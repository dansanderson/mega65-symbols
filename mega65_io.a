; Generated from: ../mega65-core/iomap.txt
; Date: 2022-06-11

!addr ETHCOMMAND_STOPTX = $00  ; Immediately stop transmitting the current ethernet frame. Will cause a partially sent frame to be received, most likely resulting in the loss of that frame.
!addr STOPTX = $00  ; Immediately stop transmitting the current ethernet frame. Will cause a partially sent frame to be received, most likely resulting in the loss of that frame.
!addr CPU_PORTDDR = $0000000  ; 6510/45GS10 CPU port DDR
!addr PORTDDR = $0000000  ; 6510/45GS10 CPU port DDR
!addr CPU_PORT = $0000001  ; 6510/45GS10 CPU port data
!addr PORT = $0000001  ; 6510/45GS10 CPU port data
!addr ETHCOMMAND_STARTTX = $01  ; Transmit packet
!addr STARTTX = $01  ; Transmit packet
!addr ETHCOMMAND_RXNORMAL = $D0  ; Disable the effects of RXONLYONE
!addr RXNORMAL = $D0  ; Disable the effects of RXONLYONE
!addr VIC2_S0X = $D000  ; sprite N horizontal position
!addr S0X = $D000  ; sprite N horizontal position
!addr VIC2_S0Y = $D001  ; sprite N vertical position
!addr S0Y = $D001  ; sprite N vertical position
!addr VIC2_S1X = $D002  ; @SNX
!addr S1X = $D002  ; @SNX
!addr VIC2_S1Y = $D003  ; @SNY
!addr S1Y = $D003  ; @SNY
!addr VIC2_S2X = $D004  ; @SNX
!addr S2X = $D004  ; @SNX
!addr VIC2_S2Y = $D005  ; @SNY
!addr S2Y = $D005  ; @SNY
!addr VIC2_S3X = $D006  ; @SNX
!addr S3X = $D006  ; @SNX
!addr VIC2_S3Y = $D007  ; @SNY
!addr S3Y = $D007  ; @SNY
!addr VIC2_S4X = $D008  ; @SNX
!addr S4X = $D008  ; @SNX
!addr VIC2_S4Y = $D009  ; @SNY
!addr S4Y = $D009  ; @SNY
!addr VIC2_S5X = $D00A  ; @SNX
!addr S5X = $D00A  ; @SNX
!addr VIC2_S5Y = $D00B  ; @SNY
!addr S5Y = $D00B  ; @SNY
!addr VIC2_S6X = $D00C  ; @SNX
!addr S6X = $D00C  ; @SNX
!addr VIC2_S6Y = $D00D  ; @SNY
!addr S6Y = $D00D  ; @SNY
!addr VIC2_S7X = $D00E  ; @SNX
!addr S7X = $D00E  ; @SNX
!addr VIC2_S7Y = $D00F  ; @SNY
!addr S7Y = $D00F  ; @SNY
!addr VIC2_SXMSB = $D010  ; sprite horizontal position MSBs
!addr SXMSB = $D010  ; sprite horizontal position MSBs
!addr VIC2_YSCL_ADDR = $D011  ; 24/25 vertical smooth scroll (address)
!addr YSCL_ADDR = $D011  ; 24/25 vertical smooth scroll (address)
VIC2_YSCL_MASK = %00000111  ; 24/25 vertical smooth scroll (bit mask)
!addr YSCL_MASK = %00000111  ; 24/25 vertical smooth scroll (bit mask)
!addr VIC2_RSEL_ADDR = $D011  ; 24/25 row select (address)
!addr RSEL_ADDR = $D011  ; 24/25 row select (address)
VIC2_RSEL_MASK = %00001000  ; 24/25 row select (bit mask)
!addr RSEL_MASK = %00001000  ; 24/25 row select (bit mask)
!addr VIC2_BLNK_ADDR = $D011  ; disable display (address)
!addr BLNK_ADDR = $D011  ; disable display (address)
VIC2_BLNK_MASK = %00010000  ; disable display (bit mask)
!addr BLNK_MASK = %00010000  ; disable display (bit mask)
!addr VIC2_BMM_ADDR = $D011  ; bitmap mode (address)
!addr BMM_ADDR = $D011  ; bitmap mode (address)
VIC2_BMM_MASK = %00100000  ; bitmap mode (bit mask)
!addr BMM_MASK = %00100000  ; bitmap mode (bit mask)
!addr VIC2_ECM_ADDR = $D011  ; extended background mode (address)
!addr ECM_ADDR = $D011  ; extended background mode (address)
VIC2_ECM_MASK = %01000000  ; extended background mode (bit mask)
!addr ECM_MASK = %01000000  ; extended background mode (bit mask)
!addr VIC2_RC_ADDR = $D011  ; raster compare bit 8 (address)
!addr RC_ADDR = $D011  ; raster compare bit 8 (address)
VIC2_RC_MASK = %10000000  ; raster compare bit 8 (bit mask)
!addr RC_MASK = %10000000  ; raster compare bit 8 (bit mask)
!addr VIC2_RC = $D012  ; raster compare bits 0 to 7
!addr RC = $D012  ; raster compare bits 0 to 7
!addr VIC2_LPX = $D013  ; Coarse horizontal beam position (was lightpen X)
!addr LPX = $D013  ; Coarse horizontal beam position (was lightpen X)
!addr VIC2_LPY = $D014  ; Coarse vertical beam position (was lightpen Y)
!addr LPY = $D014  ; Coarse vertical beam position (was lightpen Y)
!addr VIC2_SE = $D015  ; sprite enable bits
!addr SE = $D015  ; sprite enable bits
!addr VIC2_XSCL_ADDR = $D016  ; horizontal smooth scroll (address)
!addr XSCL_ADDR = $D016  ; horizontal smooth scroll (address)
VIC2_XSCL_MASK = %00000111  ; horizontal smooth scroll (bit mask)
!addr XSCL_MASK = %00000111  ; horizontal smooth scroll (bit mask)
!addr VIC2_CSEL_ADDR = $D016  ; 38/40 column select (address)
!addr CSEL_ADDR = $D016  ; 38/40 column select (address)
VIC2_CSEL_MASK = %00001000  ; 38/40 column select (bit mask)
!addr CSEL_MASK = %00001000  ; 38/40 column select (bit mask)
!addr VIC2_MCM_ADDR = $D016  ; Multi-colour mode (address)
!addr MCM_ADDR = $D016  ; Multi-colour mode (address)
VIC2_MCM_MASK = %00010000  ; Multi-colour mode (bit mask)
!addr MCM_MASK = %00010000  ; Multi-colour mode (bit mask)
!addr VIC2_RST_ADDR = $D016  ; Disables video output on MAX Machine(tm) VIC-II 6566. Ignored on normal C64s and the MEGA65 (address)
VIC2_RST_MASK = %00100000  ; Disables video output on MAX Machine(tm) VIC-II 6566. Ignored on normal C64s and the MEGA65 (bit mask)
!addr VIC2_SEXY = $D017  ; sprite vertical expansion enable bits
!addr SEXY = $D017  ; sprite vertical expansion enable bits
!addr VIC2_CB_ADDR = $D018  ; character set address location ($\times$ 1KiB) (address)
!addr CB_ADDR = $D018  ; character set address location ($\times$ 1KiB) (address)
VIC2_CB_MASK = %00001110  ; character set address location ($\times$ 1KiB) (bit mask)
!addr CB_MASK = %00001110  ; character set address location ($\times$ 1KiB) (bit mask)
!addr VIC2_VS_ADDR = $D018  ; screen address ($\times$ 1KiB) (address)
!addr VS_ADDR = $D018  ; screen address ($\times$ 1KiB) (address)
VIC2_VS_MASK = %11110000  ; screen address ($\times$ 1KiB) (bit mask)
!addr VS_MASK = %11110000  ; screen address ($\times$ 1KiB) (bit mask)
!addr VIC2_RIRQ_ADDR = $D019  ; raster compare indicate or acknowledge (address)
!addr RIRQ_ADDR = $D019  ; raster compare indicate or acknowledge (address)
VIC2_RIRQ_MASK = %00000001  ; raster compare indicate or acknowledge (bit mask)
!addr RIRQ_MASK = %00000001  ; raster compare indicate or acknowledge (bit mask)
!addr VIC2_ISBC_ADDR = $D019  ; sprite:bitmap collision indicate or acknowledge (address)
!addr ISBC_ADDR = $D019  ; sprite:bitmap collision indicate or acknowledge (address)
VIC2_ISBC_MASK = %00000010  ; sprite:bitmap collision indicate or acknowledge (bit mask)
!addr ISBC_MASK = %00000010  ; sprite:bitmap collision indicate or acknowledge (bit mask)
!addr VIC2_ISSC_ADDR = $D019  ; sprite:sprite collision indicate or acknowledge (address)
!addr ISSC_ADDR = $D019  ; sprite:sprite collision indicate or acknowledge (address)
VIC2_ISSC_MASK = %00000100  ; sprite:sprite collision indicate or acknowledge (bit mask)
!addr ISSC_MASK = %00000100  ; sprite:sprite collision indicate or acknowledge (bit mask)
!addr VIC2_ILP_ADDR = $D019  ; light pen indicate or acknowledge (address)
!addr ILP_ADDR = $D019  ; light pen indicate or acknowledge (address)
VIC2_ILP_MASK = %00001000  ; light pen indicate or acknowledge (bit mask)
!addr ILP_MASK = %00001000  ; light pen indicate or acknowledge (bit mask)
!addr VIC2_MRIRQ_ADDR = $D01A  ; mask raster IRQ (address)
!addr MRIRQ_ADDR = $D01A  ; mask raster IRQ (address)
VIC2_MRIRQ_MASK = %00000001  ; mask raster IRQ (bit mask)
!addr MRIRQ_MASK = %00000001  ; mask raster IRQ (bit mask)
!addr VIC2_MISBC_ADDR = $D01A  ; mask sprite:bitmap collision IRQ (address)
!addr MISBC_ADDR = $D01A  ; mask sprite:bitmap collision IRQ (address)
VIC2_MISBC_MASK = %00000010  ; mask sprite:bitmap collision IRQ (bit mask)
!addr MISBC_MASK = %00000010  ; mask sprite:bitmap collision IRQ (bit mask)
!addr VIC2_MISSC_ADDR = $D01A  ; mask sprite:sprite collision IRQ (address)
!addr MISSC_ADDR = $D01A  ; mask sprite:sprite collision IRQ (address)
VIC2_MISSC_MASK = %00000100  ; mask sprite:sprite collision IRQ (bit mask)
!addr MISSC_MASK = %00000100  ; mask sprite:sprite collision IRQ (bit mask)
!addr VIC2_BSP = $D01B  ; sprite background priority bits
!addr BSP = $D01B  ; sprite background priority bits
!addr VIC2_SCM = $D01C  ; sprite multicolour enable bits
!addr SCM = $D01C  ; sprite multicolour enable bits
!addr VIC2_SEXX = $D01D  ; sprite horizontal expansion enable bits
!addr SEXX = $D01D  ; sprite horizontal expansion enable bits
!addr VIC2_SSC = $D01E  ; sprite/sprite collision indicate bits
!addr SSC = $D01E  ; sprite/sprite collision indicate bits
!addr VIC2_SBC = $D01F  ; sprite/foreground collision indicate bits
!addr _SBC = $D01F  ; sprite/foreground collision indicate bits
!addr VIC2_BORDERCOL_ADDR = $D020  ; display border colour (16 colour) (address)
VIC2_BORDERCOL_MASK = %00001111  ; display border colour (16 colour) (bit mask)
!addr VIC3_BORDERCOL_ADDR = $D020  ; display border colour (256 colour) (address)
VIC3_BORDERCOL_MASK = %11111111  ; display border colour (256 colour) (bit mask)
!addr VIC4_BORDERCOL_ADDR = $D020  ; display border colour (256 colour) (address)
VIC4_BORDERCOL_MASK = %11111111  ; display border colour (256 colour) (bit mask)
!addr VIC2_SCREENCOL_ADDR = $D021  ; screen colour (16 colour) (address)
VIC2_SCREENCOL_MASK = %00001111  ; screen colour (16 colour) (bit mask)
!addr VIC3_SCREENCOL_ADDR = $D021  ; screen colour (256 colour) (address)
VIC3_SCREENCOL_MASK = %11111111  ; screen colour (256 colour) (bit mask)
!addr VIC4_SCREENCOL_ADDR = $D021  ; screen colour (256 colour) (address)
VIC4_SCREENCOL_MASK = %11111111  ; screen colour (256 colour) (bit mask)
!addr VIC2_MC1_ADDR = $D022  ; multi-colour 1 (16 colour) (address)
VIC2_MC1_MASK = %00001111  ; multi-colour 1 (16 colour) (bit mask)
!addr VIC3_MC1_ADDR = $D022  ; multi-colour 1 (256 colour) (address)
VIC3_MC1_MASK = %11111111  ; multi-colour 1 (256 colour) (bit mask)
!addr VIC4_MC1_ADDR = $D022  ; multi-colour 1 (256 colour) (address)
VIC4_MC1_MASK = %11111111  ; multi-colour 1 (256 colour) (bit mask)
!addr VIC2_MC2_ADDR = $D023  ; multi-colour 2 (16 colour) (address)
VIC2_MC2_MASK = %00001111  ; multi-colour 2 (16 colour) (bit mask)
!addr VIC3_MC2_ADDR = $D023  ; multi-colour 2 (256 colour) (address)
VIC3_MC2_MASK = %11111111  ; multi-colour 2 (256 colour) (bit mask)
!addr VIC4_MC2_ADDR = $D023  ; multi-colour 2 (256 colour) (address)
VIC4_MC2_MASK = %11111111  ; multi-colour 2 (256 colour) (bit mask)
!addr VIC2_MC3_ADDR = $D024  ; multi-colour 3 (16 colour) (address)
VIC2_MC3_MASK = %00001111  ; multi-colour 3 (16 colour) (bit mask)
!addr VIC3_MC3_ADDR = $D024  ; multi-colour 3 (256 colour) (address)
VIC3_MC3_MASK = %11111111  ; multi-colour 3 (256 colour) (bit mask)
!addr VIC4_MC3_ADDR = $D024  ; multi-colour 3 (256 colour) (address)
VIC4_MC3_MASK = %11111111  ; multi-colour 3 (256 colour) (bit mask)
!addr VIC2_SPRMC0 = $D025  ; Sprite multi-colour 0
!addr VIC3_SPRMC0 = $D025  ; Sprite multi-colour 0 (8-bit for selection of any palette colour)
!addr VIC4_SPRMC0 = $D025  ; Sprite multi-colour 0 (8-bit for selection of any palette colour)
!addr VIC2_SPRMC1 = $D026  ; Sprite multi-colour 1
!addr VIC3_SPRMC1 = $D026  ; Sprite multi-colour 1 (8-bit for selection of any palette colour)
!addr VIC4_SPRMC1 = $D026  ; Sprite multi-colour 1 (8-bit for selection of any palette colour)
!addr VIC2_SPR0COL = $D027  ; sprite N colour / 16-colour sprite transparency colour (lower nybl)
!addr SPR0COL = $D027  ; sprite N colour / 16-colour sprite transparency colour (lower nybl)
!addr VIC2_SPR1COL = $D028  ; @SPRNCOL
!addr SPR1COL = $D028  ; @SPRNCOL
!addr VIC2_SPR2COL = $D029  ; @SPRNCOL
!addr SPR2COL = $D029  ; @SPRNCOL
!addr VIC2_SPR3COL = $D02A  ; @SPRNCOL
!addr SPR3COL = $D02A  ; @SPRNCOL
!addr VIC2_SPR4COL = $D02B  ; @SPRNCOL
!addr SPR4COL = $D02B  ; @SPRNCOL
!addr VIC2_SPR5COL = $D02C  ; @SPRNCOL
!addr SPR5COL = $D02C  ; @SPRNCOL
!addr VIC2_SPR6COL = $D02D  ; @SPRNCOL
!addr SPR6COL = $D02D  ; @SPRNCOL
!addr VIC2_SPR7COL = $D02E  ; @SPRNCOL
!addr SPR7COL = $D02E  ; @SPRNCOL
!addr VIC3_KEY = $D02F  ; Write $A5 then $96 to enable C65/VIC-III IO registers
!addr VIC4_KEY = $D02F  ; Write $45 then $54 to map 45E100 ethernet controller buffers to $D000-$DFFF
!addr GS_VIC4_KEY = $D02F  ; Write $47 then $53 to enable C65GS/VIC-IV IO registers
!addr SUMMARY_VIC_III = $D030  ; Control Register A
!addr VIC2_C128_FAST_ADDR = $D030  ; 2MHz select (for C128 2MHz emulation) (address)
!addr C128_FAST_ADDR = $D030  ; 2MHz select (for C128 2MHz emulation) (address)
VIC2_C128_FAST_MASK = %00000001  ; 2MHz select (for C128 2MHz emulation) (bit mask)
!addr C128_FAST_MASK = %00000001  ; 2MHz select (for C128 2MHz emulation) (bit mask)
!addr VIC3_CRAM2K_ADDR = $D030  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (address)
!addr CRAM2K_ADDR = $D030  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (address)
VIC3_CRAM2K_MASK = %00000001  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (bit mask)
!addr CRAM2K_MASK = %00000001  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (bit mask)
!addr VIC3_EXTSYNC_ADDR = $D030  ; Enable external video sync (genlock input) (address)
!addr EXTSYNC_ADDR = $D030  ; Enable external video sync (genlock input) (address)
VIC3_EXTSYNC_MASK = %00000010  ; Enable external video sync (genlock input) (bit mask)
!addr EXTSYNC_MASK = %00000010  ; Enable external video sync (genlock input) (bit mask)
!addr VIC3_PAL_ADDR = $D030  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (address)
!addr PAL_ADDR = $D030  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (address)
VIC3_PAL_MASK = %00000100  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (bit mask)
!addr PAL_MASK = %00000100  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (bit mask)
!addr VIC3_ROM8_ADDR = $D030  ; Map C65 ROM @ $8000 (address)
!addr ROM8_ADDR = $D030  ; Map C65 ROM @ $8000 (address)
VIC3_ROM8_MASK = %00001000  ; Map C65 ROM @ $8000 (bit mask)
!addr ROM8_MASK = %00001000  ; Map C65 ROM @ $8000 (bit mask)
!addr VIC3_ROMA_ADDR = $D030  ; Map C65 ROM @ $A000 (address)
!addr ROMA_ADDR = $D030  ; Map C65 ROM @ $A000 (address)
VIC3_ROMA_MASK = %00010000  ; Map C65 ROM @ $A000 (bit mask)
!addr ROMA_MASK = %00010000  ; Map C65 ROM @ $A000 (bit mask)
!addr VIC3_ROMC_ADDR = $D030  ; Map C65 ROM @ $C000 (address)
!addr ROMC_ADDR = $D030  ; Map C65 ROM @ $C000 (address)
VIC3_ROMC_MASK = %00100000  ; Map C65 ROM @ $C000 (bit mask)
!addr ROMC_MASK = %00100000  ; Map C65 ROM @ $C000 (bit mask)
!addr VIC3_CROM9_ADDR = $D030  ; Select between C64 and C65 charset. (address)
!addr CROM9_ADDR = $D030  ; Select between C64 and C65 charset. (address)
VIC3_CROM9_MASK = %01000000  ; Select between C64 and C65 charset. (bit mask)
!addr CROM9_MASK = %01000000  ; Select between C64 and C65 charset. (bit mask)
!addr VIC3_ROME_ADDR = $D030  ; Map C65 ROM @ $E000 (address)
!addr ROME_ADDR = $D030  ; Map C65 ROM @ $E000 (address)
VIC3_ROME_MASK = %10000000  ; Map C65 ROM @ $E000 (bit mask)
!addr ROME_MASK = %10000000  ; Map C65 ROM @ $E000 (bit mask)
!addr C65_SUMMARY_VIC_III = $D031  ; Control Register B
!addr VIC3_INT_ADDR = $D031  ; Enable VIC-III interlaced mode (address)
!addr INT_ADDR = $D031  ; Enable VIC-III interlaced mode (address)
VIC3_INT_MASK = %00000001  ; Enable VIC-III interlaced mode (bit mask)
!addr INT_MASK = %00000001  ; Enable VIC-III interlaced mode (bit mask)
!addr VIC3_MONO_ADDR = $D031  ; Enable VIC-III MONO video output (not implemented) (address)
!addr MONO_ADDR = $D031  ; Enable VIC-III MONO video output (not implemented) (address)
VIC3_MONO_MASK = %00000010  ; Enable VIC-III MONO video output (not implemented) (bit mask)
!addr MONO_MASK = %00000010  ; Enable VIC-III MONO video output (not implemented) (bit mask)
!addr VIC3_H1280_ADDR = $D031  ; Enable 1280 horizontal pixels (not implemented) (address)
!addr H1280_ADDR = $D031  ; Enable 1280 horizontal pixels (not implemented) (address)
VIC3_H1280_MASK = %00000100  ; Enable 1280 horizontal pixels (not implemented) (bit mask)
!addr H1280_MASK = %00000100  ; Enable 1280 horizontal pixels (not implemented) (bit mask)
!addr VIC3_V400_ADDR = $D031  ; Enable 400 vertical pixels (address)
!addr V400_ADDR = $D031  ; Enable 400 vertical pixels (address)
VIC3_V400_MASK = %00001000  ; Enable 400 vertical pixels (bit mask)
!addr V400_MASK = %00001000  ; Enable 400 vertical pixels (bit mask)
!addr VIC3_BPM_ADDR = $D031  ; Bit-Plane Mode (address)
!addr BPM_ADDR = $D031  ; Bit-Plane Mode (address)
VIC3_BPM_MASK = %00010000  ; Bit-Plane Mode (bit mask)
!addr BPM_MASK = %00010000  ; Bit-Plane Mode (bit mask)
!addr VIC3_ATTR_ADDR = $D031  ; Enable extended attributes and 8 bit colour entries (address)
!addr ATTR_ADDR = $D031  ; Enable extended attributes and 8 bit colour entries (address)
VIC3_ATTR_MASK = %00100000  ; Enable extended attributes and 8 bit colour entries (bit mask)
!addr ATTR_MASK = %00100000  ; Enable extended attributes and 8 bit colour entries (bit mask)
!addr VIC3_FAST_ADDR = $D031  ; Enable C65 FAST mode (~3.5MHz) (address)
!addr FAST_ADDR = $D031  ; Enable C65 FAST mode (~3.5MHz) (address)
VIC3_FAST_MASK = %01000000  ; Enable C65 FAST mode (~3.5MHz) (bit mask)
!addr FAST_MASK = %01000000  ; Enable C65 FAST mode (~3.5MHz) (bit mask)
!addr VIC3_H640_ADDR = $D031  ; Enable C64 640 horizontal pixels / 80 column mode (address)
!addr H640_ADDR = $D031  ; Enable C64 640 horizontal pixels / 80 column mode (address)
VIC3_H640_MASK = %10000000  ; Enable C64 640 horizontal pixels / 80 column mode (bit mask)
!addr H640_MASK = %10000000  ; Enable C64 640 horizontal pixels / 80 column mode (bit mask)
!addr VIC3_B0ADEVN_ADDR = $D033  ; Bitplane X address, even lines (address)
!addr B0ADEVN_ADDR = $D033  ; Bitplane X address, even lines (address)
VIC3_B0ADEVN_MASK = %00001110  ; Bitplane X address, even lines (bit mask)
!addr B0ADEVN_MASK = %00001110  ; Bitplane X address, even lines (bit mask)
!addr VIC3_B0ADODD_ADDR = $D033  ; Bitplane X address, odd lines (address)
!addr B0ADODD_ADDR = $D033  ; Bitplane X address, odd lines (address)
VIC3_B0ADODD_MASK = %11100000  ; Bitplane X address, odd lines (bit mask)
!addr B0ADODD_MASK = %11100000  ; Bitplane X address, odd lines (bit mask)
!addr VIC3_B1ADEVN_ADDR = $D034  ; @BXADEVN (address)
!addr B1ADEVN_ADDR = $D034  ; @BXADEVN (address)
VIC3_B1ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr B1ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr VIC3_B1ADODD_ADDR = $D034  ; @BXADODD (address)
!addr B1ADODD_ADDR = $D034  ; @BXADODD (address)
VIC3_B1ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr B1ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr VIC3_B2ADEVN_ADDR = $D035  ; @BXADEVN (address)
!addr B2ADEVN_ADDR = $D035  ; @BXADEVN (address)
VIC3_B2ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr B2ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr VIC3_B2ADODD_ADDR = $D035  ; @BXADODD (address)
!addr B2ADODD_ADDR = $D035  ; @BXADODD (address)
VIC3_B2ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr B2ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr VIC3_B3ADEVN_ADDR = $D036  ; @BXADEVN (address)
!addr B3ADEVN_ADDR = $D036  ; @BXADEVN (address)
VIC3_B3ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr B3ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr VIC3_B3ADODD_ADDR = $D036  ; @BXADODD (address)
!addr B3ADODD_ADDR = $D036  ; @BXADODD (address)
VIC3_B3ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr B3ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr VIC3_B4ADEVN_ADDR = $D037  ; @BXADEVN (address)
!addr B4ADEVN_ADDR = $D037  ; @BXADEVN (address)
VIC3_B4ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr B4ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr VIC3_B4ADODD_ADDR = $D037  ; @BXADODD (address)
!addr B4ADODD_ADDR = $D037  ; @BXADODD (address)
VIC3_B4ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr B4ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr VIC3_B5ADEVN_ADDR = $D038  ; @BXADEVN (address)
!addr B5ADEVN_ADDR = $D038  ; @BXADEVN (address)
VIC3_B5ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr B5ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr VIC3_B5ADODD_ADDR = $D038  ; @BXADODD (address)
!addr B5ADODD_ADDR = $D038  ; @BXADODD (address)
VIC3_B5ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr B5ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr VIC3_B6ADEVN_ADDR = $D039  ; @BXADEVN (address)
!addr B6ADEVN_ADDR = $D039  ; @BXADEVN (address)
VIC3_B6ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr B6ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr VIC3_B6ADODD_ADDR = $D039  ; @BXADODD (address)
!addr B6ADODD_ADDR = $D039  ; @BXADODD (address)
VIC3_B6ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr B6ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr VIC3_B7ADEVN_ADDR = $D03A  ; @BXADEVN (address)
!addr B7ADEVN_ADDR = $D03A  ; @BXADEVN (address)
VIC3_B7ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr B7ADEVN_MASK = %00001110  ; @BXADEVN (bit mask)
!addr VIC3_B7ADODD_ADDR = $D03A  ; @BXADODD (address)
!addr B7ADODD_ADDR = $D03A  ; @BXADODD (address)
VIC3_B7ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr B7ADODD_MASK = %11100000  ; @BXADODD (bit mask)
!addr VIC3_BPCOMP = $D03B  ; Complement bitplane flags
!addr BPCOMP = $D03B  ; Complement bitplane flags
!addr VIC3_BPX = $D03C  ; Bitplane X
!addr BPX = $D03C  ; Bitplane X
!addr VIC3_BPY = $D03D  ; Bitplane Y
!addr BPY = $D03D  ; Bitplane Y
!addr VIC3_HPOS = $D03E  ; Bitplane X Offset
!addr HPOS = $D03E  ; Bitplane X Offset
!addr VIC3_VPOS = $D03F  ; Bitplane Y Offset
!addr VPOS = $D03F  ; Bitplane Y Offset
!addr VIC3_B0PIX = $D040  ; Display Address Translater (DAT) Bitplane N port
!addr B0PIX = $D040  ; Display Address Translater (DAT) Bitplane N port
!addr VIC3_B1PIX = $D041  ; @BNPIX
!addr B1PIX = $D041  ; @BNPIX
!addr VIC3_B2PIX = $D042  ; @BNPIX
!addr B2PIX = $D042  ; @BNPIX
!addr VIC3_B3PIX = $D043  ; @BNPIX
!addr B3PIX = $D043  ; @BNPIX
!addr VIC3_B4PIX = $D044  ; @BNPIX
!addr B4PIX = $D044  ; @BNPIX
!addr VIC3_B5PIX = $D045  ; @BNPIX
!addr B5PIX = $D045  ; @BNPIX
!addr VIC3_B6PIX = $D046  ; @BNPIX
!addr B6PIX = $D046  ; @BNPIX
!addr VIC3_B7PIX = $D047  ; @BNPIX
!addr B7PIX = $D047  ; @BNPIX
!addr VIC4_TBDRPOS = $D048  ; top border position
!addr TBDRPOS = $D048  ; top border position
!addr VIC4_TBDRPOS_ADDR = $D049  ; top border position MSB (address)
!addr TBDRPOS_ADDR = $D049  ; top border position MSB (address)
VIC4_TBDRPOS_MASK = %00001111  ; top border position MSB (bit mask)
!addr TBDRPOS_MASK = %00001111  ; top border position MSB (bit mask)
!addr VIC4_SPRBPMEN_ADDR = $D049  ; Sprite bitplane-modify-mode enables (address)
VIC4_SPRBPMEN_MASK = %11110000  ; Sprite bitplane-modify-mode enables (bit mask)
!addr VIC4_BBDRPOS = $D04A  ; bottom border position
!addr BBDRPOS = $D04A  ; bottom border position
!addr VIC4_BBDRPOS_ADDR = $D04B  ; bottom border position (address)
!addr BBDRPOS_ADDR = $D04B  ; bottom border position (address)
VIC4_BBDRPOS_MASK = %00001111  ; bottom border position (bit mask)
!addr BBDRPOS_MASK = %00001111  ; bottom border position (bit mask)
!addr GS_VIC4_SPRBPMEN_ADDR = $D04B  ; Sprite bitplane-modify-mode enables (address)
GS_VIC4_SPRBPMEN_MASK = %11110000  ; Sprite bitplane-modify-mode enables (bit mask)
!addr VIC4_TEXTXPOS = $D04C  ; character generator horizontal position
!addr TEXTXPOS = $D04C  ; character generator horizontal position
!addr VIC4_TEXTXPOS_ADDR = $D04D  ; character generator horizontal position (address)
!addr TEXTXPOS_ADDR = $D04D  ; character generator horizontal position (address)
VIC4_TEXTXPOS_MASK = %00001111  ; character generator horizontal position (bit mask)
!addr TEXTXPOS_MASK = %00001111  ; character generator horizontal position (bit mask)
!addr VIC4_SPRTILEN_ADDR = $D04D  ; Sprite horizontal tile enables. (address)
VIC4_SPRTILEN_MASK = %11110000  ; Sprite horizontal tile enables. (bit mask)
!addr VIC4_TEXTYPOS = $D04E  ; Character generator vertical position
!addr TEXTYPOS = $D04E  ; Character generator vertical position
!addr VIC4_TEXTYPOS_ADDR = $D04F  ; Character generator vertical position (address)
!addr TEXTYPOS_ADDR = $D04F  ; Character generator vertical position (address)
VIC4_TEXTYPOS_MASK = %00001111  ; Character generator vertical position (bit mask)
!addr TEXTYPOS_MASK = %00001111  ; Character generator vertical position (bit mask)
!addr GS_VIC4_SPRTILEN_ADDR = $D04F  ; Sprite 7-4 horizontal tile enables (address)
GS_VIC4_SPRTILEN_MASK = %11110000  ; Sprite 7-4 horizontal tile enables (bit mask)
!addr VIC4_XPOSLSB = $D050  ; Read horizontal raster scan position LSB
!addr XPOSLSB = $D050  ; Read horizontal raster scan position LSB
!addr VIC4_XPOSMSB_ADDR = $D051  ; Read horizontal raster scan position MSB (address)
!addr XPOSMSB_ADDR = $D051  ; Read horizontal raster scan position MSB (address)
VIC4_XPOSMSB_MASK = %00111111  ; Read horizontal raster scan position MSB (bit mask)
!addr XPOSMSB_MASK = %00111111  ; Read horizontal raster scan position MSB (bit mask)
!addr VIC4_DBLRR_ADDR = $D051  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (address)
!addr DBLRR_ADDR = $D051  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (address)
VIC4_DBLRR_MASK = %01000000  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (bit mask)
!addr DBLRR_MASK = %01000000  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (bit mask)
!addr VIC4_NORRDEL_ADDR = $D051  ; When clear, raster rewrite double buffering is used (address)
!addr NORRDEL_ADDR = $D051  ; When clear, raster rewrite double buffering is used (address)
VIC4_NORRDEL_MASK = %10000000  ; When clear, raster rewrite double buffering is used (bit mask)
!addr NORRDEL_MASK = %10000000  ; When clear, raster rewrite double buffering is used (bit mask)
!addr VIC4_FNRASTERLSB = $D052  ; Read physical raster position
!addr FNRASTERLSB = $D052  ; Read physical raster position
!addr VIC4_FN_RASTER_MSB_ADDR = $D053  ; Read physical raster position (address)
!addr FN_RASTER_MSB_ADDR = $D053  ; Read physical raster position (address)
VIC4_FN_RASTER_MSB_MASK = %00000111  ; Read physical raster position (bit mask)
!addr FN_RASTER_MSB_MASK = %00000111  ; Read physical raster position (bit mask)
!addr VIC4_SHDEMU_ADDR = $D053  ; Enable simulated shadow-mask (PALEMU must also be enabled) (address)
!addr SHDEMU_ADDR = $D053  ; Enable simulated shadow-mask (PALEMU must also be enabled) (address)
VIC4_SHDEMU_MASK = %01000000  ; Enable simulated shadow-mask (PALEMU must also be enabled) (bit mask)
!addr SHDEMU_MASK = %01000000  ; Enable simulated shadow-mask (PALEMU must also be enabled) (bit mask)
!addr VIC4_FNRST_ADDR = $D053  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (address)
!addr FNRST_ADDR = $D053  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (address)
VIC4_FNRST_MASK = %10000000  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (bit mask)
!addr FNRST_MASK = %10000000  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (bit mask)
!addr SUMMARY_VIC_IV = $D054  ; Control register C
!addr VIC_IV = $D054  ; Control register C
!addr VIC4_CHR16_ADDR = $D054  ; enable 16-bit character numbers (two screen bytes per character) (address)
!addr CHR16_ADDR = $D054  ; enable 16-bit character numbers (two screen bytes per character) (address)
VIC4_CHR16_MASK = %00000001  ; enable 16-bit character numbers (two screen bytes per character) (bit mask)
!addr CHR16_MASK = %00000001  ; enable 16-bit character numbers (two screen bytes per character) (bit mask)
!addr VIC4_FCLRLO_ADDR = $D054  ; enable full-colour mode for character numbers <=$FF (address)
!addr FCLRLO_ADDR = $D054  ; enable full-colour mode for character numbers <=$FF (address)
VIC4_FCLRLO_MASK = %00000010  ; enable full-colour mode for character numbers <=$FF (bit mask)
!addr FCLRLO_MASK = %00000010  ; enable full-colour mode for character numbers <=$FF (bit mask)
!addr VIC4_FCLRHI_ADDR = $D054  ; enable full-colour mode for character numbers >$FF (address)
!addr FCLRHI_ADDR = $D054  ; enable full-colour mode for character numbers >$FF (address)
VIC4_FCLRHI_MASK = %00000100  ; enable full-colour mode for character numbers >$FF (bit mask)
!addr FCLRHI_MASK = %00000100  ; enable full-colour mode for character numbers >$FF (bit mask)
!addr VIC4_SMTH_ADDR = $D054  ; video output horizontal smoothing enable (address)
!addr SMTH_ADDR = $D054  ; video output horizontal smoothing enable (address)
VIC4_SMTH_MASK = %00001000  ; video output horizontal smoothing enable (bit mask)
!addr SMTH_MASK = %00001000  ; video output horizontal smoothing enable (bit mask)
!addr VIC4_SPR640_ADDR = $D054  ; Sprite H640 enable; (address)
!addr SPR640_ADDR = $D054  ; Sprite H640 enable; (address)
VIC4_SPR640_MASK = %00010000  ; Sprite H640 enable; (bit mask)
!addr SPR640_MASK = %00010000  ; Sprite H640 enable; (bit mask)
!addr VIC4_PALEMU_ADDR = $D054  ; Enable PAL CRT-like scan-line emulation (address)
!addr PALEMU_ADDR = $D054  ; Enable PAL CRT-like scan-line emulation (address)
VIC4_PALEMU_MASK = %00100000  ; Enable PAL CRT-like scan-line emulation (bit mask)
!addr PALEMU_MASK = %00100000  ; Enable PAL CRT-like scan-line emulation (bit mask)
!addr VIC4_VFAST_ADDR = $D054  ; C65GS FAST mode (48MHz) (address)
!addr VFAST_ADDR = $D054  ; C65GS FAST mode (48MHz) (address)
VIC4_VFAST_MASK = %01000000  ; C65GS FAST mode (48MHz) (bit mask)
!addr VFAST_MASK = %01000000  ; C65GS FAST mode (48MHz) (bit mask)
!addr VIC4_ALPHEN_ADDR = $D054  ; Alpha compositor enable (address)
!addr ALPHEN_ADDR = $D054  ; Alpha compositor enable (address)
VIC4_ALPHEN_MASK = %10000000  ; Alpha compositor enable (bit mask)
!addr ALPHEN_MASK = %10000000  ; Alpha compositor enable (bit mask)
!addr VIC4_SPRHGTEN = $D055  ; sprite extended height enable (one bit per sprite)
!addr SPRHGTEN = $D055  ; sprite extended height enable (one bit per sprite)
!addr VIC4_SPRHGHT = $D056  ; Sprite extended height size (sprite pixels high)
!addr SPRHGHT = $D056  ; Sprite extended height size (sprite pixels high)
!addr VIC4_SPRX64EN = $D057  ; Sprite extended width enables (8 bytes per sprite row = 64 pixels wide for normal sprites or 16 pixels wide for 16-colour sprite mode)
!addr SPRX64EN = $D057  ; Sprite extended width enables (8 bytes per sprite row = 64 pixels wide for normal sprites or 16 pixels wide for 16-colour sprite mode)
!addr VIC4_LINESTEPLSB = $D058  ; number of bytes to advance between each text row (LSB)
!addr LINESTEPLSB = $D058  ; number of bytes to advance between each text row (LSB)
!addr VIC4_LINESTEPMSB = $D059  ; number of bytes to advance between each text row (MSB)
!addr LINESTEPMSB = $D059  ; number of bytes to advance between each text row (MSB)
!addr VIC4_CHRXSCL = $D05A  ; Horizontal hardware scale of text mode (pixel 120ths per pixel)
!addr CHRXSCL = $D05A  ; Horizontal hardware scale of text mode (pixel 120ths per pixel)
!addr VIC4_CHRYSCL = $D05B  ; Vertical scaling of text mode (number of physical rasters per char text row)
!addr CHRYSCL = $D05B  ; Vertical scaling of text mode (number of physical rasters per char text row)
!addr VIC4_SDBDRWD_LSB = $D05C  ; Width of single side border (LSB)
!addr SDBDRWD_LSB = $D05C  ; Width of single side border (LSB)
!addr VIC4_SDBDRWD_MSB_ADDR = $D05D  ; side border width (MSB) (address)
!addr SDBDRWD_MSB_ADDR = $D05D  ; side border width (MSB) (address)
VIC4_SDBDRWD_MSB_MASK = %00111111  ; side border width (MSB) (bit mask)
!addr SDBDRWD_MSB_MASK = %00111111  ; side border width (MSB) (bit mask)
!addr VIC4_RST_DELEN_ADDR = $D05D  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (address)
!addr RST_DELEN_ADDR = $D05D  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (address)
VIC4_RST_DELEN_MASK = %01000000  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (bit mask)
!addr RST_DELEN_MASK = %01000000  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (bit mask)
!addr VIC4_HOTREG_ADDR = $D05D  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (address)
!addr HOTREG_ADDR = $D05D  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (address)
VIC4_HOTREG_MASK = %10000000  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (bit mask)
!addr HOTREG_MASK = %10000000  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (bit mask)
!addr VIC4_CHRCOUNT = $D05E  ; Number of characters to display per row (LSB)
!addr CHRCOUNT = $D05E  ; Number of characters to display per row (LSB)
!addr VIC4_SPRXSMSBS = $D05F  ; Sprite H640 X Super-MSBs
!addr SPRXSMSBS = $D05F  ; Sprite H640 X Super-MSBs
!addr VIC4_SCRNPTRLSB = $D060  ; screen RAM precise base address (bits 0 - 7)
!addr SCRNPTRLSB = $D060  ; screen RAM precise base address (bits 0 - 7)
!addr VIC4_SCRNPTRMSB = $D061  ; screen RAM precise base address (bits 15 - 8)
!addr SCRNPTRMSB = $D061  ; screen RAM precise base address (bits 15 - 8)
!addr VIC4_SCRNPTRBNK = $D062  ; screen RAM precise base address (bits 23 - 16)
!addr SCRNPTRBNK = $D062  ; screen RAM precise base address (bits 23 - 16)
!addr VIC4_SCRNPTRMB_ADDR = $D063  ; screen RAM precise base address (bits 31 - 24) (address)
!addr SCRNPTRMB_ADDR = $D063  ; screen RAM precise base address (bits 31 - 24) (address)
VIC4_SCRNPTRMB_MASK = %00001111  ; screen RAM precise base address (bits 31 - 24) (bit mask)
!addr SCRNPTRMB_MASK = %00001111  ; screen RAM precise base address (bits 31 - 24) (bit mask)
!addr VIC4_CHRCOUNT_ADDR = $D063  ; Number of characters to display per (address)
!addr CHRCOUNT_ADDR = $D063  ; Number of characters to display per (address)
VIC4_CHRCOUNT_MASK = %00110000  ; Number of characters to display per (bit mask)
!addr CHRCOUNT_MASK = %00110000  ; Number of characters to display per (bit mask)
!addr VIC4_EXGLYPH_ADDR = $D063  ; source full-colour character data from expansion RAM (address)
!addr EXGLYPH_ADDR = $D063  ; source full-colour character data from expansion RAM (address)
VIC4_EXGLYPH_MASK = %10000000  ; source full-colour character data from expansion RAM (bit mask)
!addr EXGLYPH_MASK = %10000000  ; source full-colour character data from expansion RAM (bit mask)
!addr VIC4_COLPTRLSB = $D064  ; colour RAM base address (bits 0 - 7)
!addr COLPTRLSB = $D064  ; colour RAM base address (bits 0 - 7)
!addr VIC4_COLPTRMSB = $D065  ; colour RAM base address (bits 15 - 8)
!addr COLPTRMSB = $D065  ; colour RAM base address (bits 15 - 8)
!addr DEBUG_SBPDEBUG = $D067  ; Sprite/bitplane first X DEBUG WILL BE REMOVED
!addr SBPDEBUG = $D067  ; Sprite/bitplane first X DEBUG WILL BE REMOVED
!addr VIC4_CHARPTRLSB = $D068  ; Character set precise base address (bits 0 - 7)
!addr CHARPTRLSB = $D068  ; Character set precise base address (bits 0 - 7)
!addr VIC4_CHARPTRMSB = $D069  ; Character set precise base address (bits 15 - 8)
!addr CHARPTRMSB = $D069  ; Character set precise base address (bits 15 - 8)
!addr VIC4_CHARPTRBNK = $D06A  ; Character set precise base address (bits 23 - 16)
!addr CHARPTRBNK = $D06A  ; Character set precise base address (bits 23 - 16)
!addr VIC4_SPR16EN = $D06B  ; sprite 16-colour mode enables
!addr SPR16EN = $D06B  ; sprite 16-colour mode enables
!addr VIC4_SPRPTRADRLSB = $D06C  ; sprite pointer address (bits 7 - 0)
!addr SPRPTRADRLSB = $D06C  ; sprite pointer address (bits 7 - 0)
!addr VIC4_SPRPTRADRMSB = $D06D  ; sprite pointer address (bits 15 - 8)
!addr SPRPTRADRMSB = $D06D  ; sprite pointer address (bits 15 - 8)
!addr VIC4_SPRPTRBNK_ADDR = $D06E  ; sprite pointer address (bits 23 - 16) (address)
!addr SPRPTRBNK_ADDR = $D06E  ; sprite pointer address (bits 23 - 16) (address)
VIC4_SPRPTRBNK_MASK = %01111111  ; sprite pointer address (bits 23 - 16) (bit mask)
!addr SPRPTRBNK_MASK = %01111111  ; sprite pointer address (bits 23 - 16) (bit mask)
!addr VIC4_SPR_PTR16_ADDR = $D06E  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (address)
!addr SPR_PTR16_ADDR = $D06E  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (address)
VIC4_SPR_PTR16_MASK = %10000000  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (bit mask)
!addr SPR_PTR16_MASK = %10000000  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (bit mask)
!addr VIC4_RASLINE0_ADDR = $D06F  ; first VIC-II raster line (address)
!addr RASLINE0_ADDR = $D06F  ; first VIC-II raster line (address)
VIC4_RASLINE0_MASK = %00111111  ; first VIC-II raster line (bit mask)
!addr RASLINE0_MASK = %00111111  ; first VIC-II raster line (bit mask)
!addr VIC4_VGAHDTV_ADDR = $D06F  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (address)
!addr VGAHDTV_ADDR = $D06F  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (address)
VIC4_VGAHDTV_MASK = %01000000  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (bit mask)
!addr VGAHDTV_MASK = %01000000  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (bit mask)
!addr VIC4_PALNTSC_ADDR = $D06F  ; NTSC emulation mode (max raster = 262) (address)
!addr PALNTSC_ADDR = $D06F  ; NTSC emulation mode (max raster = 262) (address)
VIC4_PALNTSC_MASK = %10000000  ; NTSC emulation mode (max raster = 262) (bit mask)
!addr PALNTSC_MASK = %10000000  ; NTSC emulation mode (max raster = 262) (bit mask)
!addr VIC4_ABTPALSEL_ADDR = $D070  ; VIC-IV bitmap/text palette bank (alternate palette) (address)
!addr ABTPALSEL_ADDR = $D070  ; VIC-IV bitmap/text palette bank (alternate palette) (address)
VIC4_ABTPALSEL_MASK = %00000011  ; VIC-IV bitmap/text palette bank (alternate palette) (bit mask)
!addr ABTPALSEL_MASK = %00000011  ; VIC-IV bitmap/text palette bank (alternate palette) (bit mask)
!addr VIC4_SPRPALSEL_ADDR = $D070  ; sprite palette bank (address)
!addr SPRPALSEL_ADDR = $D070  ; sprite palette bank (address)
VIC4_SPRPALSEL_MASK = %00001100  ; sprite palette bank (bit mask)
!addr SPRPALSEL_MASK = %00001100  ; sprite palette bank (bit mask)
!addr VIC4_BTPALSEL_ADDR = $D070  ; bitmap/text palette bank (address)
!addr BTPALSEL_ADDR = $D070  ; bitmap/text palette bank (address)
VIC4_BTPALSEL_MASK = %00110000  ; bitmap/text palette bank (bit mask)
!addr BTPALSEL_MASK = %00110000  ; bitmap/text palette bank (bit mask)
!addr VIC4_MAPEDPAL_ADDR = $D070  ; palette bank mapped at $D100-$D3FF (address)
!addr MAPEDPAL_ADDR = $D070  ; palette bank mapped at $D100-$D3FF (address)
VIC4_MAPEDPAL_MASK = %11000000  ; palette bank mapped at $D100-$D3FF (bit mask)
!addr MAPEDPAL_MASK = %11000000  ; palette bank mapped at $D100-$D3FF (bit mask)
!addr VIC4_BP16ENS = $D071  ; VIC-IV 16-colour bitplane enable flags
!addr BP16ENS = $D071  ; VIC-IV 16-colour bitplane enable flags
!addr VIC4_SPRYADJ = $D072  ; Sprite Y position adjustment
!addr SPRYADJ = $D072  ; Sprite Y position adjustment
!addr VIC4_ALPHADELAY_ADDR = $D073  ; Alpha delay for compositor (address)
!addr ALPHADELAY_ADDR = $D073  ; Alpha delay for compositor (address)
VIC4_ALPHADELAY_MASK = %00001111  ; Alpha delay for compositor (bit mask)
!addr ALPHADELAY_MASK = %00001111  ; Alpha delay for compositor (bit mask)
!addr VIC4_RASTERHEIGHT_ADDR = $D073  ; physical rasters per VIC-II raster (1 to 16) (address)
!addr RASTERHEIGHT_ADDR = $D073  ; physical rasters per VIC-II raster (1 to 16) (address)
VIC4_RASTERHEIGHT_MASK = %11110000  ; physical rasters per VIC-II raster (1 to 16) (bit mask)
!addr RASTERHEIGHT_MASK = %11110000  ; physical rasters per VIC-II raster (1 to 16) (bit mask)
!addr VIC4_SPRENALPHA = $D074  ; Sprite alpha-blend enable
!addr SPRENALPHA = $D074  ; Sprite alpha-blend enable
!addr VIC4_SPRALPHAVAL = $D075  ; Sprite alpha-blend value
!addr SPRALPHAVAL = $D075  ; Sprite alpha-blend value
!addr VIC4_SPRENV400 = $D076  ; Sprite V400 enables
!addr SPRENV400 = $D076  ; Sprite V400 enables
!addr VIC4_SRPYMSBS = $D077  ; Sprite V400 Y position MSBs
!addr SRPYMSBS = $D077  ; Sprite V400 Y position MSBs
!addr VIC4_SPRYSMSBS = $D078  ; Sprite V400 Y position super MSBs
!addr SPRYSMSBS = $D078  ; Sprite V400 Y position super MSBs
!addr VIC4_RSTCOMP = $D079  ; Raster compare value
!addr RSTCOMP = $D079  ; Raster compare value
!addr VIC4_RSTCMP_ADDR = $D07A  ; Raster compare value MSB (address)
!addr RSTCMP_ADDR = $D07A  ; Raster compare value MSB (address)
VIC4_RSTCMP_MASK = %00000111  ; Raster compare value MSB (bit mask)
!addr RSTCMP_MASK = %00000111  ; Raster compare value MSB (bit mask)
!addr VIC4_SPTR_CONT_ADDR = $D07A  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (address)
!addr SPTR_CONT_ADDR = $D07A  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (address)
VIC4_SPTR_CONT_MASK = %00001000  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (bit mask)
!addr SPTR_CONT_MASK = %00001000  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (bit mask)
!addr VIC4_RESV_ADDR = $D07A  ; Reserved. (address)
VIC4_RESV_MASK = %00110000  ; Reserved. (bit mask)
!addr VIC4_EXTIRQS_ADDR = $D07A  ; Enable additional IRQ sources, e.g., raster X position. (address)
!addr EXTIRQS_ADDR = $D07A  ; Enable additional IRQ sources, e.g., raster X position. (address)
VIC4_EXTIRQS_MASK = %01000000  ; Enable additional IRQ sources, e.g., raster X position. (bit mask)
!addr EXTIRQS_MASK = %01000000  ; Enable additional IRQ sources, e.g., raster X position. (bit mask)
!addr VIC4_FNRST_CMP_ADDR = $D07A  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (address)
!addr FNRST_CMP_ADDR = $D07A  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (address)
VIC4_FNRST_CMP_MASK = %10000000  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (bit mask)
!addr FNRST_CMP_MASK = %10000000  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (bit mask)
!addr VIC4_Number = $D07B  ; of text rows to display
!addr Number = $D07B  ; of text rows to display
!addr VIC4_BIT_PBANK_ADDR = $D07C  ; Set which 128KB bank bitplanes (address)
!addr BIT_PBANK_ADDR = $D07C  ; Set which 128KB bank bitplanes (address)
VIC4_BIT_PBANK_MASK = %00000111  ; Set which 128KB bank bitplanes (bit mask)
!addr BIT_PBANK_MASK = %00000111  ; Set which 128KB bank bitplanes (bit mask)
!addr GS_VIC4_RESV_ADDR = $D07C  ; @RESV (address)
GS_VIC4_RESV_MASK = %00001000  ; @RESV (bit mask)
!addr VIC4_HSYNCP_ADDR = $D07C  ; hsync polarity (address)
!addr HSYNCP_ADDR = $D07C  ; hsync polarity (address)
VIC4_HSYNCP_MASK = %00010000  ; hsync polarity (bit mask)
!addr HSYNCP_MASK = %00010000  ; hsync polarity (bit mask)
!addr VIC4_VSYNCP_ADDR = $D07C  ; vsync polarity (address)
!addr VSYNCP_ADDR = $D07C  ; vsync polarity (address)
VIC4_VSYNCP_MASK = %00100000  ; vsync polarity (bit mask)
!addr VSYNCP_MASK = %00100000  ; vsync polarity (bit mask)
!addr VIC4_DEBUGC_ADDR = $D07C  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (address)
!addr DEBUGC_ADDR = $D07C  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (address)
VIC4_DEBUGC_MASK = %11000000  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (bit mask)
!addr DEBUGC_MASK = %11000000  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (bit mask)
!addr DEBUG_DEBUGOUT = $D07D  ; VIC-IV debug value read-back (read only)
!addr DEBUGOUT = $D07D  ; VIC-IV debug value read-back (read only)
!addr DEBUG_DEBUGX = $D07D  ; VIC-IV debug X position (LSB) (write only)
!addr DEBUGX = $D07D  ; VIC-IV debug X position (LSB) (write only)
!addr DEBUG_DEBUGY = $D07E  ; VIC-IV debug Y position (LSB)
!addr DEBUGY = $D07E  ; VIC-IV debug Y position (LSB)
!addr DEBUG_DEBUGX_ADDR = $D07F  ; VIC-IV debug X position (MSB) (address)
!addr DEBUGX_ADDR = $D07F  ; VIC-IV debug X position (MSB) (address)
DEBUG_DEBUGX_MASK = %00001111  ; VIC-IV debug X position (MSB) (bit mask)
!addr DEBUGX_MASK = %00001111  ; VIC-IV debug X position (MSB) (bit mask)
!addr DEBUG_DEBUGY_ADDR = $D07F  ; VIC-IV debug Y position (MSB) (address)
!addr DEBUGY_ADDR = $D07F  ; VIC-IV debug Y position (MSB) (address)
DEBUG_DEBUGY_MASK = %11110000  ; VIC-IV debug Y position (MSB) (bit mask)
!addr DEBUGY_MASK = %11110000  ; VIC-IV debug Y position (MSB) (bit mask)
!addr DEBUG_DEBUGOOF_ADDR = $D07F  ; VIC-IV debug out-of-frame signal enable (address)
!addr DEBUGOOF_ADDR = $D07F  ; VIC-IV debug out-of-frame signal enable (address)
DEBUG_DEBUGOOF_MASK = %10000000  ; VIC-IV debug out-of-frame signal enable (bit mask)
!addr DEBUGOOF_MASK = %10000000  ; VIC-IV debug out-of-frame signal enable (bit mask)
!addr FDC_DS_ADDR = $D080  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (address)
!addr DS_ADDR = $D080  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (address)
FDC_DS_MASK = %00000111  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (bit mask)
!addr DS_MASK = %00000111  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (bit mask)
!addr FDC_SIDE_ADDR = $D080  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (address)
!addr SIDE_ADDR = $D080  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (address)
FDC_SIDE_MASK = %00001000  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (bit mask)
!addr SIDE_MASK = %00001000  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (bit mask)
!addr FDC_SWAP_ADDR = $D080  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (address)
!addr SWAP_ADDR = $D080  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (address)
FDC_SWAP_MASK = %00010000  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (bit mask)
!addr SWAP_MASK = %00010000  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (bit mask)
!addr FDC_MOTOR_ADDR = $D080  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (address)
!addr MOTOR_ADDR = $D080  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (address)
FDC_MOTOR_MASK = %00100000  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (bit mask)
!addr MOTOR_MASK = %00100000  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (bit mask)
!addr FDC_LED_ADDR = $D080  ; Drive LED blinks when set (address)
FDC_LED_MASK = %01000000  ; Drive LED blinks when set (bit mask)
!addr FDC_IRQ_ADDR = $D080  ; When set, enables interrupts to occur. Clearing clears any pending interrupt and disables interrupts until set again. (address)
FDC_IRQ_MASK = %10000000  ; When set, enables interrupts to occur. Clearing clears any pending interrupt and disables interrupts until set again. (bit mask)
!addr FDC_COMMAND = $D081  ; F011 FDC command register
!addr FDC_NOBUF_ADDR = $D081  ; Reset the sector buffer read/write pointers (address)
!addr NOBUF_ADDR = $D081  ; Reset the sector buffer read/write pointers (address)
FDC_NOBUF_MASK = %00000001  ; Reset the sector buffer read/write pointers (bit mask)
!addr NOBUF_MASK = %00000001  ; Reset the sector buffer read/write pointers (bit mask)
!addr FDC_ALT_ADDR = $D081  ; Selects alternate DPLL read recovery method (not implemented) (address)
!addr ALT_ADDR = $D081  ; Selects alternate DPLL read recovery method (not implemented) (address)
FDC_ALT_MASK = %00000010  ; Selects alternate DPLL read recovery method (not implemented) (bit mask)
!addr ALT_MASK = %00000010  ; Selects alternate DPLL read recovery method (not implemented) (bit mask)
!addr FDC_ALGO_ADDR = $D081  ; Selects reading and writing algorithm (currently ignored). (address)
!addr ALGO_ADDR = $D081  ; Selects reading and writing algorithm (currently ignored). (address)
FDC_ALGO_MASK = %00000100  ; Selects reading and writing algorithm (currently ignored). (bit mask)
!addr ALGO_MASK = %00000100  ; Selects reading and writing algorithm (currently ignored). (bit mask)
!addr FDC_DIR_ADDR = $D081  ; Sets the stepping direction (inward vs (address)
!addr DIR_ADDR = $D081  ; Sets the stepping direction (inward vs (address)
FDC_DIR_MASK = %00001000  ; Sets the stepping direction (inward vs (bit mask)
!addr DIR_MASK = %00001000  ; Sets the stepping direction (inward vs (bit mask)
!addr FDC_STEP_ADDR = $D081  ; Writing 1 causes the head to step in the indicated direction (address)
!addr STEP_ADDR = $D081  ; Writing 1 causes the head to step in the indicated direction (address)
FDC_STEP_MASK = %00010000  ; Writing 1 causes the head to step in the indicated direction (bit mask)
!addr STEP_MASK = %00010000  ; Writing 1 causes the head to step in the indicated direction (bit mask)
!addr FDC_FREE_ADDR = $D081  ; Command is a free-format (low level) operation (address)
!addr FREE_ADDR = $D081  ; Command is a free-format (low level) operation (address)
FDC_FREE_MASK = %00100000  ; Command is a free-format (low level) operation (bit mask)
!addr FREE_MASK = %00100000  ; Command is a free-format (low level) operation (bit mask)
!addr FDC_RDCMD_ADDR = $D081  ; Command is a read operation if set (address)
!addr RDCMD_ADDR = $D081  ; Command is a read operation if set (address)
FDC_RDCMD_MASK = %01000000  ; Command is a read operation if set (bit mask)
!addr RDCMD_MASK = %01000000  ; Command is a read operation if set (bit mask)
!addr FDC_WRCMD_ADDR = $D081  ; Command is a write operation if set (address)
!addr WRCMD_ADDR = $D081  ; Command is a write operation if set (address)
FDC_WRCMD_MASK = %10000000  ; Command is a write operation if set (bit mask)
!addr WRCMD_MASK = %10000000  ; Command is a write operation if set (bit mask)
!addr FDC_TK0_ADDR = $D082  ; F011 Head is over track 0 flag (read only) (address)
!addr TK0_ADDR = $D082  ; F011 Head is over track 0 flag (read only) (address)
FDC_TK0_MASK = %00000001  ; F011 Head is over track 0 flag (read only) (bit mask)
!addr TK0_MASK = %00000001  ; F011 Head is over track 0 flag (read only) (bit mask)
!addr FDC_PROT_ADDR = $D082  ; F011 Disk write protect flag (read only) (address)
!addr PROT_ADDR = $D082  ; F011 Disk write protect flag (read only) (address)
FDC_PROT_MASK = %00000010  ; F011 Disk write protect flag (read only) (bit mask)
!addr PROT_MASK = %00000010  ; F011 Disk write protect flag (read only) (bit mask)
!addr FDC_LOST_ADDR = $D082  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (address)
!addr LOST_ADDR = $D082  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (address)
FDC_LOST_MASK = %00000100  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (bit mask)
!addr LOST_MASK = %00000100  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (bit mask)
!addr FDC_CRC_ADDR = $D082  ; F011 FDC CRC check failure flag (read only) (address)
!addr CRC_ADDR = $D082  ; F011 FDC CRC check failure flag (read only) (address)
FDC_CRC_MASK = %00001000  ; F011 FDC CRC check failure flag (read only) (bit mask)
!addr CRC_MASK = %00001000  ; F011 FDC CRC check failure flag (read only) (bit mask)
!addr FDC_RNF_ADDR = $D082  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (address)
!addr RNF_ADDR = $D082  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (address)
FDC_RNF_MASK = %00010000  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (bit mask)
!addr RNF_MASK = %00010000  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (bit mask)
!addr FDC_EQ_ADDR = $D082  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (address)
!addr EQ_ADDR = $D082  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (address)
FDC_EQ_MASK = %00100000  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (bit mask)
!addr EQ_MASK = %00100000  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (bit mask)
!addr FDC_DRQ_ADDR = $D082  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (address)
!addr DRQ_ADDR = $D082  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (address)
FDC_DRQ_MASK = %01000000  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (bit mask)
!addr DRQ_MASK = %01000000  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (bit mask)
!addr FDC_BUSY_ADDR = $D082  ; F011 FDC busy flag (command is being executed) (read only) (address)
!addr BUSY_ADDR = $D082  ; F011 FDC busy flag (command is being executed) (read only) (address)
FDC_BUSY_MASK = %10000000  ; F011 FDC busy flag (command is being executed) (read only) (bit mask)
!addr BUSY_MASK = %10000000  ; F011 FDC busy flag (command is being executed) (read only) (bit mask)
!addr FDC_DSKCHG_ADDR = $D083  ; F011 disk change sense (read only) (address)
!addr DSKCHG_ADDR = $D083  ; F011 disk change sense (read only) (address)
FDC_DSKCHG_MASK = %00000001  ; F011 disk change sense (read only) (bit mask)
!addr DSKCHG_MASK = %00000001  ; F011 disk change sense (read only) (bit mask)
!addr C65_FDC_IRQ_ADDR = $D083  ; The floppy controller has generated an interrupt (read only). Note that interrupts are not currently implemented on the 45GS27. (address)
C65_FDC_IRQ_MASK = %00000010  ; The floppy controller has generated an interrupt (read only). Note that interrupts are not currently implemented on the 45GS27. (bit mask)
!addr FDC_INDEX_ADDR = $D083  ; F011 Index hole sense (read only) (address)
!addr INDEX_ADDR = $D083  ; F011 Index hole sense (read only) (address)
FDC_INDEX_MASK = %00000100  ; F011 Index hole sense (read only) (bit mask)
!addr INDEX_MASK = %00000100  ; F011 Index hole sense (read only) (bit mask)
!addr FDC_DISKIN_ADDR = $D083  ; F011 Disk sense (read only) (address)
!addr DISKIN_ADDR = $D083  ; F011 Disk sense (read only) (address)
FDC_DISKIN_MASK = %00001000  ; F011 Disk sense (read only) (bit mask)
!addr DISKIN_MASK = %00001000  ; F011 Disk sense (read only) (bit mask)
!addr FDC_WGATE_ADDR = $D083  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (address)
!addr WGATE_ADDR = $D083  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (address)
FDC_WGATE_MASK = %00010000  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (bit mask)
!addr WGATE_MASK = %00010000  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (bit mask)
!addr FDC_RUN_ADDR = $D083  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (address)
!addr RUN_ADDR = $D083  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (address)
FDC_RUN_MASK = %00100000  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (bit mask)
!addr RUN_MASK = %00100000  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (bit mask)
!addr FDC_WTREQ_ADDR = $D083  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (address)
!addr WTREQ_ADDR = $D083  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (address)
FDC_WTREQ_MASK = %01000000  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (bit mask)
!addr WTREQ_MASK = %01000000  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (bit mask)
!addr FDC_RDREQ_ADDR = $D083  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (address)
!addr RDREQ_ADDR = $D083  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (address)
FDC_RDREQ_MASK = %10000000  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (bit mask)
!addr RDREQ_MASK = %10000000  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (bit mask)
!addr FDC_TRACK = $D084  ; F011 FDC track selection register
!addr TRACK = $D084  ; F011 FDC track selection register
!addr FDC_SECTOR = $D085  ; F011 FDC sector selection register
!addr SECTOR = $D085  ; F011 FDC sector selection register
!addr FDC_SIDE = $D086  ; F011 FDC side selection register
!addr SIDE = $D086  ; F011 FDC side selection register
!addr FDC_DATA = $D087  ; F011 FDC data register (read/write) for accessing the floppy controller's 512 byte sector buffer
!addr FDC_CLOCK = $D088  ; Set or read the clock pattern to be used when writing address and data marks. Should normally be left $FF
!addr CLOCK = $D088  ; Set or read the clock pattern to be used when writing address and data marks. Should normally be left $FF
!addr FDC_STEP = $D089  ; Set or read the track stepping rate in 62.5 microsecond steps (normally 128, i.e., 8 milliseconds).
!addr STEP = $D089  ; Set or read the track stepping rate in 62.5 microsecond steps (normally 128, i.e., 8 milliseconds).
!addr FDC_PCODE = $D08A  ; (Read only) returns the protection code of the most recently read sector. Was intended for rudimentary copy protection. Not implemented.
!addr PCODE = $D08A  ; (Read only) returns the protection code of the most recently read sector. Was intended for rudimentary copy protection. Not implemented.
!addr SUMMARY_REC = $D0A0  ; Reserved for C65 RAM Expansion Controller.
!addr REC = $D0A0  ; Reserved for C65 RAM Expansion Controller.
!addr VIC3_PALRED = $D100  ; red palette values (reversed nybl order)
!addr PALRED = $D100  ; red palette values (reversed nybl order)
!addr VIC3_PALGREEN = $D200  ; green palette values (reversed nybl order)
!addr PALGREEN = $D200  ; green palette values (reversed nybl order)
!addr VIC3_PALBLUE = $D300  ; blue palette values (reversed nybl order)
!addr PALBLUE = $D300  ; blue palette values (reversed nybl order)
!addr ETHCOMMAND_DEBUGVIC = $D4  ; Select VIC-IV debug stream via ethernet when \$D6E1.3 is set
!addr DEBUGVIC = $D4  ; Select VIC-IV debug stream via ethernet when \$D6E1.3 is set
!addr UART_DATA = $D600  ; UART data register (read or write)
!addr UART_RXRDY_ADDR = $D601  ; UART RX byte ready flag (clear by reading \$D600) (address)
!addr RXRDY_ADDR = $D601  ; UART RX byte ready flag (clear by reading \$D600) (address)
UART_RXRDY_MASK = %00000001  ; UART RX byte ready flag (clear by reading \$D600) (bit mask)
!addr RXRDY_MASK = %00000001  ; UART RX byte ready flag (clear by reading \$D600) (bit mask)
!addr UART_RXOVRRUN_ADDR = $D601  ; UART RX overrun flag (clear by reading \$D600) (address)
!addr RXOVRRUN_ADDR = $D601  ; UART RX overrun flag (clear by reading \$D600) (address)
UART_RXOVRRUN_MASK = %00000010  ; UART RX overrun flag (clear by reading \$D600) (bit mask)
!addr RXOVRRUN_MASK = %00000010  ; UART RX overrun flag (clear by reading \$D600) (bit mask)
!addr UART_PTYERR_ADDR = $D601  ; UART RX parity error flag (clear by reading \$D600) (address)
!addr PTYERR_ADDR = $D601  ; UART RX parity error flag (clear by reading \$D600) (address)
UART_PTYERR_MASK = %00000100  ; UART RX parity error flag (clear by reading \$D600) (bit mask)
!addr PTYERR_MASK = %00000100  ; UART RX parity error flag (clear by reading \$D600) (bit mask)
!addr UART_FRMERR_ADDR = $D601  ; UART RX framing error flag (clear by reading \$D600) (address)
!addr FRMERR_ADDR = $D601  ; UART RX framing error flag (clear by reading \$D600) (address)
UART_FRMERR_MASK = %00001000  ; UART RX framing error flag (clear by reading \$D600) (bit mask)
!addr FRMERR_MASK = %00001000  ; UART RX framing error flag (clear by reading \$D600) (bit mask)
!addr UART_PTYEVEN_ADDR = $D602  ; UART Parity: 1=even, 0=odd (address)
!addr PTYEVEN_ADDR = $D602  ; UART Parity: 1=even, 0=odd (address)
UART_PTYEVEN_MASK = %00000001  ; UART Parity: 1=even, 0=odd (bit mask)
!addr PTYEVEN_MASK = %00000001  ; UART Parity: 1=even, 0=odd (bit mask)
!addr UART_PTYEN_ADDR = $D602  ; UART Parity enable: 1=enabled (address)
!addr PTYEN_ADDR = $D602  ; UART Parity enable: 1=enabled (address)
UART_PTYEN_MASK = %00000010  ; UART Parity enable: 1=enabled (bit mask)
!addr PTYEN_MASK = %00000010  ; UART Parity enable: 1=enabled (bit mask)
!addr UART_CHARSZ_ADDR = $D602  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (address)
!addr CHARSZ_ADDR = $D602  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (address)
UART_CHARSZ_MASK = %00001100  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (bit mask)
!addr CHARSZ_MASK = %00001100  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (bit mask)
!addr UART_SYNCMOD_ADDR = $D602  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (address)
!addr SYNCMOD_ADDR = $D602  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (address)
UART_SYNCMOD_MASK = %00110000  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (bit mask)
!addr SYNCMOD_MASK = %00110000  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (bit mask)
!addr UART_RXEN_ADDR = $D602  ; UART enable receive (address)
!addr RXEN_ADDR = $D602  ; UART enable receive (address)
UART_RXEN_MASK = %01000000  ; UART enable receive (bit mask)
!addr RXEN_MASK = %01000000  ; UART enable receive (bit mask)
!addr UART_TXEN_ADDR = $D602  ; UART enable transmit (address)
!addr TXEN_ADDR = $D602  ; UART enable transmit (address)
UART_TXEN_MASK = %10000000  ; UART enable transmit (bit mask)
!addr TXEN_MASK = %10000000  ; UART enable transmit (bit mask)
!addr UART_DIVISOR = $D603  ; UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
!addr C65_UART_DIVISOR = $D604  ; UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
!addr UART_IMRXNMI_ADDR = $D605  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (address)
!addr IMRXNMI_ADDR = $D605  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (address)
UART_IMRXNMI_MASK = %00010000  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (bit mask)
!addr IMRXNMI_MASK = %00010000  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (bit mask)
!addr UART_IMTXNMI_ADDR = $D605  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (address)
!addr IMTXNMI_ADDR = $D605  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (address)
UART_IMTXNMI_MASK = %00100000  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (bit mask)
!addr IMTXNMI_MASK = %00100000  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (bit mask)
!addr UART_IMRXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (address)
!addr IMRXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (address)
UART_IMRXIRQ_MASK = %01000000  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
!addr IMRXIRQ_MASK = %01000000  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
!addr UART_IMTXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (address)
!addr IMTXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (address)
UART_IMTXIRQ_MASK = %10000000  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
!addr IMTXIRQ_MASK = %10000000  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
!addr UART_IFRXNMI_ADDR = $D606  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (address)
!addr IFRXNMI_ADDR = $D606  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (address)
UART_IFRXNMI_MASK = %00010000  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (bit mask)
!addr IFRXNMI_MASK = %00010000  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (bit mask)
!addr UART_IFTXNMI_ADDR = $D606  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (address)
!addr IFTXNMI_ADDR = $D606  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (address)
UART_IFTXNMI_MASK = %00100000  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (bit mask)
!addr IFTXNMI_MASK = %00100000  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (bit mask)
!addr UART_IFRXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (address)
!addr IFRXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (address)
UART_IFRXIRQ_MASK = %01000000  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
!addr IFRXIRQ_MASK = %01000000  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
!addr UART_IFTXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (address)
!addr IFTXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (address)
UART_IFTXIRQ_MASK = %10000000  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
!addr IFTXIRQ_MASK = %10000000  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
!addr UART_CAPLOCK_ADDR = $D607  ; C65 capslock key sense (address)
!addr CAPLOCK_ADDR = $D607  ; C65 capslock key sense (address)
UART_CAPLOCK_MASK = %00000001  ; C65 capslock key sense (bit mask)
!addr CAPLOCK_MASK = %00000001  ; C65 capslock key sense (bit mask)
!addr UART_KEYCOL8_ADDR = $D607  ; C65 keyboard column 8 select (address)
!addr KEYCOL8_ADDR = $D607  ; C65 keyboard column 8 select (address)
UART_KEYCOL8_MASK = %00000010  ; C65 keyboard column 8 select (bit mask)
!addr KEYCOL8_MASK = %00000010  ; C65 keyboard column 8 select (bit mask)
!addr UART_PORTEDDR_ADDR = $D608  ; C65 keyboard extra lines Data Direction Register (DDR) (address)
!addr PORTEDDR_ADDR = $D608  ; C65 keyboard extra lines Data Direction Register (DDR) (address)
UART_PORTEDDR_MASK = %00000011  ; C65 keyboard extra lines Data Direction Register (DDR) (bit mask)
!addr PORTEDDR_MASK = %00000011  ; C65 keyboard extra lines Data Direction Register (DDR) (bit mask)
!addr UARTMISC_UFAST_ADDR = $D609  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (address)
!addr UFAST_ADDR = $D609  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (address)
UARTMISC_UFAST_MASK = %00000001  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (bit mask)
!addr UFAST_MASK = %00000001  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (bit mask)
!addr UARTMISC_PORTF_ADDR = $D60B  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (address)
!addr PORTF_ADDR = $D60B  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (address)
UARTMISC_PORTF_MASK = %00111111  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (bit mask)
!addr PORTF_MASK = %00111111  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (bit mask)
!addr UARTMISC_OSKZON_ADDR = $D60B  ; Display hardware zoom of region under first touch point always (address)
!addr OSKZON_ADDR = $D60B  ; Display hardware zoom of region under first touch point always (address)
UARTMISC_OSKZON_MASK = %01000000  ; Display hardware zoom of region under first touch point always (bit mask)
!addr OSKZON_MASK = %01000000  ; Display hardware zoom of region under first touch point always (bit mask)
!addr UARTMISC_OSKZEN_ADDR = $D60B  ; Display hardware zoom of region under first touch point for on-screen keyboard (address)
!addr OSKZEN_ADDR = $D60B  ; Display hardware zoom of region under first touch point for on-screen keyboard (address)
UARTMISC_OSKZEN_MASK = %10000000  ; Display hardware zoom of region under first touch point for on-screen keyboard (bit mask)
!addr OSKZEN_MASK = %10000000  ; Display hardware zoom of region under first touch point for on-screen keyboard (bit mask)
!addr UARTMISC_PORTFDDR_ADDR = $D60C  ; PMOD port A on FPGA board (DDR) (address)
UARTMISC_PORTFDDR_MASK = %00111111  ; PMOD port A on FPGA board (DDR) (bit mask)
!addr GS_UARTMISC_PORTFDDR_ADDR = $D60C  ; On Screen Keyboard (OSK) Zoom Control Data Direction Register (DDR). Must be set to output to control these features. (address)
GS_UARTMISC_PORTFDDR_MASK = %11000000  ; On Screen Keyboard (OSK) Zoom Control Data Direction Register (DDR). Must be set to output to control these features. (bit mask)
!addr UARTMISC_CONN41_ADDR = $D60D  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (address)
!addr CONN41_ADDR = $D60D  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (address)
UARTMISC_CONN41_MASK = %00000001  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (bit mask)
!addr CONN41_MASK = %00000001  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (bit mask)
!addr UARTMISC_RST41_ADDR = $D60D  ; Internal 1541 drive reset (1=reset, 0=operate) (address)
!addr RST41_ADDR = $D60D  ; Internal 1541 drive reset (1=reset, 0=operate) (address)
UARTMISC_RST41_MASK = %00000010  ; Internal 1541 drive reset (1=reset, 0=operate) (bit mask)
!addr RST41_MASK = %00000010  ; Internal 1541 drive reset (1=reset, 0=operate) (bit mask)
!addr UARTMISC_SDDATA_ADDR = $D60D  ; SD card MOSI/MISO (address)
!addr SDDATA_ADDR = $D60D  ; SD card MOSI/MISO (address)
UARTMISC_SDDATA_MASK = %00000100  ; SD card MOSI/MISO (bit mask)
!addr SDDATA_MASK = %00000100  ; SD card MOSI/MISO (bit mask)
!addr UARTMISC_SDCLK_ADDR = $D60D  ; SD card SCLK (address)
!addr SDCLK_ADDR = $D60D  ; SD card SCLK (address)
UARTMISC_SDCLK_MASK = %00001000  ; SD card SCLK (bit mask)
!addr SDCLK_MASK = %00001000  ; SD card SCLK (bit mask)
!addr UARTMISC_SDCS_ADDR = $D60D  ; SD card CS_BO (address)
!addr SDCS_ADDR = $D60D  ; SD card CS_BO (address)
UARTMISC_SDCS_MASK = %00010000  ; SD card CS_BO (bit mask)
!addr SDCS_MASK = %00010000  ; SD card CS_BO (bit mask)
!addr UARTMISC_SDBSH_ADDR = $D60D  ; Enable SD card bitbash mode (address)
!addr SDBSH_ADDR = $D60D  ; Enable SD card bitbash mode (address)
UARTMISC_SDBSH_MASK = %00100000  ; Enable SD card bitbash mode (bit mask)
!addr SDBSH_MASK = %00100000  ; Enable SD card bitbash mode (bit mask)
!addr UARTMISC_HDSDA_ADDR = $D60D  ; HDMI I2C control interface SDA data line (address)
!addr HDSDA_ADDR = $D60D  ; HDMI I2C control interface SDA data line (address)
UARTMISC_HDSDA_MASK = %01000000  ; HDMI I2C control interface SDA data line (bit mask)
!addr HDSDA_MASK = %01000000  ; HDMI I2C control interface SDA data line (bit mask)
!addr UARTMISC_HDSCL_ADDR = $D60D  ; HDMI I2C control interface SCL clock (address)
!addr HDSCL_ADDR = $D60D  ; HDMI I2C control interface SCL clock (address)
UARTMISC_HDSCL_MASK = %10000000  ; HDMI I2C control interface SCL clock (bit mask)
!addr HDSCL_MASK = %10000000  ; HDMI I2C control interface SCL clock (bit mask)
!addr UARTMISC_BASHDDR = $D60E  ; Data Direction Register (DDR) for \$D60D bit bashing port.
!addr BASHDDR = $D60E  ; Data Direction Register (DDR) for \$D60D bit bashing port.
!addr UARTMISC_KEYLEFT_ADDR = $D60F  ; Directly read C65 Cursor left key (address)
!addr KEYLEFT_ADDR = $D60F  ; Directly read C65 Cursor left key (address)
UARTMISC_KEYLEFT_MASK = %00000001  ; Directly read C65 Cursor left key (bit mask)
!addr KEYLEFT_MASK = %00000001  ; Directly read C65 Cursor left key (bit mask)
!addr UARTMISC_KEYUP_ADDR = $D60F  ; Directly read C65 Cursor up key (address)
!addr KEYUP_ADDR = $D60F  ; Directly read C65 Cursor up key (address)
UARTMISC_KEYUP_MASK = %00000010  ; Directly read C65 Cursor up key (bit mask)
!addr KEYUP_MASK = %00000010  ; Directly read C65 Cursor up key (bit mask)
!addr UARTMISC_REALHW_ADDR = $D60F  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (address)
!addr REALHW_ADDR = $D60F  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (address)
UARTMISC_REALHW_MASK = %00100000  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (bit mask)
!addr REALHW_MASK = %00100000  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (bit mask)
!addr UARTMISC_OSKDIM_ADDR = $D60F  ; Light or heavy dimming of background material behind on-screen keyboard (address)
!addr OSKDIM_ADDR = $D60F  ; Light or heavy dimming of background material behind on-screen keyboard (address)
UARTMISC_OSKDIM_MASK = %01000000  ; Light or heavy dimming of background material behind on-screen keyboard (bit mask)
!addr OSKDIM_MASK = %01000000  ; Light or heavy dimming of background material behind on-screen keyboard (bit mask)
!addr UARTMISC_ACCESSKEY_ADDR = $D60F  ; Enable accessible keyboard input via joystick port 2 fire button (address)
!addr ACCESSKEY_ADDR = $D60F  ; Enable accessible keyboard input via joystick port 2 fire button (address)
UARTMISC_ACCESSKEY_MASK = %10000000  ; Enable accessible keyboard input via joystick port 2 fire button (bit mask)
!addr ACCESSKEY_MASK = %10000000  ; Enable accessible keyboard input via joystick port 2 fire button (bit mask)
!addr UARTMISC_ASCIIKEY = $D610  ; Last key press as ASCII (hardware accelerated keyboard scanner). Write to clear event ready for next.
!addr ASCIIKEY = $D610  ; Last key press as ASCII (hardware accelerated keyboard scanner). Write to clear event ready for next.
!addr UARTMISC_MRSHFT_ADDR = $D611  ; Right shift key state (hardware accelerated keyboard scanner). (address)
!addr MRSHFT_ADDR = $D611  ; Right shift key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MRSHFT_MASK = %00000001  ; Right shift key state (hardware accelerated keyboard scanner). (bit mask)
!addr MRSHFT_MASK = %00000001  ; Right shift key state (hardware accelerated keyboard scanner). (bit mask)
!addr UARTMISC_MLSHFT_ADDR = $D611  ; Left shift key state (hardware accelerated keyboard scanner). (address)
!addr MLSHFT_ADDR = $D611  ; Left shift key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MLSHFT_MASK = %00000010  ; Left shift key state (hardware accelerated keyboard scanner). (bit mask)
!addr MLSHFT_MASK = %00000010  ; Left shift key state (hardware accelerated keyboard scanner). (bit mask)
!addr UARTMISC_MCTRL_ADDR = $D611  ; CTRL key state (hardware accelerated keyboard scanner). (address)
!addr MCTRL_ADDR = $D611  ; CTRL key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MCTRL_MASK = %00000100  ; CTRL key state (hardware accelerated keyboard scanner). (bit mask)
!addr MCTRL_MASK = %00000100  ; CTRL key state (hardware accelerated keyboard scanner). (bit mask)
!addr UARTMISC_MMEGA_ADDR = $D611  ; MEGA/C= key state (hardware accelerated keyboard scanner). (address)
!addr MMEGA_ADDR = $D611  ; MEGA/C= key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MMEGA_MASK = %00001000  ; MEGA/C= key state (hardware accelerated keyboard scanner). (bit mask)
!addr MMEGA_MASK = %00001000  ; MEGA/C= key state (hardware accelerated keyboard scanner). (bit mask)
!addr UARTMISC_MALT_ADDR = $D611  ; ALT key state (hardware accelerated keyboard scanner). (address)
!addr MALT_ADDR = $D611  ; ALT key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MALT_MASK = %00010000  ; ALT key state (hardware accelerated keyboard scanner). (bit mask)
!addr MALT_MASK = %00010000  ; ALT key state (hardware accelerated keyboard scanner). (bit mask)
!addr UARTMISC_MSCRL_ADDR = $D611  ; NOSCRL key state (hardware accelerated keyboard scanner). (address)
!addr MSCRL_ADDR = $D611  ; NOSCRL key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MSCRL_MASK = %00100000  ; NOSCRL key state (hardware accelerated keyboard scanner). (bit mask)
!addr MSCRL_MASK = %00100000  ; NOSCRL key state (hardware accelerated keyboard scanner). (bit mask)
!addr UARTMISC_MCAPS_ADDR = $D611  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (address)
!addr MCAPS_ADDR = $D611  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MCAPS_MASK = %01000000  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (bit mask)
!addr MCAPS_MASK = %01000000  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (bit mask)
!addr UARTMISC_WGTKEY_ADDR = $D612  ; Enable widget board keyboard/joystick input (address)
!addr WGTKEY_ADDR = $D612  ; Enable widget board keyboard/joystick input (address)
UARTMISC_WGTKEY_MASK = %00000001  ; Enable widget board keyboard/joystick input (bit mask)
!addr WGTKEY_MASK = %00000001  ; Enable widget board keyboard/joystick input (bit mask)
!addr UARTMISC_PS2KEY_ADDR = $D612  ; Enable ps2 keyboard/joystick input (address)
!addr PS2KEY_ADDR = $D612  ; Enable ps2 keyboard/joystick input (address)
UARTMISC_PS2KEY_MASK = %00000010  ; Enable ps2 keyboard/joystick input (bit mask)
!addr PS2KEY_MASK = %00000010  ; Enable ps2 keyboard/joystick input (bit mask)
!addr UARTMISC_PHYKEY_ADDR = $D612  ; Enable physical keyboard input (address)
!addr PHYKEY_ADDR = $D612  ; Enable physical keyboard input (address)
UARTMISC_PHYKEY_MASK = %00000100  ; Enable physical keyboard input (bit mask)
!addr PHYKEY_MASK = %00000100  ; Enable physical keyboard input (bit mask)
!addr UARTMISC_VRTKEY_ADDR = $D612  ; Enable virtual/snythetic keyboard input (address)
!addr VRTKEY_ADDR = $D612  ; Enable virtual/snythetic keyboard input (address)
UARTMISC_VRTKEY_MASK = %00001000  ; Enable virtual/snythetic keyboard input (bit mask)
!addr VRTKEY_MASK = %00001000  ; Enable virtual/snythetic keyboard input (bit mask)
!addr UARTMISC_OSKDEBUG_ADDR = $D612  ; Debug OSK overlay (WRITE ONLY) (address)
!addr OSKDEBUG_ADDR = $D612  ; Debug OSK overlay (WRITE ONLY) (address)
UARTMISC_OSKDEBUG_MASK = %00010000  ; Debug OSK overlay (WRITE ONLY) (bit mask)
!addr OSKDEBUG_MASK = %00010000  ; Debug OSK overlay (WRITE ONLY) (bit mask)
!addr UARTMISC_PS2JOY_ADDR = $D612  ; Enable PS/2 / USB keyboard simulated joystick input (address)
!addr PS2JOY_ADDR = $D612  ; Enable PS/2 / USB keyboard simulated joystick input (address)
UARTMISC_PS2JOY_MASK = %00010000  ; Enable PS/2 / USB keyboard simulated joystick input (bit mask)
!addr PS2JOY_MASK = %00010000  ; Enable PS/2 / USB keyboard simulated joystick input (bit mask)
!addr UARTMISC_JOYSWAP_ADDR = $D612  ; Exchange joystick ports 1 \& 2 (address)
!addr JOYSWAP_ADDR = $D612  ; Exchange joystick ports 1 \& 2 (address)
UARTMISC_JOYSWAP_MASK = %00100000  ; Exchange joystick ports 1 \& 2 (bit mask)
!addr JOYSWAP_MASK = %00100000  ; Exchange joystick ports 1 \& 2 (bit mask)
!addr UARTMISC_LJOYA_ADDR = $D612  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (address)
!addr LJOYA_ADDR = $D612  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (address)
UARTMISC_LJOYA_MASK = %01000000  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (bit mask)
!addr LJOYA_MASK = %01000000  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (bit mask)
!addr UARTMISC_LJOYB_ADDR = $D612  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (address)
!addr LJOYB_ADDR = $D612  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (address)
UARTMISC_LJOYB_MASK = %10000000  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (bit mask)
!addr LJOYB_MASK = %10000000  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (bit mask)
!addr DEBUG_CRTACSCNT = $D613  ; Count of cartridge port memory accesses (read only)
!addr CRTACSCNT = $D613  ; Count of cartridge port memory accesses (read only)
!addr DEBUG_KEYMATRIXPEEK = $D614  ; 8-bit segment of combined keyboard matrix (READ)
!addr KEYMATRIXPEEK = $D614  ; 8-bit segment of combined keyboard matrix (READ)
!addr UARTMISC_VIRTKEY1_ADDR = $D615  ; Set to \$7F for no key down, else specify virtual key press. (address)
!addr VIRTKEY1_ADDR = $D615  ; Set to \$7F for no key down, else specify virtual key press. (address)
UARTMISC_VIRTKEY1_MASK = %01111111  ; Set to \$7F for no key down, else specify virtual key press. (bit mask)
!addr VIRTKEY1_MASK = %01111111  ; Set to \$7F for no key down, else specify virtual key press. (bit mask)
!addr UARTMISC_OSKEN_ADDR = $D615  ; Enable display of on-screen keyboard composited overlay (address)
!addr OSKEN_ADDR = $D615  ; Enable display of on-screen keyboard composited overlay (address)
UARTMISC_OSKEN_MASK = %10000000  ; Enable display of on-screen keyboard composited overlay (bit mask)
!addr OSKEN_MASK = %10000000  ; Enable display of on-screen keyboard composited overlay (bit mask)
!addr UARTMISC_VIRTKEY2_ADDR = $D616  ; Set to \$7F for no key down, else specify 2nd virtual key press. (address)
!addr VIRTKEY2_ADDR = $D616  ; Set to \$7F for no key down, else specify 2nd virtual key press. (address)
UARTMISC_VIRTKEY2_MASK = %01111111  ; Set to \$7F for no key down, else specify 2nd virtual key press. (bit mask)
!addr VIRTKEY2_MASK = %01111111  ; Set to \$7F for no key down, else specify 2nd virtual key press. (bit mask)
!addr UARTMISC_OSKALT_ADDR = $D616  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (address)
!addr OSKALT_ADDR = $D616  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (address)
UARTMISC_OSKALT_MASK = %10000000  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (bit mask)
!addr OSKALT_MASK = %10000000  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (bit mask)
!addr UARTMISC_VIRTKEY3_ADDR = $D617  ; Set to \$7F for no key down, else specify 3nd virtual key press. (address)
!addr VIRTKEY3_ADDR = $D617  ; Set to \$7F for no key down, else specify 3nd virtual key press. (address)
UARTMISC_VIRTKEY3_MASK = %01111111  ; Set to \$7F for no key down, else specify 3nd virtual key press. (bit mask)
!addr VIRTKEY3_MASK = %01111111  ; Set to \$7F for no key down, else specify 3nd virtual key press. (bit mask)
!addr UARTMISC_OSKTOP_ADDR = $D617  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (address)
!addr OSKTOP_ADDR = $D617  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (address)
UARTMISC_OSKTOP_MASK = %10000000  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (bit mask)
!addr OSKTOP_MASK = %10000000  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (bit mask)
!addr UARTMISC_KSCNRATE = $D618  ; Physical keyboard scan rate (\$00=50MHz, \$FF=~200KHz)
!addr KSCNRATE = $D618  ; Physical keyboard scan rate (\$00=50MHz, \$FF=~200KHz)
!addr UARTMISC_UNUSED = $D619  ; port o output value
!addr UNUSED = $D619  ; port o output value
!addr UARTMISC_SYSCTL = $D61A  ; System control flags (target specific)
!addr SYSCTL = $D61A  ; System control flags (target specific)
!addr SYSCTL_AUDMUTE_ADDR = $D61A  ; Mute digital video audio (MEGA65 R2 only) (address)
!addr AUDMUTE_ADDR = $D61A  ; Mute digital video audio (MEGA65 R2 only) (address)
SYSCTL_AUDMUTE_MASK = %00000001  ; Mute digital video audio (MEGA65 R2 only) (bit mask)
!addr AUDMUTE_MASK = %00000001  ; Mute digital video audio (MEGA65 R2 only) (bit mask)
!addr SYSCTL_DVI_ADDR = $D61A  ; Control digital video as DVI (disables audio) (address)
!addr DVI_ADDR = $D61A  ; Control digital video as DVI (disables audio) (address)
SYSCTL_DVI_MASK = %00000010  ; Control digital video as DVI (disables audio) (bit mask)
!addr DVI_MASK = %00000010  ; Control digital video as DVI (disables audio) (bit mask)
!addr SYSCTL_AUDDBG_ADDR = $D61A  ; Visualise audio samples (DEBUG) (address)
!addr AUDDBG_ADDR = $D61A  ; Visualise audio samples (DEBUG) (address)
SYSCTL_AUDDBG_MASK = %00000100  ; Visualise audio samples (DEBUG) (bit mask)
!addr AUDDBG_MASK = %00000100  ; Visualise audio samples (DEBUG) (bit mask)
!addr SYSCTL_AUD48K_ADDR = $D61A  ; Select 48KHz or 44.1KHz digital video audio sample rate (address)
!addr AUD48K_ADDR = $D61A  ; Select 48KHz or 44.1KHz digital video audio sample rate (address)
SYSCTL_AUD48K_MASK = %00001000  ; Select 48KHz or 44.1KHz digital video audio sample rate (bit mask)
!addr AUD48K_MASK = %00001000  ; Select 48KHz or 44.1KHz digital video audio sample rate (bit mask)
!addr SYSCTL_LED_ADDR = $D61A  ; Control LED next to U1 on mother board (address)
SYSCTL_LED_MASK = %00010000  ; Control LED next to U1 on mother board (bit mask)
!addr SYSCTL_AUDINV_ADDR = $D61A  ; Invert digital video audio sample values (address)
!addr AUDINV_ADDR = $D61A  ; Invert digital video audio sample values (address)
SYSCTL_AUDINV_MASK = %10000000  ; Invert digital video audio sample values (bit mask)
!addr AUDINV_MASK = %10000000  ; Invert digital video audio sample values (bit mask)
!addr DEBUG_AMIMOUSDETECT = $D61B  ; READ 1351/amiga mouse auto detection DEBUG
!addr AMIMOUSDETECT = $D61B  ; READ 1351/amiga mouse auto detection DEBUG
!addr DEBUG__1541PCLSB = $D61C  ; internal 1541 PC LSB
!addr _1541PCLSB = $D61C  ; internal 1541 PC LSB
!addr UARTMISC_Keyboard_ADDR = $D61D  ; LED register select (R,G,B channels x 4 = 0 to 11) (address)
UARTMISC_Keyboard_MASK = %01111111  ; LED register select (R,G,B channels x 4 = 0 to 11) (bit mask)
!addr GS_UARTMISC_Keyboard_ADDR = $D61D  ; LED control enable (address)
GS_UARTMISC_Keyboard_MASK = %10000000  ; LED control enable (bit mask)
!addr UARTMISC_Keyboard = $D61E  ; register value (write only)
!addr Keyboard = $D61E  ; register value (write only)
!addr DEBUG_BUCKYCOPY = $D61F  ; DUPLICATE Modifier key state (hardware accelerated keyboard scanner).
!addr BUCKYCOPY = $D61F  ; DUPLICATE Modifier key state (hardware accelerated keyboard scanner).
!addr UARTMISC_POTAX = $D620  ; Read Port A paddle X, without having to fiddle with SID/CIA settings.
!addr POTAX = $D620  ; Read Port A paddle X, without having to fiddle with SID/CIA settings.
!addr UARTMISC_POTAY = $D621  ; Read Port A paddle Y, without having to fiddle with SID/CIA settings.
!addr POTAY = $D621  ; Read Port A paddle Y, without having to fiddle with SID/CIA settings.
!addr UARTMISC_POTBX = $D622  ; Read Port B paddle X, without having to fiddle with SID/CIA settings.
!addr POTBX = $D622  ; Read Port B paddle X, without having to fiddle with SID/CIA settings.
!addr UARTMISC_POTBY = $D623  ; Read Port B paddle Y, without having to fiddle with SID/CIA settings.
!addr POTBY = $D623  ; Read Port B paddle Y, without having to fiddle with SID/CIA settings.
!addr DEBUG_POTDEBUG = $D624  ; READ ONLY flags for paddles. See c65uart.vhdl for more information.
!addr POTDEBUG = $D624  ; READ ONLY flags for paddles. See c65uart.vhdl for more information.
!addr UARTMISC_J21L = $D625  ; J21 pins 1 -- 6, 9 -- 10 input/output values
!addr J21L = $D625  ; J21 pins 1 -- 6, 9 -- 10 input/output values
!addr UARTMISC_J21H = $D626  ; J21 pins 11 -- 14 input/output values
!addr J21H = $D626  ; J21 pins 11 -- 14 input/output values
!addr UARTMISC_J21LDDR = $D627  ; J21 pins 1 -- 6, 9 -- 10 data direction register
!addr J21LDDR = $D627  ; J21 pins 1 -- 6, 9 -- 10 data direction register
!addr UARTMISC_J21HDDR = $D628  ; J21 pins 11 -- 14 data direction register
!addr J21HDDR = $D628  ; J21 pins 11 -- 14 data direction register
!addr UARTMISC_M65MODEL = $D629  ; MEGA65 model ID. Can be used to determine the model of MEGA65 a programme is running on, e.g., to enable touch controls on MEGAphone.
!addr M65MODEL = $D629  ; MEGA65 model ID. Can be used to determine the model of MEGA65 a programme is running on, e.g., to enable touch controls on MEGAphone.
!addr KBD_FWDATEL = $D62A  ; LSB of keyboard firmware date stamp (days since 1 Jan 2020)
!addr KBD_FWDATEH = $D62B  ; MSB of keyboard firmware date stamp (days since 1 Jan 2020)
!addr KBD_FWGIT0 = $D62C  ; LSB of keyboard firmware git commit
!addr GS_KBD_FWGIT0 = $D62D  ; 2nd byte of keyboard firmware git commit
!addr GS_KBD_FWGIT0_2 = $D62E  ; 3rd byte of keyboard firmware git commit
!addr GS_KBD_FWGIT0_3 = $D62F  ; MSB of keyboard firmware git commit
!addr FPGA_FWDATEL = $D630  ; LSB of MEGA65 FPGA design date stamp (days since 1 Jan 2020)
!addr FPGA_FWDATEH = $D631  ; MSB of MEGA65 FPGA design date stamp (days since 1 Jan 2020)
!addr FPGA_FWGIT0 = $D632  ; LSB of MEGA65 FPGA design git commit
!addr GS_FPGA_FWGIT0 = $D633  ; 2nd byte of MEGA65 FPGA design git commit
!addr GS_FPGA_FWGIT0_2 = $D634  ; 3rd byte of MEGA65 FPGA design git commit
!addr GS_FPGA_FWGIT0_3 = $D635  ; MSB of MEGA65 FPGA design git commit
!addr AUXFPGA_FWDATEL = $D636  ; LSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
!addr AUXFPGA_MFWDATEH = $D637  ; MSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
!addr MFWDATEH = $D637  ; MSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
!addr AUXFPGA_FWGIT0 = $D638  ; LSB of Auxilliary (MAX10) FPGA design git commit
!addr GS_AUXFPGA_FWGIT0 = $D639  ; 2nd byte of Auxilliary (MAX10) FPGA design git commit
!addr GS_AUXFPGA_FWGIT0_2 = $D63A  ; 3rd byte of Auxilliary (MAX10) FPGA design git commit
!addr GS_AUXFPGA_FWGIT0_3 = $D63B  ; MSB of Auxilliary (MAX10) FPGA design git commit
!addr SID_SIDMODE_ADDR = $D63C  ; Select SID mode: 0=6581, 1=8580 (address)
!addr SIDMODE_ADDR = $D63C  ; Select SID mode: 0=6581, 1=8580 (address)
SID_SIDMODE_MASK = %00001111  ; Select SID mode: 0=6581, 1=8580 (bit mask)
!addr SIDMODE_MASK = %00001111  ; Select SID mode: 0=6581, 1=8580 (bit mask)
!addr AUDIOMIX_DCTRKEN_ADDR = $D63C  ; Enable DC offset subtraction in audio mixer (address)
!addr DCTRKEN_ADDR = $D63C  ; Enable DC offset subtraction in audio mixer (address)
AUDIOMIX_DCTRKEN_MASK = %00010000  ; Enable DC offset subtraction in audio mixer (bit mask)
!addr DCTRKEN_MASK = %00010000  ; Enable DC offset subtraction in audio mixer (bit mask)
!addr DEBUG_RESETSRC_ADDR = $D63C  ; Source of last CPU reset (address)
!addr RESETSRC_ADDR = $D63C  ; Source of last CPU reset (address)
DEBUG_RESETSRC_MASK = %11100000  ; Source of last CPU reset (bit mask)
!addr RESETSRC_MASK = %11100000  ; Source of last CPU reset (bit mask)
!addr AUDIOMIX_DCTIME = $D63D  ; Audio mixer DC-estimation time step. Lower values = faster updating of DC estimation, at the cost of making low-frequencies quieter.
!addr DCTIME = $D63D  ; Audio mixer DC-estimation time step. Lower values = faster updating of DC estimation, at the cost of making low-frequencies quieter.
!addr CPU_HTRAP00 = $D640  ; Writing triggers hypervisor trap \$XX
!addr HTRAP00 = $D640  ; Writing triggers hypervisor trap \$XX
!addr HCPU_REGA = $D640  ; Hypervisor A register storage
!addr REGA = $D640  ; Hypervisor A register storage
!addr CPU_HTRAP01 = $D641  ; @HTRAPXX
!addr HTRAP01 = $D641  ; @HTRAPXX
!addr HCPU_REGX = $D641  ; Hypervisor X register storage
!addr REGX = $D641  ; Hypervisor X register storage
!addr CPU_HTRAP02 = $D642  ; @HTRAPXX
!addr HTRAP02 = $D642  ; @HTRAPXX
!addr CPU_HTRAP03 = $D643  ; @HTRAPXX
!addr HTRAP03 = $D643  ; @HTRAPXX
!addr HCPU_REGZ = $D643  ; Hypervisor Z register storage
!addr REGZ = $D643  ; Hypervisor Z register storage
!addr CPU_HTRAP04 = $D644  ; @HTRAPXX
!addr HTRAP04 = $D644  ; @HTRAPXX
!addr HCPU_REGB = $D644  ; Hypervisor B register storage
!addr REGB = $D644  ; Hypervisor B register storage
!addr CPU_HTRAP05 = $D645  ; @HTRAPXX
!addr HTRAP05 = $D645  ; @HTRAPXX
!addr HCPU_SPL = $D645  ; Hypervisor SPL register storage
!addr SPL = $D645  ; Hypervisor SPL register storage
!addr CPU_HTRAP06 = $D646  ; @HTRAPXX
!addr HTRAP06 = $D646  ; @HTRAPXX
!addr HCPU_SPH = $D646  ; Hypervisor SPH register storage
!addr SPH = $D646  ; Hypervisor SPH register storage
!addr CPU_HTRAP07 = $D647  ; @HTRAPXX
!addr HTRAP07 = $D647  ; @HTRAPXX
!addr HCPU_PFLAGS = $D647  ; Hypervisor P register storage
!addr PFLAGS = $D647  ; Hypervisor P register storage
!addr CPU_HTRAP08 = $D648  ; @HTRAPXX
!addr HTRAP08 = $D648  ; @HTRAPXX
!addr HCPU_PCL = $D648  ; Hypervisor PC-low register storage
!addr PCL = $D648  ; Hypervisor PC-low register storage
!addr CPU_HTRAP09 = $D649  ; @HTRAPXX
!addr HTRAP09 = $D649  ; @HTRAPXX
!addr HCPU_PCH = $D649  ; Hypervisor PC-high register storage
!addr PCH = $D649  ; Hypervisor PC-high register storage
!addr CPU_HTRAP0A = $D64A  ; @HTRAPXX
!addr HTRAP0A = $D64A  ; @HTRAPXX
!addr HCPU_MAPLO = $D64A  ; Hypervisor MAPLO register storage (high bits)
!addr CPU_HTRAP0B = $D64B  ; @HTRAPXX
!addr HTRAP0B = $D64B  ; @HTRAPXX
!addr GS_HCPU_MAPLO = $D64B  ; Hypervisor MAPLO register storage (low bits)
!addr CPU_HTRAP0C = $D64C  ; @HTRAPXX
!addr HTRAP0C = $D64C  ; @HTRAPXX
!addr HCPU_MAPHI = $D64C  ; Hypervisor MAPHI register storage (high bits)
!addr CPU_HTRAP0D = $D64D  ; @HTRAPXX
!addr HTRAP0D = $D64D  ; @HTRAPXX
!addr GS_HCPU_MAPHI = $D64D  ; Hypervisor MAPHI register storage (low bits)
!addr CPU_HTRAP0E = $D64E  ; @HTRAPXX
!addr HTRAP0E = $D64E  ; @HTRAPXX
!addr HCPU_MAPLOMB = $D64E  ; Hypervisor MAPLO mega-byte number register storage
!addr MAPLOMB = $D64E  ; Hypervisor MAPLO mega-byte number register storage
!addr CPU_HTRAP0F = $D64F  ; @HTRAPXX
!addr HTRAP0F = $D64F  ; @HTRAPXX
!addr HCPU_MAPHIMB = $D64F  ; Hypervisor MAPHI mega-byte number register storage
!addr MAPHIMB = $D64F  ; Hypervisor MAPHI mega-byte number register storage
!addr CPU_HTRAP10 = $D650  ; @HTRAPXX
!addr HTRAP10 = $D650  ; @HTRAPXX
!addr HCPU_PORT00 = $D650  ; Hypervisor CPU port \$00 value
!addr PORT00 = $D650  ; Hypervisor CPU port \$00 value
!addr CPU_HTRAP11 = $D651  ; @HTRAPXX
!addr HTRAP11 = $D651  ; @HTRAPXX
!addr HCPU_PORT01 = $D651  ; Hypervisor CPU port \$01 value
!addr PORT01 = $D651  ; Hypervisor CPU port \$01 value
!addr CPU_HTRAP12 = $D652  ; @HTRAPXX
!addr HTRAP12 = $D652  ; @HTRAPXX
!addr HCPU_VICMODE_ADDR = $D652  ; VIC-II/VIC-III/VIC-IV mode select (address)
!addr VICMODE_ADDR = $D652  ; VIC-II/VIC-III/VIC-IV mode select (address)
HCPU_VICMODE_MASK = %00000011  ; VIC-II/VIC-III/VIC-IV mode select (bit mask)
!addr VICMODE_MASK = %00000011  ; VIC-II/VIC-III/VIC-IV mode select (bit mask)
!addr HCPU_EXSID_ADDR = $D652  ; 0=Use internal SIDs, 1=Use external(1) SIDs (address)
!addr EXSID_ADDR = $D652  ; 0=Use internal SIDs, 1=Use external(1) SIDs (address)
HCPU_EXSID_MASK = %00000100  ; 0=Use internal SIDs, 1=Use external(1) SIDs (bit mask)
!addr EXSID_MASK = %00000100  ; 0=Use internal SIDs, 1=Use external(1) SIDs (bit mask)
!addr CPU_HTRAP13 = $D653  ; @HTRAPXX
!addr HTRAP13 = $D653  ; @HTRAPXX
!addr HCPU_DMASRCMB = $D653  ; Hypervisor DMAgic source MB
!addr DMASRCMB = $D653  ; Hypervisor DMAgic source MB
!addr CPU_HTRAP14 = $D654  ; @HTRAPXX
!addr HTRAP14 = $D654  ; @HTRAPXX
!addr HCPU_DMADSTMB = $D654  ; Hypervisor DMAgic destination MB
!addr DMADSTMB = $D654  ; Hypervisor DMAgic destination MB
!addr CPU_HTRAP15 = $D655  ; @HTRAPXX
!addr HTRAP15 = $D655  ; @HTRAPXX
!addr HCPU_DMALADDR = $D655  ; Hypervisor DMAGic list address bits 0-7
!addr CPU_HTRAP16 = $D656  ; @HTRAPXX
!addr HTRAP16 = $D656  ; @HTRAPXX
!addr GS_HCPU_DMALADDR = $D656  ; Hypervisor DMAGic list address bits 15-8
!addr CPU_HTRAP17 = $D657  ; @HTRAPXX
!addr HTRAP17 = $D657  ; @HTRAPXX
!addr GS_HCPU_DMALADDR_2 = $D657  ; Hypervisor DMAGic list address bits 23-16
!addr CPU_HTRAP18 = $D658  ; @HTRAPXX
!addr HTRAP18 = $D658  ; @HTRAPXX
!addr GS_HCPU_DMALADDR_3 = $D658  ; Hypervisor DMAGic list address bits 27-24
!addr CPU_HTRAP19 = $D659  ; @HTRAPXX
!addr HTRAP19 = $D659  ; @HTRAPXX
!addr HCPU_VFLOP_ADDR = $D659  ; 1=Virtualise SD/Floppy0 access (usually for access via serial debugger interface) (address)
HCPU_VFLOP_MASK = %00000001  ; 1=Virtualise SD/Floppy0 access (usually for access via serial debugger interface) (bit mask)
!addr GS_HCPU_VFLOP_ADDR = $D659  ; 1=Virtualise SD/Floppy1 access (usually for access via serial debugger interface) (address)
GS_HCPU_VFLOP_MASK = %00000010  ; 1=Virtualise SD/Floppy1 access (usually for access via serial debugger interface) (bit mask)
!addr CPU_HTRAP1A = $D65A  ; @HTRAPXX
!addr HTRAP1A = $D65A  ; @HTRAPXX
!addr CPU_HTRAP1B = $D65B  ; @HTRAPXX
!addr HTRAP1B = $D65B  ; @HTRAPXX
!addr CPU_HTRAP1C = $D65C  ; @HTRAPXX
!addr HTRAP1C = $D65C  ; @HTRAPXX
!addr CPU_HTRAP1D = $D65D  ; @HTRAPXX
!addr HTRAP1D = $D65D  ; @HTRAPXX
!addr CPU_HTRAP1E = $D65E  ; @HTRAPXX
!addr HTRAP1E = $D65E  ; @HTRAPXX
!addr CPU_HTRAP1F = $D65F  ; @HTRAPXX
!addr HTRAP1F = $D65F  ; @HTRAPXX
!addr CPU_HTRAP20 = $D660  ; @HTRAPXX
!addr HTRAP20 = $D660  ; @HTRAPXX
!addr CPU_HTRAP21 = $D661  ; @HTRAPXX
!addr HTRAP21 = $D661  ; @HTRAPXX
!addr CPU_HTRAP22 = $D662  ; @HTRAPXX
!addr HTRAP22 = $D662  ; @HTRAPXX
!addr CPU_HTRAP23 = $D663  ; @HTRAPXX
!addr HTRAP23 = $D663  ; @HTRAPXX
!addr CPU_HTRAP24 = $D664  ; @HTRAPXX
!addr HTRAP24 = $D664  ; @HTRAPXX
!addr CPU_HTRAP25 = $D665  ; @HTRAPXX
!addr HTRAP25 = $D665  ; @HTRAPXX
!addr CPU_HTRAP26 = $D666  ; @HTRAPXX
!addr HTRAP26 = $D666  ; @HTRAPXX
!addr CPU_HTRAP27 = $D667  ; @HTRAPXX
!addr HTRAP27 = $D667  ; @HTRAPXX
!addr CPU_HTRAP28 = $D668  ; @HTRAPXX
!addr HTRAP28 = $D668  ; @HTRAPXX
!addr CPU_HTRAP29 = $D669  ; @HTRAPXX
!addr HTRAP29 = $D669  ; @HTRAPXX
!addr CPU_HTRAP2A = $D66A  ; @HTRAPXX
!addr HTRAP2A = $D66A  ; @HTRAPXX
!addr CPU_HTRAP2B = $D66B  ; @HTRAPXX
!addr HTRAP2B = $D66B  ; @HTRAPXX
!addr CPU_HTRAP2C = $D66C  ; @HTRAPXX
!addr HTRAP2C = $D66C  ; @HTRAPXX
!addr CPU_HTRAP2D = $D66D  ; @HTRAPXX
!addr HTRAP2D = $D66D  ; @HTRAPXX
!addr CPU_HTRAP2E = $D66E  ; @HTRAPXX
!addr HTRAP2E = $D66E  ; @HTRAPXX
!addr CPU_HTRAP2F = $D66F  ; @HTRAPXX
!addr HTRAP2F = $D66F  ; @HTRAPXX
!addr CPU_HTRAP30 = $D670  ; @HTRAPXX
!addr HTRAP30 = $D670  ; @HTRAPXX
!addr HCPU_GEORAMBASE = $D670  ; Hypervisor GeoRAM base address (x MB)
!addr GEORAMBASE = $D670  ; Hypervisor GeoRAM base address (x MB)
!addr CPU_HTRAP31 = $D671  ; @HTRAPXX
!addr HTRAP31 = $D671  ; @HTRAPXX
!addr HCPU_GEORAMMASK = $D671  ; Hypervisor GeoRAM address mask (applied to GeoRAM block register)
!addr GEORAMMASK = $D671  ; Hypervisor GeoRAM address mask (applied to GeoRAM block register)
!addr CPU_HTRAP32 = $D672  ; @HTRAPXX
!addr HTRAP32 = $D672  ; @HTRAPXX
!addr HCPU_MATRIXEN_ADDR = $D672  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (address)
!addr MATRIXEN_ADDR = $D672  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (address)
HCPU_MATRIXEN_MASK = %01000000  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (bit mask)
!addr MATRIXEN_MASK = %01000000  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (bit mask)
!addr CPU_HTRAP33 = $D673  ; @HTRAPXX
!addr HTRAP33 = $D673  ; @HTRAPXX
!addr CPU_HTRAP34 = $D674  ; @HTRAPXX
!addr HTRAP34 = $D674  ; @HTRAPXX
!addr CPU_HTRAP35 = $D675  ; @HTRAPXX
!addr HTRAP35 = $D675  ; @HTRAPXX
!addr CPU_HTRAP36 = $D676  ; @HTRAPXX
!addr HTRAP36 = $D676  ; @HTRAPXX
!addr CPU_HTRAP37 = $D677  ; @HTRAPXX
!addr HTRAP37 = $D677  ; @HTRAPXX
!addr CPU_HTRAP38 = $D678  ; @HTRAPXX
!addr HTRAP38 = $D678  ; @HTRAPXX
!addr CPU_HTRAP39 = $D679  ; @HTRAPXX
!addr HTRAP39 = $D679  ; @HTRAPXX
!addr CPU_HTRAP3A = $D67A  ; @HTRAPXX
!addr HTRAP3A = $D67A  ; @HTRAPXX
!addr CPU_HTRAP3B = $D67B  ; @HTRAPXX
!addr HTRAP3B = $D67B  ; @HTRAPXX
!addr CPU_HTRAP3C = $D67C  ; @HTRAPXX
!addr HTRAP3C = $D67C  ; @HTRAPXX
!addr HCPU_UARTDATA_ADDR = $D67C  ; (write) Hypervisor write serial output to UART monitor (address)
!addr UARTDATA_ADDR = $D67C  ; (write) Hypervisor write serial output to UART monitor (address)
HCPU_UARTDATA_MASK = %11111111  ; (write) Hypervisor write serial output to UART monitor (bit mask)
!addr UARTDATA_MASK = %11111111  ; (write) Hypervisor write serial output to UART monitor (bit mask)
!addr CPU_HTRAP3D = $D67D  ; @HTRAPXX
!addr HTRAP3D = $D67D  ; @HTRAPXX
!addr HCPU_WATCHDOG = $D67D  ; Hypervisor watchdog register: writing any value clears the watch dog
!addr WATCHDOG = $D67D  ; Hypervisor watchdog register: writing any value clears the watch dog
!addr HCPU_RSVD_ADDR = $D67D  ; RESERVED (address)
!addr RSVD_ADDR = $D67D  ; RESERVED (address)
HCPU_RSVD_MASK = %00000001  ; RESERVED (bit mask)
!addr RSVD_MASK = %00000001  ; RESERVED (bit mask)
!addr HCPU_JMP32EN_ADDR = $D67D  ; Hypervisor enable 32-bit JMP/JSR etc (address)
!addr JMP32EN_ADDR = $D67D  ; Hypervisor enable 32-bit JMP/JSR etc (address)
HCPU_JMP32EN_MASK = %00000010  ; Hypervisor enable 32-bit JMP/JSR etc (bit mask)
!addr JMP32EN_MASK = %00000010  ; Hypervisor enable 32-bit JMP/JSR etc (bit mask)
!addr HCPU_ROMPROT_ADDR = $D67D  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (address)
!addr ROMPROT_ADDR = $D67D  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (address)
HCPU_ROMPROT_MASK = %00000100  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (bit mask)
!addr ROMPROT_MASK = %00000100  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (bit mask)
!addr HCPU_ASCFAST_ADDR = $D67D  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (address)
!addr ASCFAST_ADDR = $D67D  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (address)
HCPU_ASCFAST_MASK = %00001000  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (bit mask)
!addr ASCFAST_MASK = %00001000  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (bit mask)
!addr HCPU_CPUFAST_ADDR = $D67D  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (address)
!addr CPUFAST_ADDR = $D67D  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (address)
HCPU_CPUFAST_MASK = %00010000  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (bit mask)
!addr CPUFAST_MASK = %00010000  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (bit mask)
!addr HCPU_F4502_ADDR = $D67D  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (address)
!addr F4502_ADDR = $D67D  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (address)
HCPU_F4502_MASK = %00100000  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (bit mask)
!addr F4502_MASK = %00100000  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (bit mask)
!addr HCPU_PIRQ_ADDR = $D67D  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (address)
!addr PIRQ_ADDR = $D67D  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (address)
HCPU_PIRQ_MASK = %01000000  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (bit mask)
!addr PIRQ_MASK = %01000000  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (bit mask)
!addr HCPU_PNMI_ADDR = $D67D  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (address)
!addr PNMI_ADDR = $D67D  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (address)
HCPU_PNMI_MASK = %10000000  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (bit mask)
!addr PNMI_MASK = %10000000  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (bit mask)
!addr CPU_HTRAP3E = $D67E  ; @HTRAPXX
!addr HTRAP3E = $D67E  ; @HTRAPXX
!addr HCPU_HICKED = $D67E  ; Hypervisor already-upgraded bit (writing sets permanently)
!addr HICKED = $D67E  ; Hypervisor already-upgraded bit (writing sets permanently)
!addr CPU_HTRAP3F = $D67F  ; @HTRAPXX
!addr HTRAP3F = $D67F  ; @HTRAPXX
!addr HCPU_ENTEREXIT = $D67F  ; Writing trigger return from hypervisor
!addr ENTEREXIT = $D67F  ; Writing trigger return from hypervisor
!addr SD_CMDANDSTAT = $D680  ; SD controller status/command
!addr CMDANDSTAT = $D680  ; SD controller status/command
!addr SD_SECTOR0 = $D681  ; SD controller SD sector address (LSB)
!addr SECTOR0 = $D681  ; SD controller SD sector address (LSB)
!addr SD_SECTOR1 = $D682  ; SD controller SD sector address (2nd byte)
!addr SECTOR1 = $D682  ; SD controller SD sector address (2nd byte)
!addr SD_SECTOR2 = $D683  ; SD controller SD sector address (3rd byte)
!addr SECTOR2 = $D683  ; SD controller SD sector address (3rd byte)
!addr SD_SECTOR3 = $D684  ; SD controller SD sector address (MSB)
!addr SECTOR3 = $D684  ; SD controller SD sector address (MSB)
!addr SD_FILLVAL = $D686  ; WRITE ONLY set fill byte for use in fill mode, instead of SD buffer data
!addr FILLVAL = $D686  ; WRITE ONLY set fill byte for use in fill mode, instead of SD buffer data
!addr SD_BUFBIT8_ADDR = $D689  ; (read only) reads bit 8 of the sector buffer pointer (address)
!addr BUFBIT8_ADDR = $D689  ; (read only) reads bit 8 of the sector buffer pointer (address)
SD_BUFBIT8_MASK = %00000001  ; (read only) reads bit 8 of the sector buffer pointer (bit mask)
!addr BUFBIT8_MASK = %00000001  ; (read only) reads bit 8 of the sector buffer pointer (bit mask)
!addr SD_BUFFFULL_ADDR = $D689  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (address)
!addr BUFFFULL_ADDR = $D689  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (address)
SD_BUFFFULL_MASK = %00000010  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (bit mask)
!addr BUFFFULL_MASK = %00000010  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (bit mask)
!addr SD_HNDSHK_ADDR = $D689  ; Set/read SD card sd_handshake signal (address)
!addr HNDSHK_ADDR = $D689  ; Set/read SD card sd_handshake signal (address)
SD_HNDSHK_MASK = %00000100  ; Set/read SD card sd_handshake signal (bit mask)
!addr HNDSHK_MASK = %00000100  ; Set/read SD card sd_handshake signal (bit mask)
!addr SD_DRDY_ADDR = $D689  ; SD Card Data Ready indication (address)
!addr DRDY_ADDR = $D689  ; SD Card Data Ready indication (address)
SD_DRDY_MASK = %00001000  ; SD Card Data Ready indication (bit mask)
!addr DRDY_MASK = %00001000  ; SD Card Data Ready indication (bit mask)
!addr SD_RESERVED_ADDR = $D689  ; Reserved (address)
SD_RESERVED_MASK = %00010000  ; Reserved (bit mask)
!addr SD_FDCSWAP_ADDR = $D689  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (address)
!addr FDCSWAP_ADDR = $D689  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (address)
SD_FDCSWAP_MASK = %00100000  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (bit mask)
!addr FDCSWAP_MASK = %00100000  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (bit mask)
!addr SD_BUFFSEL_ADDR = $D689  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (address)
!addr BUFFSEL_ADDR = $D689  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (address)
SD_BUFFSEL_MASK = %10000000  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (bit mask)
!addr BUFFSEL_MASK = %10000000  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (bit mask)
!addr SD_CDC00_ADDR = $D68A  ; (read only) Set if colour RAM at $DC00 (address)
!addr CDC00_ADDR = $D68A  ; (read only) Set if colour RAM at $DC00 (address)
SD_CDC00_MASK = %00000001  ; (read only) Set if colour RAM at $DC00 (bit mask)
!addr CDC00_MASK = %00000001  ; (read only) Set if colour RAM at $DC00 (bit mask)
!addr SD_VICIII_ADDR = $D68A  ; (read only) Set if VIC-IV or ethernet IO bank visible (address)
!addr VICIII_ADDR = $D68A  ; (read only) Set if VIC-IV or ethernet IO bank visible (address)
SD_VICIII_MASK = %00000010  ; (read only) Set if VIC-IV or ethernet IO bank visible (bit mask)
!addr VICIII_MASK = %00000010  ; (read only) Set if VIC-IV or ethernet IO bank visible (bit mask)
!addr SD_VFDC0_ADDR = $D68A  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (address)
!addr VFDC0_ADDR = $D68A  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (address)
SD_VFDC0_MASK = %00000100  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (bit mask)
!addr VFDC0_MASK = %00000100  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (bit mask)
!addr SD_VFDC1_ADDR = $D68A  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (address)
!addr VFDC1_ADDR = $D68A  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (address)
SD_VFDC1_MASK = %00001000  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (bit mask)
!addr VFDC1_MASK = %00001000  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (bit mask)
!addr SDFDC_D0IMG_ADDR = $D68B  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (address)
!addr D0IMG_ADDR = $D68B  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (address)
SDFDC_D0IMG_MASK = %00000001  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (bit mask)
!addr D0IMG_MASK = %00000001  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (bit mask)
!addr SDFDC_D0P_ADDR = $D68B  ; F011 drive 0 media present (address)
!addr D0P_ADDR = $D68B  ; F011 drive 0 media present (address)
SDFDC_D0P_MASK = %00000010  ; F011 drive 0 media present (bit mask)
!addr D0P_MASK = %00000010  ; F011 drive 0 media present (bit mask)
!addr SDFDC_D0WP_ADDR = $D68B  ; Write enable F011 drive 0 (address)
!addr D0WP_ADDR = $D68B  ; Write enable F011 drive 0 (address)
SDFDC_D0WP_MASK = %00000100  ; Write enable F011 drive 0 (bit mask)
!addr D0WP_MASK = %00000100  ; Write enable F011 drive 0 (bit mask)
!addr SDFDC_D1IMG_ADDR = $D68B  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (address)
!addr D1IMG_ADDR = $D68B  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (address)
SDFDC_D1IMG_MASK = %00001000  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (bit mask)
!addr D1IMG_MASK = %00001000  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (bit mask)
!addr SDFDC_D1P_ADDR = $D68B  ; F011 drive 1 media present (address)
!addr D1P_ADDR = $D68B  ; F011 drive 1 media present (address)
SDFDC_D1P_MASK = %00010000  ; F011 drive 1 media present (bit mask)
!addr D1P_MASK = %00010000  ; F011 drive 1 media present (bit mask)
!addr SDFDC_D1WP_ADDR = $D68B  ; Write enable F011 drive 1 (address)
!addr D1WP_ADDR = $D68B  ; Write enable F011 drive 1 (address)
SDFDC_D1WP_MASK = %00100000  ; Write enable F011 drive 1 (bit mask)
!addr D1WP_MASK = %00100000  ; Write enable F011 drive 1 (bit mask)
!addr F011_MDISK0_ADDR = $D68B  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 0 (address)
F011_MDISK0_MASK = %01000000  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 0 (bit mask)
!addr SDFDC_D0MD_ADDR = $D68B  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
!addr D0MD_ADDR = $D68B  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
SDFDC_D0MD_MASK = %01000000  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
!addr D0MD_MASK = %01000000  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
!addr GS_F011_MDISK0_ADDR = $D68B  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 1 (address)
GS_F011_MDISK0_MASK = %10000000  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 1 (bit mask)
!addr SDFDC_D1MD_ADDR = $D68B  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
!addr D1MD_ADDR = $D68B  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
SDFDC_D1MD_MASK = %10000000  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
!addr D1MD_MASK = %10000000  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
!addr F011_DISKADDR0 = $D68C  ; Diskimage sector number (bits 0-7)
!addr DISKADDR0 = $D68C  ; Diskimage sector number (bits 0-7)
!addr SDFDC_D0STARTSEC0 = $D68C  ; F011 drive 0 disk image address on SD card (LSB)
!addr D0STARTSEC0 = $D68C  ; F011 drive 0 disk image address on SD card (LSB)
!addr F011_DISKADDR1 = $D68D  ; Diskimage sector number (bits 8-15)
!addr DISKADDR1 = $D68D  ; Diskimage sector number (bits 8-15)
!addr SDFDC_D0STARTSEC1 = $D68D  ; F011 drive 0 disk image address on SD card (2nd byte)
!addr D0STARTSEC1 = $D68D  ; F011 drive 0 disk image address on SD card (2nd byte)
!addr F011_DISKADDR2 = $D68E  ; Diskimage sector number (bits 16-23)
!addr DISKADDR2 = $D68E  ; Diskimage sector number (bits 16-23)
!addr SDFDC_D0STARTSEC2 = $D68E  ; F011 drive 0 disk image address on SD card (3rd byte)
!addr D0STARTSEC2 = $D68E  ; F011 drive 0 disk image address on SD card (3rd byte)
!addr F011_DISKADDR3 = $D68F  ; Diskimage sector number (bits 24-31)
!addr DISKADDR3 = $D68F  ; Diskimage sector number (bits 24-31)
!addr SDFDC_D0STARTSEC3 = $D68F  ; F011 drive 0 disk image address on SD card (MSB)
!addr D0STARTSEC3 = $D68F  ; F011 drive 0 disk image address on SD card (MSB)
!addr F011_DISK2ADDR0 = $D690  ; Diskimage 2 sector number (bits 0-7)
!addr DISK2ADDR0 = $D690  ; Diskimage 2 sector number (bits 0-7)
!addr SDFDC_D1STARTSEC0 = $D690  ; F011 drive 1 disk image address on SD card (LSB)
!addr D1STARTSEC0 = $D690  ; F011 drive 1 disk image address on SD card (LSB)
!addr F011_DISK2ADDR1 = $D691  ; Diskimage 2 sector number (bits 8-15)
!addr DISK2ADDR1 = $D691  ; Diskimage 2 sector number (bits 8-15)
!addr SDFDC_D1STARTSEC1 = $D691  ; F011 drive 1 disk image address on SD card (2nd byte)
!addr D1STARTSEC1 = $D691  ; F011 drive 1 disk image address on SD card (2nd byte)
!addr F011_DISK2ADDR2 = $D692  ; Diskimage 2 sector number (bits 16-23)
!addr DISK2ADDR2 = $D692  ; Diskimage 2 sector number (bits 16-23)
!addr SDFDC_D1STARTSEC2 = $D692  ; F011 drive 1 disk image address on SD card (3rd byte)
!addr D1STARTSEC2 = $D692  ; F011 drive 1 disk image address on SD card (3rd byte)
!addr F011_DISK2ADDR3 = $D693  ; Diskimage 2 sector number (bits 24-31)
!addr DISK2ADDR3 = $D693  ; Diskimage 2 sector number (bits 24-31)
!addr SDFDC_D1STARTSEC3 = $D693  ; F011 drive 1 disk image address on SD card (MSB)
!addr D1STARTSEC3 = $D693  ; F011 drive 1 disk image address on SD card (MSB)
!addr F011_AUTOTUNE = $D696  ; Enable automatic track seeking for sector reads and writes
!addr AUTOTUNE = $D696  ; Enable automatic track seeking for sector reads and writes
!addr DEBUG_J21INL = $D69B  ; Status of M65 R3 J21 pins
!addr J21INL = $D69B  ; Status of M65 R3 J21 pins
!addr DEBUG_J21INH = $D69C  ; Status of M65 R3 J21 pins
!addr J21INH = $D69C  ; Status of M65 R3 J21 pins
!addr DEBUG_DIPSW = $D69D  ; Status of M65 R3 DIP switches
!addr DIPSW = $D69D  ; Status of M65 R3 DIP switches
!addr DEBUG_SWSTATUS = $D69E  ; Status of switches 0 to 7
!addr GS_DEBUG_SWSTATUS = $D69F  ; Status of switches 8 to 15
!addr FDC_DBGWGATE_ADDR = $D6A0  ; Control floppy drive SIDE1 line (address)
FDC_DBGWGATE_MASK = %00000001  ; Control floppy drive SIDE1 line (bit mask)
!addr GS_FDC_DBGWGATE_ADDR = $D6A0  ; Control floppy drive WGATE line (address)
GS_FDC_DBGWGATE_MASK = %00000010  ; Control floppy drive WGATE line (bit mask)
!addr FDC_DBGWDATA_ADDR = $D6A0  ; Control floppy drive WDATA line (address)
!addr DBGWDATA_ADDR = $D6A0  ; Control floppy drive WDATA line (address)
FDC_DBGWDATA_MASK = %00000100  ; Control floppy drive WDATA line (bit mask)
!addr DBGWDATA_MASK = %00000100  ; Control floppy drive WDATA line (bit mask)
!addr FDC_DBGDIR_ADDR = $D6A0  ; Control floppy drive STEP line (address)
FDC_DBGDIR_MASK = %00001000  ; Control floppy drive STEP line (bit mask)
!addr GS_FDC_DBGDIR_ADDR = $D6A0  ; Control floppy drive STEPDIR line (address)
GS_FDC_DBGDIR_MASK = %00010000  ; Control floppy drive STEPDIR line (bit mask)
!addr FDC_DBGMOTORA_ADDR = $D6A0  ; Control floppy drive SELECT line (address)
FDC_DBGMOTORA_MASK = %00100000  ; Control floppy drive SELECT line (bit mask)
!addr GS_FDC_DBGMOTORA_ADDR = $D6A0  ; Control floppy drive MOTOR line (address)
GS_FDC_DBGMOTORA_MASK = %01000000  ; Control floppy drive MOTOR line (bit mask)
!addr FDC_DENSITY_ADDR = $D6A0  ; Control floppy drive density select line (address)
!addr DENSITY_ADDR = $D6A0  ; Control floppy drive density select line (address)
FDC_DENSITY_MASK = %10000000  ; Control floppy drive density select line (bit mask)
!addr DENSITY_MASK = %10000000  ; Control floppy drive density select line (bit mask)
!addr F011_DRV0EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 1st floppy drive (address)
!addr DRV0EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 1st floppy drive (address)
F011_DRV0EN_MASK = %00000001  ; Use real floppy drive instead of SD card for 1st floppy drive (bit mask)
!addr DRV0EN_MASK = %00000001  ; Use real floppy drive instead of SD card for 1st floppy drive (bit mask)
!addr SDFDC_USEREAL0_ADDR = $D6A1  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (address)
!addr USEREAL0_ADDR = $D6A1  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (address)
SDFDC_USEREAL0_MASK = %00000001  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (bit mask)
!addr USEREAL0_MASK = %00000001  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (bit mask)
!addr SDFDC_TARGANY_ADDR = $D6A1  ; Read next sector under head if set, ignoring the requested side, track and sector number. (address)
!addr TARGANY_ADDR = $D6A1  ; Read next sector under head if set, ignoring the requested side, track and sector number. (address)
SDFDC_TARGANY_MASK = %00000010  ; Read next sector under head if set, ignoring the requested side, track and sector number. (bit mask)
!addr TARGANY_MASK = %00000010  ; Read next sector under head if set, ignoring the requested side, track and sector number. (bit mask)
!addr F011_DRV2EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 2nd floppy drive (address)
!addr DRV2EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 2nd floppy drive (address)
F011_DRV2EN_MASK = %00000100  ; Use real floppy drive instead of SD card for 2nd floppy drive (bit mask)
!addr DRV2EN_MASK = %00000100  ; Use real floppy drive instead of SD card for 2nd floppy drive (bit mask)
!addr SDFDC_USEREAL1_ADDR = $D6A1  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (address)
!addr USEREAL1_ADDR = $D6A1  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (address)
SDFDC_USEREAL1_MASK = %00000100  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (bit mask)
!addr USEREAL1_MASK = %00000100  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (bit mask)
!addr SDFDC_SILENT_ADDR = $D6A1  ; Disable floppy spinning and tracking for SD card operations. (address)
!addr SILENT_ADDR = $D6A1  ; Disable floppy spinning and tracking for SD card operations. (address)
SDFDC_SILENT_MASK = %00001000  ; Disable floppy spinning and tracking for SD card operations. (bit mask)
!addr SILENT_MASK = %00001000  ; Disable floppy spinning and tracking for SD card operations. (bit mask)
!addr FDC_DATARATE = $D6A2  ; Set number of bus cycles per floppy magnetic interval (decrease to increase data rate)
!addr DATARATE = $D6A2  ; Set number of bus cycles per floppy magnetic interval (decrease to increase data rate)
!addr MISCIO_WHEEL3TARGET_ADDR = $D6AC  ; Select audio channel volume to be set by thumb wheel #3 (address)
!addr WHEEL3TARGET_ADDR = $D6AC  ; Select audio channel volume to be set by thumb wheel #3 (address)
MISCIO_WHEEL3TARGET_MASK = %00001111  ; Select audio channel volume to be set by thumb wheel #3 (bit mask)
!addr WHEEL3TARGET_MASK = %00001111  ; Select audio channel volume to be set by thumb wheel #3 (bit mask)
!addr MISCIO_WHEELBRIGHTEN_ADDR = $D6AC  ; Enable control of LCD panel brightness via thumb wheel (address)
!addr WHEELBRIGHTEN_ADDR = $D6AC  ; Enable control of LCD panel brightness via thumb wheel (address)
MISCIO_WHEELBRIGHTEN_MASK = %10000000  ; Enable control of LCD panel brightness via thumb wheel (bit mask)
!addr WHEELBRIGHTEN_MASK = %10000000  ; Enable control of LCD panel brightness via thumb wheel (bit mask)
!addr MISCIO_WHEEL1TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #1 (address)
!addr WHEEL1TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #1 (address)
MISCIO_WHEEL1TARGET_MASK = %00001111  ; Select audio channel volume to be set by thumb wheel #1 (bit mask)
!addr WHEEL1TARGET_MASK = %00001111  ; Select audio channel volume to be set by thumb wheel #1 (bit mask)
!addr MISCIO_WHEEL2TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #2 (address)
!addr WHEEL2TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #2 (address)
MISCIO_WHEEL2TARGET_MASK = %11110000  ; Select audio channel volume to be set by thumb wheel #2 (bit mask)
!addr WHEEL2TARGET_MASK = %11110000  ; Select audio channel volume to be set by thumb wheel #2 (bit mask)
!addr SD_FDC_ENC_ADDR = $D6AE  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (address)
!addr FDC_ENC_ADDR = $D6AE  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (address)
SD_FDC_ENC_MASK = %00001111  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (bit mask)
!addr FDC_ENC_MASK = %00001111  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (bit mask)
!addr SD_AUTO_2XSEL_ADDR = $D6AE  ; Automatically select DD or HD decoder for last sector display (address)
!addr AUTO_2XSEL_ADDR = $D6AE  ; Automatically select DD or HD decoder for last sector display (address)
SD_AUTO_2XSEL_MASK = %00010000  ; Automatically select DD or HD decoder for last sector display (bit mask)
!addr AUTO_2XSEL_MASK = %00010000  ; Automatically select DD or HD decoder for last sector display (bit mask)
!addr SD_FDC_VARSPD_ADDR = $D6AE  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (address)
!addr FDC_VARSPD_ADDR = $D6AE  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (address)
SD_FDC_VARSPD_MASK = %00100000  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (bit mask)
!addr FDC_VARSPD_MASK = %00100000  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (bit mask)
!addr SD_FDC_2XSEL_ADDR = $D6AE  ; Select HD decoder for last sector display (address)
!addr FDC_2XSEL_ADDR = $D6AE  ; Select HD decoder for last sector display (address)
SD_FDC_2XSEL_MASK = %01000000  ; Select HD decoder for last sector display (bit mask)
!addr FDC_2XSEL_MASK = %01000000  ; Select HD decoder for last sector display (bit mask)
!addr SD_FDC_TIBEN_ADDR = $D6AE  ; Enable use of Track Info Block settings (address)
!addr FDC_TIBEN_ADDR = $D6AE  ; Enable use of Track Info Block settings (address)
SD_FDC_TIBEN_MASK = %10000000  ; Enable use of Track Info Block settings (bit mask)
!addr FDC_TIBEN_MASK = %10000000  ; Enable use of Track Info Block settings (bit mask)
!addr SD_VR_FOUND_ADDR = $D6AF  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (address)
!addr VR_FOUND_ADDR = $D6AF  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (address)
SD_VR_FOUND_MASK = %00000001  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (bit mask)
!addr VR_FOUND_MASK = %00000001  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (bit mask)
!addr SD_VW_FOUND_ADDR = $D6AF  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (address)
!addr VW_FOUND_ADDR = $D6AF  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (address)
SD_VW_FOUND_MASK = %00000010  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (bit mask)
!addr VW_FOUND_MASK = %00000010  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (bit mask)
!addr SD_VEQ_INH_ADDR = $D6AF  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (address)
!addr VEQ_INH_ADDR = $D6AF  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (address)
SD_VEQ_INH_MASK = %00000100  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (bit mask)
!addr VEQ_INH_MASK = %00000100  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (bit mask)
!addr SD_VRNF_ADDR = $D6AF  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (address)
!addr VRNF_ADDR = $D6AF  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (address)
SD_VRNF_MASK = %00001000  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (bit mask)
!addr VRNF_MASK = %00001000  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (bit mask)
!addr SD_VDRQ_ADDR = $D6AF  ; Manually set f011_drq signal (indented for virtual F011 mode only) (address)
!addr VDRQ_ADDR = $D6AF  ; Manually set f011_drq signal (indented for virtual F011 mode only) (address)
SD_VDRQ_MASK = %00010000  ; Manually set f011_drq signal (indented for virtual F011 mode only) (bit mask)
!addr VDRQ_MASK = %00010000  ; Manually set f011_drq signal (indented for virtual F011 mode only) (bit mask)
!addr SD_VLOST_ADDR = $D6AF  ; Manually set f011_lost signal (indented for virtual F011 mode only) (address)
!addr VLOST_ADDR = $D6AF  ; Manually set f011_lost signal (indented for virtual F011 mode only) (address)
SD_VLOST_MASK = %00100000  ; Manually set f011_lost signal (indented for virtual F011 mode only) (bit mask)
!addr VLOST_MASK = %00100000  ; Manually set f011_lost signal (indented for virtual F011 mode only) (bit mask)
!addr TOUCH_EV1_ADDR = $D6B0  ; Touch event 1 is valid (address)
!addr EV1_ADDR = $D6B0  ; Touch event 1 is valid (address)
TOUCH_EV1_MASK = %00000001  ; Touch event 1 is valid (bit mask)
!addr EV1_MASK = %00000001  ; Touch event 1 is valid (bit mask)
!addr TOUCH_EV2_ADDR = $D6B0  ; Touch event 2 is valid (address)
!addr EV2_ADDR = $D6B0  ; Touch event 2 is valid (address)
TOUCH_EV2_MASK = %00000010  ; Touch event 2 is valid (bit mask)
!addr EV2_MASK = %00000010  ; Touch event 2 is valid (bit mask)
!addr TOUCH_UPDN1_ADDR = $D6B0  ; Touch event 1 up/down state (address)
!addr UPDN1_ADDR = $D6B0  ; Touch event 1 up/down state (address)
TOUCH_UPDN1_MASK = %00001100  ; Touch event 1 up/down state (bit mask)
!addr UPDN1_MASK = %00001100  ; Touch event 1 up/down state (bit mask)
!addr TOUCH_UPDN2_ADDR = $D6B0  ; Touch event 2 up/down state (address)
!addr UPDN2_ADDR = $D6B0  ; Touch event 2 up/down state (address)
TOUCH_UPDN2_MASK = %00110000  ; Touch event 2 up/down state (bit mask)
!addr UPDN2_MASK = %00110000  ; Touch event 2 up/down state (bit mask)
!addr MISCIO_TCHFLX_ADDR = $D6B0  ; Flip X axis of touch interface if set (address)
MISCIO_TCHFLX_MASK = %01000000  ; Flip X axis of touch interface if set (bit mask)
!addr TOUCH_XINV_ADDR = $D6B0  ; Invert horizontal axis (address)
!addr XINV_ADDR = $D6B0  ; Invert horizontal axis (address)
TOUCH_XINV_MASK = %01000000  ; Invert horizontal axis (bit mask)
!addr XINV_MASK = %01000000  ; Invert horizontal axis (bit mask)
!addr GS_MISCIO_TCHFLX_ADDR = $D6B0  ; Flip Y axis of touch interface if set (address)
GS_MISCIO_TCHFLX_MASK = %10000000  ; Flip Y axis of touch interface if set (bit mask)
!addr TOUCH_YINV_ADDR = $D6B0  ; Invert vertical axis (address)
!addr YINV_ADDR = $D6B0  ; Invert vertical axis (address)
TOUCH_YINV_MASK = %10000000  ; Invert vertical axis (bit mask)
!addr YINV_MASK = %10000000  ; Invert vertical axis (bit mask)
!addr MISCIO_TCHXSCALE = $D6B1  ; Set X scale value for touch interface (LSB)
!addr TOUCH_CALXSCALELSB = $D6B1  ; Touch pad X scaling LSB
!addr CALXSCALELSB = $D6B1  ; Touch pad X scaling LSB
!addr GS_MISCIO_TCHXSCALE = $D6B2  ; Set X scale value for touch interface (MSB)
!addr TOUCH_CALXSCALEMSB = $D6B2  ; Touch pad X scaling MSB
!addr CALXSCALEMSB = $D6B2  ; Touch pad X scaling MSB
!addr MISCIO_TCHYSCALE = $D6B3  ; Set Y scale value for touch interface (LSB)
!addr TOUCH_CALYSCALELSB = $D6B3  ; Touch pad Y scaling LSB
!addr CALYSCALELSB = $D6B3  ; Touch pad Y scaling LSB
!addr GS_MISCIO_TCHYSCALE = $D6B4  ; Set Y scale value for touch interface (MSB)
!addr TOUCH_CALYSCALEMSB = $D6B4  ; Touch pad Y scaling MSB
!addr CALYSCALEMSB = $D6B4  ; Touch pad Y scaling MSB
!addr MISCIO_TCHXDELTA = $D6B5  ; Set X delta value for touch interface (LSB)
!addr TOUCH_CALXDELTALSB = $D6B5  ; Touch pad X delta LSB
!addr CALXDELTALSB = $D6B5  ; Touch pad X delta LSB
!addr MISCIO_TCHYDELTA = $D6B7  ; Set Y delta value for touch interface (LSB)
!addr TOUCH_CALYDELTALSB = $D6B7  ; Touch pad Y delta LSB
!addr CALYDELTALSB = $D6B7  ; Touch pad Y delta LSB
!addr GS_MISCIO_TCHYDELTA = $D6B8  ; Set Y delta value for touch interface (MSB)
!addr TOUCH_CALYDELTAMSB = $D6B8  ; Touch pad Y delta MSB
!addr CALYDELTAMSB = $D6B8  ; Touch pad Y delta MSB
!addr TOUCH_TOUCH1XLSB = $D6B9  ; Touch pad touch #1 X LSB
!addr TOUCH1XLSB = $D6B9  ; Touch pad touch #1 X LSB
!addr TOUCH_TOUCH1YLSB = $D6BA  ; Touch pad touch #1 Y LSB
!addr TOUCH1YLSB = $D6BA  ; Touch pad touch #1 Y LSB
!addr GS_MISCIO_TCHXDELTA = $D6BB  ; Set X delta value for touch interface (MSB)
!addr TOUCH_TOUCH1XMSB_ADDR = $D6BB  ; Touch pad touch \#1 X MSBs (address)
!addr TOUCH1XMSB_ADDR = $D6BB  ; Touch pad touch \#1 X MSBs (address)
TOUCH_TOUCH1XMSB_MASK = %00000011  ; Touch pad touch \#1 X MSBs (bit mask)
!addr TOUCH1XMSB_MASK = %00000011  ; Touch pad touch \#1 X MSBs (bit mask)
!addr TOUCH_TOUCH1YMSB_ADDR = $D6BB  ; Touch pad touch \#1 Y MSBs (address)
!addr TOUCH1YMSB_ADDR = $D6BB  ; Touch pad touch \#1 Y MSBs (address)
TOUCH_TOUCH1YMSB_MASK = %00110000  ; Touch pad touch \#1 Y MSBs (bit mask)
!addr TOUCH1YMSB_MASK = %00110000  ; Touch pad touch \#1 Y MSBs (bit mask)
!addr TOUCH_TOUCH2XLSB = $D6BC  ; Touch pad touch \#2 X LSB
!addr TOUCH2XLSB = $D6BC  ; Touch pad touch \#2 X LSB
!addr TOUCH_TOUCH2YLSB = $D6BD  ; Touch pad touch \#2 Y LSB
!addr TOUCH2YLSB = $D6BD  ; Touch pad touch \#2 Y LSB
!addr TOUCH_TOUCH2XMSB_ADDR = $D6BE  ; Touch pad touch \#2 X MSBs (address)
!addr TOUCH2XMSB_ADDR = $D6BE  ; Touch pad touch \#2 X MSBs (address)
TOUCH_TOUCH2XMSB_MASK = %00000011  ; Touch pad touch \#2 X MSBs (bit mask)
!addr TOUCH2XMSB_MASK = %00000011  ; Touch pad touch \#2 X MSBs (bit mask)
!addr TOUCH_TOUCH2YMSB_ADDR = $D6BE  ; Touch pad touch \#2 Y MSBs (address)
!addr TOUCH2YMSB_ADDR = $D6BE  ; Touch pad touch \#2 Y MSBs (address)
TOUCH_TOUCH2YMSB_MASK = %00110000  ; Touch pad touch \#2 Y MSBs (bit mask)
!addr TOUCH2YMSB_MASK = %00110000  ; Touch pad touch \#2 Y MSBs (bit mask)
!addr MISCIO_TCHBYTENUM_ADDR = $D6BF  ; Select byte number for touch panel communications instrumentation (address)
!addr TCHBYTENUM_ADDR = $D6BF  ; Select byte number for touch panel communications instrumentation (address)
MISCIO_TCHBYTENUM_MASK = %01111111  ; Select byte number for touch panel communications instrumentation (bit mask)
!addr TCHBYTENUM_MASK = %01111111  ; Select byte number for touch panel communications instrumentation (bit mask)
!addr MISCIO_TCHI2CEN_ADDR = $D6BF  ; Enable/disable touch panel I2C communications (address)
!addr TCHI2CEN_ADDR = $D6BF  ; Enable/disable touch panel I2C communications (address)
MISCIO_TCHI2CEN_MASK = %10000000  ; Enable/disable touch panel I2C communications (bit mask)
!addr TCHI2CEN_MASK = %10000000  ; Enable/disable touch panel I2C communications (bit mask)
!addr TOUCH_GESTUREDIR_ADDR = $D6C0  ; Touch pad gesture directions (left,right,up,down) (address)
!addr GESTUREDIR_ADDR = $D6C0  ; Touch pad gesture directions (left,right,up,down) (address)
TOUCH_GESTUREDIR_MASK = %00001111  ; Touch pad gesture directions (left,right,up,down) (bit mask)
!addr GESTUREDIR_MASK = %00001111  ; Touch pad gesture directions (left,right,up,down) (bit mask)
!addr TOUCH_GESTUREID_ADDR = $D6C0  ; Touch pad gesture ID (address)
!addr GESTUREID_ADDR = $D6C0  ; Touch pad gesture ID (address)
TOUCH_GESTUREID_MASK = %11110000  ; Touch pad gesture ID (bit mask)
!addr GESTUREID_MASK = %11110000  ; Touch pad gesture ID (bit mask)
!addr FPGA_REGNUM = $D6C4  ; Select ICAPE2 FPGA configuration register for reading WRITE ONLY
!addr REGNUM = $D6C4  ; Select ICAPE2 FPGA configuration register for reading WRITE ONLY
!addr FPGA_REGVAL = $D6C4  ; Value of selected ICAPE2 register (least significant byte)
!addr GS_FPGA_REGVAL = $D6C5  ; Value of selected ICAPE2 register
!addr GS_FPGA_REGVAL_2 = $D6C6  ; Value of selected ICAPE2 register
!addr GS_FPGA_REGVAL_3 = $D6C7  ; Value of selected ICAPE2 register (most significant byte)
!addr FPGA_BOOTADDR0 = $D6C8  ; Address of bitstream in boot flash for reconfiguration (least significant byte)
!addr BOOTADDR0 = $D6C8  ; Address of bitstream in boot flash for reconfiguration (least significant byte)
!addr FPGA_BOOTADDR1 = $D6C9  ; Address of bitstream in boot flash for reconfiguration
!addr BOOTADDR1 = $D6C9  ; Address of bitstream in boot flash for reconfiguration
!addr FPGA_BOOTADDR2 = $D6CA  ; Address of bitstream in boot flash for reconfiguration
!addr BOOTADDR2 = $D6CA  ; Address of bitstream in boot flash for reconfiguration
!addr FPGA_BOOTADDR3 = $D6CB  ; Address of bitstream in boot flash for reconfiguration (most significant byte)
!addr BOOTADDR3 = $D6CB  ; Address of bitstream in boot flash for reconfiguration (most significant byte)
!addr QSPI_DB_ADDR = $D6CC  ; Data bits for QSPI flash interface (read/write) (address)
!addr DB_ADDR = $D6CC  ; Data bits for QSPI flash interface (read/write) (address)
QSPI_DB_MASK = %00001111  ; Data bits for QSPI flash interface (read/write) (bit mask)
!addr DB_MASK = %00001111  ; Data bits for QSPI flash interface (read/write) (bit mask)
!addr QSPI_RESERVED_ADDR = $D6CC  ; (set to 0) (address)
QSPI_RESERVED_MASK = %00010000  ; (set to 0) (bit mask)
!addr QSPI_CLOCK_ADDR = $D6CC  ; Clock output line for QSPI flash (address)
QSPI_CLOCK_MASK = %00100000  ; Clock output line for QSPI flash (bit mask)
!addr QSPI_CSN_ADDR = $D6CC  ; Active-low chip-select for QSPI flash (address)
!addr CSN_ADDR = $D6CC  ; Active-low chip-select for QSPI flash (address)
QSPI_CSN_MASK = %01000000  ; Active-low chip-select for QSPI flash (bit mask)
!addr CSN_MASK = %01000000  ; Active-low chip-select for QSPI flash (bit mask)
!addr QSPI_TRI_ADDR = $D6CC  ; Tristate DB0-3 (address)
!addr TRI_ADDR = $D6CC  ; Tristate DB0-3 (address)
QSPI_TRI_MASK = %10000000  ; Tristate DB0-3 (bit mask)
!addr TRI_MASK = %10000000  ; Tristate DB0-3 (bit mask)
!addr QSPI_CLOCKRUN_ADDR = $D6CD  ; Set to cause QSPI clock to free run at CPU clock frequency. (address)
!addr CLOCKRUN_ADDR = $D6CD  ; Set to cause QSPI clock to free run at CPU clock frequency. (address)
QSPI_CLOCKRUN_MASK = %00000001  ; Set to cause QSPI clock to free run at CPU clock frequency. (bit mask)
!addr CLOCKRUN_MASK = %00000001  ; Set to cause QSPI clock to free run at CPU clock frequency. (bit mask)
!addr GS_QSPI_CLOCK_ADDR = $D6CD  ; Alternate address for direct manipulation of QSPI CLOCK (address)
GS_QSPI_CLOCK_MASK = %00000010  ; Alternate address for direct manipulation of QSPI CLOCK (bit mask)
!addr FPGA_RECONFTRIG = $D6CF  ; Write $42 to Trigger FPGA reconfiguration to switch to alternate bitstream.
!addr RECONFTRIG = $D6CF  ; Write $42 to Trigger FPGA reconfiguration to switch to alternate bitstream.
!addr MISC_I2CBUSSELECT = $D6D0  ; I2C bus select (bus 0 = temp sensor on Nexys4 boardS)
!addr I2CBUSSELECT = $D6D0  ; I2C bus select (bus 0 = temp sensor on Nexys4 boardS)
!addr MISCIO_I2CBUSSEL = $D6D0  ; Select I2C bus number (I2C busses vary between MEGA65 and MEGAphone variants)
!addr I2CBUSSEL = $D6D0  ; Select I2C bus number (I2C busses vary between MEGA65 and MEGAphone variants)
!addr MISCIO_I2CRST_ADDR = $D6D1  ; I2C reset (address)
!addr I2CRST_ADDR = $D6D1  ; I2C reset (address)
MISCIO_I2CRST_MASK = %00000001  ; I2C reset (bit mask)
!addr I2CRST_MASK = %00000001  ; I2C reset (bit mask)
!addr MISCIO_I2CL_ADDR = $D6D1  ; I2C command latch write strobe (write 1 to trigger command) (address)
!addr I2CL_ADDR = $D6D1  ; I2C command latch write strobe (write 1 to trigger command) (address)
MISCIO_I2CL_MASK = %00000010  ; I2C command latch write strobe (write 1 to trigger command) (bit mask)
!addr I2CL_MASK = %00000010  ; I2C command latch write strobe (write 1 to trigger command) (bit mask)
!addr MISCIO_I2CRW_ADDR = $D6D1  ; I2C Select read (1) or write (0) (address)
!addr I2CRW_ADDR = $D6D1  ; I2C Select read (1) or write (0) (address)
MISCIO_I2CRW_MASK = %00000100  ; I2C Select read (1) or write (0) (bit mask)
!addr I2CRW_MASK = %00000100  ; I2C Select read (1) or write (0) (bit mask)
!addr MISCIO_I2CSW_ADDR = $D6D1  ; I2C bus 1 swap SDA/SCL pins (address)
!addr I2CSW_ADDR = $D6D1  ; I2C bus 1 swap SDA/SCL pins (address)
MISCIO_I2CSW_MASK = %00100000  ; I2C bus 1 swap SDA/SCL pins (bit mask)
!addr I2CSW_MASK = %00100000  ; I2C bus 1 swap SDA/SCL pins (bit mask)
!addr MISCIO_I2CBSY_ADDR = $D6D1  ; I2C busy flag (address)
!addr I2CBSY_ADDR = $D6D1  ; I2C busy flag (address)
MISCIO_I2CBSY_MASK = %01000000  ; I2C busy flag (bit mask)
!addr I2CBSY_MASK = %01000000  ; I2C busy flag (bit mask)
!addr MISCIO_I2CERR_ADDR = $D6D1  ; I2C ack error (address)
!addr I2CERR_ADDR = $D6D1  ; I2C ack error (address)
MISCIO_I2CERR_MASK = %10000000  ; I2C ack error (bit mask)
!addr I2CERR_MASK = %10000000  ; I2C ack error (bit mask)
!addr MISCIO_I2CADDR_ADDR = $D6D2  ; I2C address (address)
!addr I2CADDR_ADDR = $D6D2  ; I2C address (address)
MISCIO_I2CADDR_MASK = %11111110  ; I2C address (bit mask)
!addr I2CADDR_MASK = %11111110  ; I2C address (bit mask)
!addr MISCIO_I2CWDATA = $D6D3  ; I2C data write register
!addr I2CWDATA = $D6D3  ; I2C data write register
!addr MISCIO_I2CRDATA = $D6D4  ; I2C data read register
!addr I2CRDATA = $D6D4  ; I2C data read register
!addr MISC_SDDEBUGERRLSB = $D6DA  ; DEBUG SD card last error code LSB
!addr SDDEBUGERRLSB = $D6DA  ; DEBUG SD card last error code LSB
!addr MISC_SDDEBUGERRMSB = $D6DB  ; DEBUG SD card last error code MSB
!addr SDDEBUGERRMSB = $D6DB  ; DEBUG SD card last error code MSB
!addr FPGA_FPGATEMPLSB = $D6DE  ; FPGA die temperature sensor (lower nybl)
!addr FPGATEMPLSB = $D6DE  ; FPGA die temperature sensor (lower nybl)
!addr FPGA_FPGATEMPMSB = $D6DF  ; FPGA die temperature sensor (upper byte)
!addr FPGATEMPMSB = $D6DF  ; FPGA die temperature sensor (upper byte)
!addr ETH_RST_ADDR = $D6E0  ; Write 0 to hold ethernet controller under reset (address)
ETH_RST_MASK = %00000001  ; Write 0 to hold ethernet controller under reset (bit mask)
!addr ETH_TXRST_ADDR = $D6E0  ; Write 0 to hold ethernet controller transmit sub-system under reset (address)
!addr TXRST_ADDR = $D6E0  ; Write 0 to hold ethernet controller transmit sub-system under reset (address)
ETH_TXRST_MASK = %00000010  ; Write 0 to hold ethernet controller transmit sub-system under reset (bit mask)
!addr TXRST_MASK = %00000010  ; Write 0 to hold ethernet controller transmit sub-system under reset (bit mask)
!addr ETH_DRXD_ADDR = $D6E0  ; Read ethernet RX bits currently on the wire (address)
!addr DRXD_ADDR = $D6E0  ; Read ethernet RX bits currently on the wire (address)
ETH_DRXD_MASK = %00000100  ; Read ethernet RX bits currently on the wire (bit mask)
!addr DRXD_MASK = %00000100  ; Read ethernet RX bits currently on the wire (bit mask)
!addr ETH_DRXDV_ADDR = $D6E0  ; Read ethernet RX data valid (debug) (address)
!addr DRXDV_ADDR = $D6E0  ; Read ethernet RX data valid (debug) (address)
ETH_DRXDV_MASK = %00001000  ; Read ethernet RX data valid (debug) (bit mask)
!addr DRXDV_MASK = %00001000  ; Read ethernet RX data valid (debug) (bit mask)
!addr ETH_KEYEN_ADDR = $D6E0  ; Allow remote keyboard input via magic ethernet frames (address)
!addr KEYEN_ADDR = $D6E0  ; Allow remote keyboard input via magic ethernet frames (address)
ETH_KEYEN_MASK = %00010000  ; Allow remote keyboard input via magic ethernet frames (bit mask)
!addr KEYEN_MASK = %00010000  ; Allow remote keyboard input via magic ethernet frames (bit mask)
!addr ETH_RXBLKD_ADDR = $D6E0  ; Indicate if ethernet RX is blocked until RX buffers freed (address)
!addr RXBLKD_ADDR = $D6E0  ; Indicate if ethernet RX is blocked until RX buffers freed (address)
ETH_RXBLKD_MASK = %01000000  ; Indicate if ethernet RX is blocked until RX buffers freed (bit mask)
!addr RXBLKD_MASK = %01000000  ; Indicate if ethernet RX is blocked until RX buffers freed (bit mask)
!addr ETH_TXIDLE_ADDR = $D6E0  ; Ethernet transmit side is idle, i.e., a packet can be sent. (address)
!addr TXIDLE_ADDR = $D6E0  ; Ethernet transmit side is idle, i.e., a packet can be sent. (address)
ETH_TXIDLE_MASK = %10000000  ; Ethernet transmit side is idle, i.e., a packet can be sent. (bit mask)
!addr TXIDLE_MASK = %10000000  ; Ethernet transmit side is idle, i.e., a packet can be sent. (bit mask)
!addr ETH_RXBF_ADDR = $D6E1  ; Number of free receive buffers (address)
!addr RXBF_ADDR = $D6E1  ; Number of free receive buffers (address)
ETH_RXBF_MASK = %00000110  ; Number of free receive buffers (bit mask)
!addr RXBF_MASK = %00000110  ; Number of free receive buffers (bit mask)
!addr ETH_STRM_ADDR = $D6E1  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (address)
!addr STRM_ADDR = $D6E1  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (address)
ETH_STRM_MASK = %00001000  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (bit mask)
!addr STRM_MASK = %00001000  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (bit mask)
!addr ETH_TXQ_ADDR = $D6E1  ; Ethernet TX IRQ status (address)
!addr TXQ_ADDR = $D6E1  ; Ethernet TX IRQ status (address)
ETH_TXQ_MASK = %00010000  ; Ethernet TX IRQ status (bit mask)
!addr TXQ_MASK = %00010000  ; Ethernet TX IRQ status (bit mask)
!addr ETH_RXQ_ADDR = $D6E1  ; Ethernet RX IRQ status (address)
!addr RXQ_ADDR = $D6E1  ; Ethernet RX IRQ status (address)
ETH_RXQ_MASK = %00100000  ; Ethernet RX IRQ status (bit mask)
!addr RXQ_MASK = %00100000  ; Ethernet RX IRQ status (bit mask)
!addr ETH_TXQEN_ADDR = $D6E1  ; Enable ethernet TX IRQ (address)
!addr TXQEN_ADDR = $D6E1  ; Enable ethernet TX IRQ (address)
ETH_TXQEN_MASK = %01000000  ; Enable ethernet TX IRQ (bit mask)
!addr TXQEN_MASK = %01000000  ; Enable ethernet TX IRQ (bit mask)
!addr ETH_RXQEN_ADDR = $D6E1  ; Enable ethernet RX IRQ (address)
!addr RXQEN_ADDR = $D6E1  ; Enable ethernet RX IRQ (address)
ETH_RXQEN_MASK = %10000000  ; Enable ethernet RX IRQ (bit mask)
!addr RXQEN_MASK = %10000000  ; Enable ethernet RX IRQ (bit mask)
!addr ETH_TXSZLSB = $D6E2  ; TX Packet size (low byte)
!addr TXSZLSB = $D6E2  ; TX Packet size (low byte)
!addr ETH_TXSZMSB = $D6E3  ; TX Packet size (high byte)
!addr TXSZMSB = $D6E3  ; TX Packet size (high byte)
!addr ETH_COMMAND = $D6E4  ; Ethernet command register (write only)
!addr ETH_NOPROM_ADDR = $D6E5  ; Ethernet disable promiscuous mode (address)
!addr NOPROM_ADDR = $D6E5  ; Ethernet disable promiscuous mode (address)
ETH_NOPROM_MASK = %00000001  ; Ethernet disable promiscuous mode (bit mask)
!addr NOPROM_MASK = %00000001  ; Ethernet disable promiscuous mode (bit mask)
!addr ETH_NOCRC_ADDR = $D6E5  ; Disable CRC check for received packets (address)
!addr NOCRC_ADDR = $D6E5  ; Disable CRC check for received packets (address)
ETH_NOCRC_MASK = %00000010  ; Disable CRC check for received packets (bit mask)
!addr NOCRC_MASK = %00000010  ; Disable CRC check for received packets (bit mask)
!addr ETH_TXPH_ADDR = $D6E5  ; Ethernet TX clock phase adjust (address)
!addr TXPH_ADDR = $D6E5  ; Ethernet TX clock phase adjust (address)
ETH_TXPH_MASK = %00001100  ; Ethernet TX clock phase adjust (bit mask)
!addr TXPH_MASK = %00001100  ; Ethernet TX clock phase adjust (bit mask)
!addr ETH_BCST_ADDR = $D6E5  ; Accept broadcast frames (address)
!addr BCST_ADDR = $D6E5  ; Accept broadcast frames (address)
ETH_BCST_MASK = %00010000  ; Accept broadcast frames (bit mask)
!addr BCST_MASK = %00010000  ; Accept broadcast frames (bit mask)
!addr ETH_MCST_ADDR = $D6E5  ; Accept multicast frames (address)
!addr MCST_ADDR = $D6E5  ; Accept multicast frames (address)
ETH_MCST_MASK = %00100000  ; Accept multicast frames (bit mask)
!addr MCST_MASK = %00100000  ; Accept multicast frames (bit mask)
!addr ETH_RXPH_ADDR = $D6E5  ; Ethernet RX clock phase adjust (address)
!addr RXPH_ADDR = $D6E5  ; Ethernet RX clock phase adjust (address)
ETH_RXPH_MASK = %11000000  ; Ethernet RX clock phase adjust (bit mask)
!addr RXPH_MASK = %11000000  ; Ethernet RX clock phase adjust (bit mask)
!addr ETH_MIIMREG_ADDR = $D6E6  ; Ethernet MIIM register number (address)
!addr MIIMREG_ADDR = $D6E6  ; Ethernet MIIM register number (address)
ETH_MIIMREG_MASK = %00011111  ; Ethernet MIIM register number (bit mask)
!addr MIIMREG_MASK = %00011111  ; Ethernet MIIM register number (bit mask)
!addr ETH_MIIMPHY_ADDR = $D6E6  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (address)
!addr MIIMPHY_ADDR = $D6E6  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (address)
ETH_MIIMPHY_MASK = %11100000  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (bit mask)
!addr MIIMPHY_MASK = %11100000  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (bit mask)
!addr ETH_MIIMVLSB = $D6E7  ; Ethernet MIIM register value (LSB)
!addr MIIMVLSB = $D6E7  ; Ethernet MIIM register value (LSB)
!addr ETH_MIIMVMSB = $D6E8  ; Ethernet MIIM register value (MSB)
!addr MIIMVMSB = $D6E8  ; Ethernet MIIM register value (MSB)
!addr ETH_MACADDR1 = $D6E9  ; Ethernet MAC address
!addr MACADDR1 = $D6E9  ; Ethernet MAC address
!addr ETH_MACADDR2 = $D6EA  ; @MACADDRX
!addr MACADDR2 = $D6EA  ; @MACADDRX
!addr ETH_MACADDR3 = $D6EB  ; @MACADDRX
!addr MACADDR3 = $D6EB  ; @MACADDRX
!addr ETH_MACADDR4 = $D6EC  ; @MACADDRX
!addr MACADDR4 = $D6EC  ; @MACADDRX
!addr ETH_MACADDR5 = $D6ED  ; @MACADDRX
!addr MACADDR5 = $D6ED  ; @MACADDRX
!addr ETH_MACADDR6 = $D6EE  ; @MACADDRX
!addr MACADDR6 = $D6EE  ; @MACADDRX
!addr ETH_DBGRXWCOUNT = $D6EF  ; DEBUG show number of writes to eth RX buffer
!addr DBGRXWCOUNT = $D6EF  ; DEBUG show number of writes to eth RX buffer
!addr ETH_DBGTXSTAT = $D6EF  ; DEBUG show current ethernet TX state
!addr DBGTXSTAT = $D6EF  ; DEBUG show current ethernet TX state
!addr MISC_LCDBRIGHTNESS = $D6F0  ; LCD panel brightness control
!addr LCDBRIGHTNESS = $D6F0  ; LCD panel brightness control
!addr MISCIO_LCDBRIGHT = $D6F0  ; LCD panel brightness control
!addr LCDBRIGHT = $D6F0  ; LCD panel brightness control
!addr MISC_FPGABUTTONS = $D6F2  ; Read FPGA five-way buttons
!addr FPGABUTTONS = $D6F2  ; Read FPGA five-way buttons
!addr MISC_ACCELBITBASH = $D6F3  ; Accelerometer bit-bash interface
!addr ACCELBITBASH = $D6F3  ; Accelerometer bit-bash interface
!addr MISCIO_ACCELBASH = $D6F3  ; Accelerometer bit-bashing port (debug only)
!addr ACCELBASH = $D6F3  ; Accelerometer bit-bashing port (debug only)
!addr AUDIO_MIXREGSEL = $D6F4  ; Audio Mixer register select
!addr MIXREGSEL = $D6F4  ; Audio Mixer register select
!addr AUDIOMIX_REGSEL = $D6F4  ; Audio Mixer register select
!addr REGSEL = $D6F4  ; Audio Mixer register select
!addr AUDIO_MIXREGDATA = $D6F5  ; Audio Mixer register read port
!addr MIXREGDATA = $D6F5  ; Audio Mixer register read port
!addr AUDIOMIX_REGWDATA = $D6F5  ; Audio Mixer register write port
!addr REGWDATA = $D6F5  ; Audio Mixer register write port
!addr MISC_PS2KEYSCANLSB = $D6F6  ; Keyboard scan code reader (lower byte)
!addr PS2KEYSCANLSB = $D6F6  ; Keyboard scan code reader (lower byte)
!addr MISC_PS2KEYSCANMSB = $D6F7  ; Keyboard scan code reader (upper nybl)
!addr PS2KEYSCANMSB = $D6F7  ; Keyboard scan code reader (upper nybl)
!addr AUDIO_DIGILEFTLSB = $D6F8  ; Digital audio, left channel, LSB
!addr DIGILEFTLSB = $D6F8  ; Digital audio, left channel, LSB
!addr AUDIO_DIGILLSB = $D6F8  ; 16-bit digital audio out (left LSB)
!addr DIGILLSB = $D6F8  ; 16-bit digital audio out (left LSB)
!addr AUDIO_DIGILEFTMSB = $D6F9  ; Digital audio, left channel, MSB
!addr DIGILEFTMSB = $D6F9  ; Digital audio, left channel, MSB
!addr AUDIO_DIGILMSB = $D6F9  ; 16-bit digital audio out (left MSB)
!addr DIGILMSB = $D6F9  ; 16-bit digital audio out (left MSB)
!addr AUDIO_DIGIRIGHTLSB = $D6FA  ; Digital audio, left channel, LSB
!addr DIGIRIGHTLSB = $D6FA  ; Digital audio, left channel, LSB
!addr AUDIO_DIGIRLSB = $D6FA  ; 16-bit digital audio out (right LSB)
!addr DIGIRLSB = $D6FA  ; 16-bit digital audio out (right LSB)
!addr AUDIO_DIGIRIGHTMSB = $D6FB  ; Digital audio, left channel, MSB
!addr DIGIRIGHTMSB = $D6FB  ; Digital audio, left channel, MSB
!addr AUDIO_DIGIRMSB = $D6FB  ; 16-bit digital audio out (right MSB)
!addr DIGIRMSB = $D6FB  ; 16-bit digital audio out (right MSB)
!addr AUDIO_READBACKLSB = $D6FC  ; audio read-back LSB (source selected by $D6F4)
!addr READBACKLSB = $D6FC  ; audio read-back LSB (source selected by $D6F4)
!addr AUDIO_READBACKMSB = $D6FD  ; audio read-back MSB (source selected by $D6F4)
!addr READBACKMSB = $D6FD  ; audio read-back MSB (source selected by $D6F4)
!addr DMA_ADDRLSBTRIG = $D700  ; DMAgic DMA list address LSB, and trigger DMA (when written)
!addr ADDRLSBTRIG = $D700  ; DMAgic DMA list address LSB, and trigger DMA (when written)
!addr DMA_ADDRMSB = $D701  ; DMA list address high byte (address bits 8 -- 15).
!addr ADDRMSB = $D701  ; DMA list address high byte (address bits 8 -- 15).
!addr DMA_ADDRBANK = $D702  ; DMA list address bank (address bits 16 -- 22). Writing clears \$D704.
!addr ADDRBANK = $D702  ; DMA list address bank (address bits 16 -- 22). Writing clears \$D704.
!addr DMA_EN018B_ADDR = $D703  ; DMA enable F018B mode (adds sub-command byte) (address)
!addr EN018B_ADDR = $D703  ; DMA enable F018B mode (adds sub-command byte) (address)
DMA_EN018B_MASK = %00000001  ; DMA enable F018B mode (adds sub-command byte) (bit mask)
!addr EN018B_MASK = %00000001  ; DMA enable F018B mode (adds sub-command byte) (bit mask)
!addr DMA_ADDRMB = $D704  ; DMA list address mega-byte
!addr ADDRMB = $D704  ; DMA list address mega-byte
!addr DMA_ETRIG = $D705  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list address specified as 28-bit flat address (uses DMA option list)
!addr ETRIG = $D705  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list address specified as 28-bit flat address (uses DMA option list)
!addr DMA_ETRIGMAPD = $D706  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list in current CPU memory map (uses DMA option list)
!addr ETRIGMAPD = $D706  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list in current CPU memory map (uses DMA option list)
!addr DMA_ADDRLSB = $D70E  ; DMA list address low byte (address bits 0 -- 7) WITHOUT STARTING A DMA JOB (used by Hypervisor for unfreezing DMA-using tasks)
!addr ADDRLSB = $D70E  ; DMA list address low byte (address bits 0 -- 7) WITHOUT STARTING A DMA JOB (used by Hypervisor for unfreezing DMA-using tasks)
!addr MATH_MULBUSY_ADDR = $D70F  ; Set if hardware multiplier is busy (address)
!addr MULBUSY_ADDR = $D70F  ; Set if hardware multiplier is busy (address)
MATH_MULBUSY_MASK = %01000000  ; Set if hardware multiplier is busy (bit mask)
!addr MULBUSY_MASK = %01000000  ; Set if hardware multiplier is busy (bit mask)
!addr MATH_DIVBUSY_ADDR = $D70F  ; Set if hardware divider is busy (address)
!addr DIVBUSY_ADDR = $D70F  ; Set if hardware divider is busy (address)
MATH_DIVBUSY_MASK = %10000000  ; Set if hardware divider is busy (bit mask)
!addr DIVBUSY_MASK = %10000000  ; Set if hardware divider is busy (bit mask)
!addr CPU_BADLEN_ADDR = $D710  ; Enable badline emulation (address)
!addr BADLEN_ADDR = $D710  ; Enable badline emulation (address)
CPU_BADLEN_MASK = %00000001  ; Enable badline emulation (bit mask)
!addr BADLEN_MASK = %00000001  ; Enable badline emulation (bit mask)
!addr CPU_SLIEN_ADDR = $D710  ; Enable 6502-style slow (7 cycle) interrupts (address)
!addr SLIEN_ADDR = $D710  ; Enable 6502-style slow (7 cycle) interrupts (address)
CPU_SLIEN_MASK = %00000010  ; Enable 6502-style slow (7 cycle) interrupts (bit mask)
!addr SLIEN_MASK = %00000010  ; Enable 6502-style slow (7 cycle) interrupts (bit mask)
!addr MISC_VDCSEN_ADDR = $D710  ; Enable VDC inteface simulation (address)
!addr VDCSEN_ADDR = $D710  ; Enable VDC inteface simulation (address)
MISC_VDCSEN_MASK = %00000100  ; Enable VDC inteface simulation (bit mask)
!addr VDCSEN_MASK = %00000100  ; Enable VDC inteface simulation (bit mask)
!addr CPU_BRCOST_ADDR = $D710  ; 1=charge extra cycle(s) for branches taken (address)
!addr BRCOST_ADDR = $D710  ; 1=charge extra cycle(s) for branches taken (address)
CPU_BRCOST_MASK = %00001000  ; 1=charge extra cycle(s) for branches taken (bit mask)
!addr BRCOST_MASK = %00001000  ; 1=charge extra cycle(s) for branches taken (bit mask)
!addr CPU_BADEXTRA_ADDR = $D710  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (address)
!addr BADEXTRA_ADDR = $D710  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (address)
CPU_BADEXTRA_MASK = %00110000  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (bit mask)
!addr BADEXTRA_MASK = %00110000  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (bit mask)
!addr DMA_AUD_BLKTO_ADDR = $D711  ; Audio DMA block timeout (read only) DEBUG (address)
!addr AUD_BLKTO_ADDR = $D711  ; Audio DMA block timeout (read only) DEBUG (address)
DMA_AUD_BLKTO_MASK = %00000111  ; Audio DMA block timeout (read only) DEBUG (bit mask)
!addr AUD_BLKTO_MASK = %00000111  ; Audio DMA block timeout (read only) DEBUG (bit mask)
!addr AUDIO_PWMPDM_ADDR = $D711  ; PWM/PDM audio encoding select (address)
!addr PWMPDM_ADDR = $D711  ; PWM/PDM audio encoding select (address)
AUDIO_PWMPDM_MASK = %00001000  ; PWM/PDM audio encoding select (bit mask)
!addr PWMPDM_MASK = %00001000  ; PWM/PDM audio encoding select (bit mask)
!addr DMA_NOMIX_ADDR = $D711  ; Audio DMA bypasses audio mixer (address)
!addr NOMIX_ADDR = $D711  ; Audio DMA bypasses audio mixer (address)
DMA_NOMIX_MASK = %00010000  ; Audio DMA bypasses audio mixer (bit mask)
!addr NOMIX_MASK = %00010000  ; Audio DMA bypasses audio mixer (bit mask)
!addr DMA_AUD_WRBLK_ADDR = $D711  ; Audio DMA block writes (samples still get read) (address)
!addr AUD_WRBLK_ADDR = $D711  ; Audio DMA block writes (samples still get read) (address)
DMA_AUD_WRBLK_MASK = %00100000  ; Audio DMA block writes (samples still get read) (bit mask)
!addr AUD_WRBLK_MASK = %00100000  ; Audio DMA block writes (samples still get read) (bit mask)
!addr DMA_BLKD_ADDR = $D711  ; Audio DMA blocked (read only) DEBUG (address)
!addr BLKD_ADDR = $D711  ; Audio DMA blocked (read only) DEBUG (address)
DMA_BLKD_MASK = %01000000  ; Audio DMA blocked (read only) DEBUG (bit mask)
!addr BLKD_MASK = %01000000  ; Audio DMA blocked (read only) DEBUG (bit mask)
!addr DMA_AUDEN_ADDR = $D711  ; Enable Audio DMA (address)
!addr AUDEN_ADDR = $D711  ; Enable Audio DMA (address)
DMA_AUDEN_MASK = %10000000  ; Enable Audio DMA (bit mask)
!addr AUDEN_MASK = %10000000  ; Enable Audio DMA (bit mask)
!addr DMA_CH0RVOL = $D71C  ; Audio DMA channel 0 right channel volume
!addr CH0RVOL = $D71C  ; Audio DMA channel 0 right channel volume
!addr DMA_CH1RVOL = $D71D  ; Audio DMA channel 1 right channel volume
!addr CH1RVOL = $D71D  ; Audio DMA channel 1 right channel volume
!addr DMA_CH2LVOL = $D71E  ; Audio DMA channel 2 left channel volume
!addr CH2LVOL = $D71E  ; Audio DMA channel 2 left channel volume
!addr DMA_CH3LVOL = $D71F  ; Audio DMA channel 3 left channel volume
!addr CH3LVOL = $D71F  ; Audio DMA channel 3 left channel volume
!addr DMA_CH0_SBITS_ADDR = $D720  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (address)
!addr CH0_SBITS_ADDR = $D720  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (address)
DMA_CH0_SBITS_MASK = %00000011  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (bit mask)
!addr CH0_SBITS_MASK = %00000011  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (bit mask)
!addr DMA_CH0_STP_ADDR = $D720  ; Audio DMA channel X stop flag (address)
!addr CH0_STP_ADDR = $D720  ; Audio DMA channel X stop flag (address)
DMA_CH0_STP_MASK = %00001000  ; Audio DMA channel X stop flag (bit mask)
!addr CH0_STP_MASK = %00001000  ; Audio DMA channel X stop flag (bit mask)
!addr DMA_CH0_SINE_ADDR = $D720  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (address)
!addr CH0_SINE_ADDR = $D720  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (address)
DMA_CH0_SINE_MASK = %00010000  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (bit mask)
!addr CH0_SINE_MASK = %00010000  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (bit mask)
!addr DMA_CH0_SGN_ADDR = $D720  ; Enable Audio DMA channel X signed samples (address)
!addr CH0_SGN_ADDR = $D720  ; Enable Audio DMA channel X signed samples (address)
DMA_CH0_SGN_MASK = %00100000  ; Enable Audio DMA channel X signed samples (bit mask)
!addr CH0_SGN_MASK = %00100000  ; Enable Audio DMA channel X signed samples (bit mask)
!addr DMA_CH0_LOOP_ADDR = $D720  ; Enable Audio DMA channel X looping (address)
!addr CH0_LOOP_ADDR = $D720  ; Enable Audio DMA channel X looping (address)
DMA_CH0_LOOP_MASK = %01000000  ; Enable Audio DMA channel X looping (bit mask)
!addr CH0_LOOP_MASK = %01000000  ; Enable Audio DMA channel X looping (bit mask)
!addr DMA_CH0_EN_ADDR = $D720  ; Enable Audio DMA channel X (address)
!addr CH0_EN_ADDR = $D720  ; Enable Audio DMA channel X (address)
DMA_CH0_EN_MASK = %10000000  ; Enable Audio DMA channel X (bit mask)
!addr CH0_EN_MASK = %10000000  ; Enable Audio DMA channel X (bit mask)
!addr DMA_CH0BADDRL = $D721  ; Audio DMA channel X base address LSB
!addr CH0BADDRL = $D721  ; Audio DMA channel X base address LSB
!addr DMA_CH0BADDRC = $D722  ; Audio DMA channel X base address middle byte
!addr CH0BADDRC = $D722  ; Audio DMA channel X base address middle byte
!addr DMA_CH0BADDRM = $D723  ; Audio DMA channel X base address MSB
!addr CH0BADDRM = $D723  ; Audio DMA channel X base address MSB
!addr DMA_CH0FREQL = $D724  ; Audio DMA channel X frequency LSB
!addr CH0FREQL = $D724  ; Audio DMA channel X frequency LSB
!addr DMA_CH0FREQC = $D725  ; Audio DMA channel X frequency middle byte
!addr CH0FREQC = $D725  ; Audio DMA channel X frequency middle byte
!addr DMA_CH0FREQM = $D726  ; Audio DMA channel X frequency MSB
!addr CH0FREQM = $D726  ; Audio DMA channel X frequency MSB
!addr DMA_CH0TADDRL = $D727  ; Audio DMA channel X top address LSB
!addr CH0TADDRL = $D727  ; Audio DMA channel X top address LSB
!addr DMA_CH0TADDRM = $D728  ; Audio DMA channel X top address MSB
!addr CH0TADDRM = $D728  ; Audio DMA channel X top address MSB
!addr DMA_CH0VOLUME = $D729  ; Audio DMA channel X playback volume
!addr CH0VOLUME = $D729  ; Audio DMA channel X playback volume
!addr DMA_CH0CURADDRL = $D72A  ; Audio DMA channel X current address LSB
!addr CH0CURADDRL = $D72A  ; Audio DMA channel X current address LSB
!addr DMA_CH0CURADDRC = $D72B  ; Audio DMA channel X current address middle byte
!addr CH0CURADDRC = $D72B  ; Audio DMA channel X current address middle byte
!addr DMA_CH0CURADDRM = $D72C  ; Audio DMA channel X current address MSB
!addr CH0CURADDRM = $D72C  ; Audio DMA channel X current address MSB
!addr DMA_CH0TMRADDRL = $D72D  ; Audio DMA channel X timing counter LSB
!addr CH0TMRADDRL = $D72D  ; Audio DMA channel X timing counter LSB
!addr DMA_CH0TMRADDRC = $D72E  ; Audio DMA channel X timing counter middle byte
!addr CH0TMRADDRC = $D72E  ; Audio DMA channel X timing counter middle byte
!addr DMA_CH0TMRADDRM = $D72F  ; Audio DMA channel X timing counter MSB
!addr CH0TMRADDRM = $D72F  ; Audio DMA channel X timing counter MSB
!addr DMA_CH1_SBITS_ADDR = $D730  ; @CHXSBITS (address)
!addr CH1_SBITS_ADDR = $D730  ; @CHXSBITS (address)
DMA_CH1_SBITS_MASK = %00000011  ; @CHXSBITS (bit mask)
!addr CH1_SBITS_MASK = %00000011  ; @CHXSBITS (bit mask)
!addr DMA_CH1_STP_ADDR = $D730  ; @CHXSTP (address)
!addr CH1_STP_ADDR = $D730  ; @CHXSTP (address)
DMA_CH1_STP_MASK = %00001000  ; @CHXSTP (bit mask)
!addr CH1_STP_MASK = %00001000  ; @CHXSTP (bit mask)
!addr DMA_CH1_SINE_ADDR = $D730  ; @CHXSINE (address)
!addr CH1_SINE_ADDR = $D730  ; @CHXSINE (address)
DMA_CH1_SINE_MASK = %00010000  ; @CHXSINE (bit mask)
!addr CH1_SINE_MASK = %00010000  ; @CHXSINE (bit mask)
!addr DMA_CH1_SGN_ADDR = $D730  ; @CHXSGN (address)
!addr CH1_SGN_ADDR = $D730  ; @CHXSGN (address)
DMA_CH1_SGN_MASK = %00100000  ; @CHXSGN (bit mask)
!addr CH1_SGN_MASK = %00100000  ; @CHXSGN (bit mask)
!addr DMA_CH1_LOOP_ADDR = $D730  ; @CHXLOOP (address)
!addr CH1_LOOP_ADDR = $D730  ; @CHXLOOP (address)
DMA_CH1_LOOP_MASK = %01000000  ; @CHXLOOP (bit mask)
!addr CH1_LOOP_MASK = %01000000  ; @CHXLOOP (bit mask)
!addr DMA_CH1_EN_ADDR = $D730  ; @CHXEN (address)
!addr CH1_EN_ADDR = $D730  ; @CHXEN (address)
DMA_CH1_EN_MASK = %10000000  ; @CHXEN (bit mask)
!addr CH1_EN_MASK = %10000000  ; @CHXEN (bit mask)
!addr DMA_CH1BADDRL = $D731  ; @CHXBADDRL
!addr CH1BADDRL = $D731  ; @CHXBADDRL
!addr DMA_CH1BADDRC = $D732  ; @CHXBADDRC
!addr CH1BADDRC = $D732  ; @CHXBADDRC
!addr DMA_CH1BADDRM = $D733  ; @CHXBADDRM
!addr CH1BADDRM = $D733  ; @CHXBADDRM
!addr DMA_CH1FREQL = $D734  ; @CHXFREQL
!addr CH1FREQL = $D734  ; @CHXFREQL
!addr DMA_CH1FREQC = $D735  ; @CHXFREQC
!addr CH1FREQC = $D735  ; @CHXFREQC
!addr DMA_CH1FREQM = $D736  ; @CHXFREQM
!addr CH1FREQM = $D736  ; @CHXFREQM
!addr DMA_CH1TADDRL = $D737  ; @CHXTADDRL
!addr CH1TADDRL = $D737  ; @CHXTADDRL
!addr DMA_CH1TADDRM = $D738  ; @CHXTADDRM
!addr CH1TADDRM = $D738  ; @CHXTADDRM
!addr DMA_CH1VOLUME = $D739  ; @CHXVOLUME
!addr CH1VOLUME = $D739  ; @CHXVOLUME
!addr DMA_CH1CURADDRL = $D73A  ; @CHXCURADDRL
!addr CH1CURADDRL = $D73A  ; @CHXCURADDRL
!addr DMA_CH1CURADDRC = $D73B  ; @CHXCURADDRC
!addr CH1CURADDRC = $D73B  ; @CHXCURADDRC
!addr DMA_CH1CURADDRM = $D73C  ; @CHXCURADDRM
!addr CH1CURADDRM = $D73C  ; @CHXCURADDRM
!addr DMA_CH1TMRADDRL = $D73D  ; @CHXTMRADDRL
!addr CH1TMRADDRL = $D73D  ; @CHXTMRADDRL
!addr DMA_CH1TMRADDRC = $D73E  ; @CHXTMRADDRC
!addr CH1TMRADDRC = $D73E  ; @CHXTMRADDRC
!addr DMA_CH1TMRADDRM = $D73F  ; @CHXTMRADDRM
!addr CH1TMRADDRM = $D73F  ; @CHXTMRADDRM
!addr DMA_CH2_SBITS_ADDR = $D740  ; @CHXSBITS (address)
!addr CH2_SBITS_ADDR = $D740  ; @CHXSBITS (address)
DMA_CH2_SBITS_MASK = %00000011  ; @CHXSBITS (bit mask)
!addr CH2_SBITS_MASK = %00000011  ; @CHXSBITS (bit mask)
!addr DMA_CH2_STP_ADDR = $D740  ; @CHXSTP (address)
!addr CH2_STP_ADDR = $D740  ; @CHXSTP (address)
DMA_CH2_STP_MASK = %00001000  ; @CHXSTP (bit mask)
!addr CH2_STP_MASK = %00001000  ; @CHXSTP (bit mask)
!addr DMA_CH2_SINE_ADDR = $D740  ; @CHXSINE (address)
!addr CH2_SINE_ADDR = $D740  ; @CHXSINE (address)
DMA_CH2_SINE_MASK = %00010000  ; @CHXSINE (bit mask)
!addr CH2_SINE_MASK = %00010000  ; @CHXSINE (bit mask)
!addr DMA_CH2_SGN_ADDR = $D740  ; @CHXSGN (address)
!addr CH2_SGN_ADDR = $D740  ; @CHXSGN (address)
DMA_CH2_SGN_MASK = %00100000  ; @CHXSGN (bit mask)
!addr CH2_SGN_MASK = %00100000  ; @CHXSGN (bit mask)
!addr DMA_CH2_LOOP_ADDR = $D740  ; @CHXLOOP (address)
!addr CH2_LOOP_ADDR = $D740  ; @CHXLOOP (address)
DMA_CH2_LOOP_MASK = %01000000  ; @CHXLOOP (bit mask)
!addr CH2_LOOP_MASK = %01000000  ; @CHXLOOP (bit mask)
!addr DMA_CH2_EN_ADDR = $D740  ; @CHXEN (address)
!addr CH2_EN_ADDR = $D740  ; @CHXEN (address)
DMA_CH2_EN_MASK = %10000000  ; @CHXEN (bit mask)
!addr CH2_EN_MASK = %10000000  ; @CHXEN (bit mask)
!addr DMA_CH2BADDRL = $D741  ; @CHXBADDRL
!addr CH2BADDRL = $D741  ; @CHXBADDRL
!addr DMA_CH2BADDRC = $D742  ; @CHXBADDRC
!addr CH2BADDRC = $D742  ; @CHXBADDRC
!addr DMA_CH2BADDRM = $D743  ; @CHXBADDRM
!addr CH2BADDRM = $D743  ; @CHXBADDRM
!addr DMA_CH2FREQL = $D744  ; @CHXFREQL
!addr CH2FREQL = $D744  ; @CHXFREQL
!addr DMA_CH2FREQC = $D745  ; @CHXFREQC
!addr CH2FREQC = $D745  ; @CHXFREQC
!addr DMA_CH2FREQM = $D746  ; @CHXFREQM
!addr CH2FREQM = $D746  ; @CHXFREQM
!addr DMA_CH2TADDRL = $D747  ; @CHXTADDRL
!addr CH2TADDRL = $D747  ; @CHXTADDRL
!addr DMA_CH2TADDRM = $D748  ; @CHXTADDRM
!addr CH2TADDRM = $D748  ; @CHXTADDRM
!addr DMA_CH2VOLUME = $D749  ; @CHXVOLUME
!addr CH2VOLUME = $D749  ; @CHXVOLUME
!addr DMA_CH2CURADDRL = $D74A  ; @CHXCURADDRL
!addr CH2CURADDRL = $D74A  ; @CHXCURADDRL
!addr DMA_CH2CURADDRC = $D74B  ; @CHXCURADDRC
!addr CH2CURADDRC = $D74B  ; @CHXCURADDRC
!addr DMA_CH2CURADDRM = $D74C  ; @CHXCURADDRM
!addr CH2CURADDRM = $D74C  ; @CHXCURADDRM
!addr DMA_CH2TMRADDRL = $D74D  ; @CHXTMRADDRL
!addr CH2TMRADDRL = $D74D  ; @CHXTMRADDRL
!addr DMA_CH2TMRADDRC = $D74E  ; @CHXTMRADDRC
!addr CH2TMRADDRC = $D74E  ; @CHXTMRADDRC
!addr DMA_CH2TMRADDRM = $D74F  ; @CHXTMRADDRM
!addr CH2TMRADDRM = $D74F  ; @CHXTMRADDRM
!addr DMA_CH3_SBITS_ADDR = $D750  ; @CHXSBITS (address)
!addr CH3_SBITS_ADDR = $D750  ; @CHXSBITS (address)
DMA_CH3_SBITS_MASK = %00000011  ; @CHXSBITS (bit mask)
!addr CH3_SBITS_MASK = %00000011  ; @CHXSBITS (bit mask)
!addr DMA_CH3_STP_ADDR = $D750  ; @CHXSTP (address)
!addr CH3_STP_ADDR = $D750  ; @CHXSTP (address)
DMA_CH3_STP_MASK = %00001000  ; @CHXSTP (bit mask)
!addr CH3_STP_MASK = %00001000  ; @CHXSTP (bit mask)
!addr DMA_CH3_SINE_ADDR = $D750  ; @CHXSINE (address)
!addr CH3_SINE_ADDR = $D750  ; @CHXSINE (address)
DMA_CH3_SINE_MASK = %00010000  ; @CHXSINE (bit mask)
!addr CH3_SINE_MASK = %00010000  ; @CHXSINE (bit mask)
!addr DMA_CH3_SGN_ADDR = $D750  ; @CHXSGN (address)
!addr CH3_SGN_ADDR = $D750  ; @CHXSGN (address)
DMA_CH3_SGN_MASK = %00100000  ; @CHXSGN (bit mask)
!addr CH3_SGN_MASK = %00100000  ; @CHXSGN (bit mask)
!addr DMA_CH3_LOOP_ADDR = $D750  ; @CHXLOOP (address)
!addr CH3_LOOP_ADDR = $D750  ; @CHXLOOP (address)
DMA_CH3_LOOP_MASK = %01000000  ; @CHXLOOP (bit mask)
!addr CH3_LOOP_MASK = %01000000  ; @CHXLOOP (bit mask)
!addr DMA_CH3_EN_ADDR = $D750  ; @CHXEN (address)
!addr CH3_EN_ADDR = $D750  ; @CHXEN (address)
DMA_CH3_EN_MASK = %10000000  ; @CHXEN (bit mask)
!addr CH3_EN_MASK = %10000000  ; @CHXEN (bit mask)
!addr DMA_CH3BADDRL = $D751  ; @CHXBADDRL
!addr CH3BADDRL = $D751  ; @CHXBADDRL
!addr DMA_CH3BADDRC = $D752  ; @CHXBADDRC
!addr CH3BADDRC = $D752  ; @CHXBADDRC
!addr DMA_CH3BADDRM = $D753  ; @CHXBADDRM
!addr CH3BADDRM = $D753  ; @CHXBADDRM
!addr DMA_CH3FREQL = $D754  ; @CHXFREQL
!addr CH3FREQL = $D754  ; @CHXFREQL
!addr DMA_CH3FREQC = $D755  ; @CHXFREQC
!addr CH3FREQC = $D755  ; @CHXFREQC
!addr DMA_CH3FREQM = $D756  ; @CHXFREQM
!addr CH3FREQM = $D756  ; @CHXFREQM
!addr DMA_CH3TADDRL = $D757  ; @CHXTADDRL
!addr CH3TADDRL = $D757  ; @CHXTADDRL
!addr DMA_CH3TADDRM = $D758  ; @CHXTADDRM
!addr CH3TADDRM = $D758  ; @CHXTADDRM
!addr DMA_CH3VOLUME = $D759  ; @CHXVOLUME
!addr CH3VOLUME = $D759  ; @CHXVOLUME
!addr DMA_CH3CURADDRL = $D75A  ; @CHXCURADDRL
!addr CH3CURADDRL = $D75A  ; @CHXCURADDRL
!addr DMA_CH3CURADDRC = $D75B  ; @CHXCURADDRC
!addr CH3CURADDRC = $D75B  ; @CHXCURADDRC
!addr DMA_CH3CURADDRM = $D75C  ; @CHXCURADDRM
!addr CH3CURADDRM = $D75C  ; @CHXCURADDRM
!addr DMA_CH3TMRADDRL = $D75D  ; @CHXTMRADDRL
!addr CH3TMRADDRL = $D75D  ; @CHXTMRADDRL
!addr DMA_CH3TMRADDRC = $D75E  ; @CHXTMRADDRC
!addr CH3TMRADDRC = $D75E  ; @CHXTMRADDRC
!addr DMA_CH3TMRADDRM = $D75F  ; @CHXTMRADDRM
!addr CH3TMRADDRM = $D75F  ; @CHXTMRADDRM
!addr MATH_DIVOUT = $D768  ; 64-bit output of MULTINA $\div$ MULTINB
!addr GS_MATH_DIVOUT = $D769  ; 64-bit output of MULTINA $\div$ MULTINB
!addr GS_MATH_DIVOUT_2 = $D76A  ; 64-bit output of MULTINA $\div$ MULTINB
!addr GS_MATH_DIVOUT_3 = $D76B  ; 64-bit output of MULTINA $\div$ MULTINB
!addr GS_MATH_DIVOUT_4 = $D76C  ; 64-bit output of MULTINA $\div$ MULTINB
!addr GS_MATH_DIVOUT_5 = $D76D  ; 64-bit output of MULTINA $\div$ MULTINB
!addr GS_MATH_DIVOUT_6 = $D76E  ; 64-bit output of MULTINA $\div$ MULTINB
!addr GS_MATH_DIVOUT_7 = $D76F  ; 64-bit output of MULTINA $\div$ MULTINB
!addr MATH_MULTINA = $D770  ; Multiplier input A / Divider numerator (32 bit)
!addr GS_MATH_MULTINA = $D771  ; Multiplier input A / Divider numerator (32 bit)
!addr GS_MATH_MULTINA_2 = $D772  ; Multiplier input A / Divider numerator (32 bit)
!addr GS_MATH_MULTINA_3 = $D773  ; Multiplier input A / Divider numerator (32 bit)
!addr MATH_MULTINB = $D774  ; Multiplier input B / Divider denominator (32 bit)
!addr GS_MATH_MULTINB = $D775  ; Multiplier input B / Divider denominator (32 bit)
!addr GS_MATH_MULTINB_2 = $D776  ; Multiplier input B / Divider denominator (32 bit)
!addr GS_MATH_MULTINB_3 = $D777  ; Multiplier input B / Divider denominator (32 bit)
!addr MATH_MULTOUT = $D778  ; 64-bit output of MULTINA $\times$ MULTINB
!addr GS_MATH_MULTOUT = $D779  ; 64-bit output of MULTINA $\times$ MULTINB
!addr GS_MATH_MULTOUT_2 = $D77A  ; 64-bit output of MULTINA $\times$ MULTINB
!addr GS_MATH_MULTOUT_3 = $D77B  ; 64-bit output of MULTINA $\times$ MULTINB
!addr GS_MATH_MULTOUT_4 = $D77C  ; 64-bit output of MULTINA $\times$ MULTINB
!addr GS_MATH_MULTOUT_5 = $D77D  ; 64-bit output of MULTINA $\times$ MULTINB
!addr GS_MATH_MULTOUT_6 = $D77E  ; 64-bit output of MULTINA $\times$ MULTINB
!addr GS_MATH_MULTOUT_7 = $D77F  ; 64-bit output of MULTINA $\times$ MULTINB
!addr MATH_MATHIN0 = $D780  ; Math unit 32-bit input X
!addr GS_MATH_MATHIN0 = $D781  ; @MATHINX
!addr GS_MATH_MATHIN0_2 = $D782  ; @MATHINX
!addr GS_MATH_MATHIN0_3 = $D783  ; @MATHINX
!addr MATH_MATHIN1 = $D784  ; @MATHINX
!addr GS_MATH_MATHIN1 = $D785  ; @MATHINX
!addr GS_MATH_MATHIN1_2 = $D786  ; @MATHINX
!addr GS_MATH_MATHIN1_3 = $D787  ; @MATHINX
!addr MATH_MATHIN2 = $D788  ; @MATHINX
!addr GS_MATH_MATHIN2 = $D789  ; @MATHINX
!addr GS_MATH_MATHIN2_2 = $D78A  ; @MATHINX
!addr GS_MATH_MATHIN2_3 = $D78B  ; @MATHINX
!addr MATH_MATHIN3 = $D78C  ; @MATHINX
!addr GS_MATH_MATHIN3 = $D78D  ; @MATHINX
!addr GS_MATH_MATHIN3_2 = $D78E  ; @MATHINX
!addr GS_MATH_MATHIN3_3 = $D78F  ; @MATHINX
!addr MATH_MATHIN4 = $D790  ; @MATHINX
!addr GS_MATH_MATHIN4 = $D791  ; @MATHINX
!addr GS_MATH_MATHIN4_2 = $D792  ; @MATHINX
!addr GS_MATH_MATHIN4_3 = $D793  ; @MATHINX
!addr MATH_MATHIN5 = $D794  ; @MATHINX
!addr GS_MATH_MATHIN5 = $D795  ; @MATHINX
!addr GS_MATH_MATHIN5_2 = $D796  ; @MATHINX
!addr GS_MATH_MATHIN5_3 = $D797  ; @MATHINX
!addr MATH_MATHIN6 = $D798  ; @MATHINX
!addr GS_MATH_MATHIN6 = $D799  ; @MATHINX
!addr GS_MATH_MATHIN6_2 = $D79A  ; @MATHINX
!addr GS_MATH_MATHIN6_3 = $D79B  ; @MATHINX
!addr MATH_MATHIN7 = $D79C  ; @MATHINX
!addr GS_MATH_MATHIN7 = $D79D  ; @MATHINX
!addr GS_MATH_MATHIN7_2 = $D79E  ; @MATHINX
!addr GS_MATH_MATHIN7_3 = $D79F  ; @MATHINX
!addr MATH_MATHIN8 = $D7A0  ; @MATHINX
!addr GS_MATH_MATHIN8 = $D7A1  ; @MATHINX
!addr GS_MATH_MATHIN8_2 = $D7A2  ; @MATHINX
!addr GS_MATH_MATHIN8_3 = $D7A3  ; @MATHINX
!addr MATH_MATHIN9 = $D7A4  ; @MATHINX
!addr GS_MATH_MATHIN9 = $D7A5  ; @MATHINX
!addr GS_MATH_MATHIN9_2 = $D7A6  ; @MATHINX
!addr GS_MATH_MATHIN9_3 = $D7A7  ; @MATHINX
!addr MATH_MATHINA = $D7A8  ; @MATHINX
!addr GS_MATH_MATHINA = $D7A9  ; @MATHINX
!addr GS_MATH_MATHINA_2 = $D7AA  ; @MATHINX
!addr GS_MATH_MATHINA_3 = $D7AB  ; @MATHINX
!addr MATH_MATHINB = $D7AC  ; @MATHINX
!addr GS_MATH_MATHINB = $D7AD  ; @MATHINX
!addr GS_MATH_MATHINB_2 = $D7AE  ; @MATHINX
!addr GS_MATH_MATHINB_3 = $D7AF  ; @MATHINX
!addr MATH_MATHINC = $D7B0  ; @MATHINX
!addr GS_MATH_MATHINC = $D7B1  ; @MATHINX
!addr GS_MATH_MATHINC_2 = $D7B2  ; @MATHINX
!addr GS_MATH_MATHINC_3 = $D7B3  ; @MATHINX
!addr MATH_MATHIND = $D7B4  ; @MATHINX
!addr GS_MATH_MATHIND = $D7B5  ; @MATHINX
!addr GS_MATH_MATHIND_2 = $D7B6  ; @MATHINX
!addr GS_MATH_MATHIND_3 = $D7B7  ; @MATHINX
!addr MATH_MATHINE = $D7B8  ; @MATHINX
!addr GS_MATH_MATHINE = $D7B9  ; @MATHINX
!addr GS_MATH_MATHINE_2 = $D7BA  ; @MATHINX
!addr GS_MATH_MATHINE_3 = $D7BB  ; @MATHINX
!addr MATH_MATHINF = $D7BC  ; @MATHINX
!addr GS_MATH_MATHINF = $D7BD  ; @MATHINX
!addr GS_MATH_MATHINF_2 = $D7BE  ; @MATHINX
!addr GS_MATH_MATHINF_3 = $D7BF  ; @MATHINX
!addr MATH_UNIT0INA_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (address)
!addr UNIT0INA_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (address)
MATH_UNIT0INA_MASK = %00001111  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (bit mask)
!addr UNIT0INA_MASK = %00001111  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (bit mask)
!addr MATH_UNIT0INB_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (address)
!addr UNIT0INB_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (address)
MATH_UNIT0INB_MASK = %11110000  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (bit mask)
!addr UNIT0INB_MASK = %11110000  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (bit mask)
!addr MATH_UNIT1INA_ADDR = $D7C1  ; @UNITXINA (address)
!addr UNIT1INA_ADDR = $D7C1  ; @UNITXINA (address)
MATH_UNIT1INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT1INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT1INB_ADDR = $D7C1  ; @UNITXINB (address)
!addr UNIT1INB_ADDR = $D7C1  ; @UNITXINB (address)
MATH_UNIT1INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT1INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT2INA_ADDR = $D7C2  ; @UNITXINA (address)
!addr UNIT2INA_ADDR = $D7C2  ; @UNITXINA (address)
MATH_UNIT2INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT2INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT2INB_ADDR = $D7C2  ; @UNITXINB (address)
!addr UNIT2INB_ADDR = $D7C2  ; @UNITXINB (address)
MATH_UNIT2INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT2INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT3INA_ADDR = $D7C3  ; @UNITXINA (address)
!addr UNIT3INA_ADDR = $D7C3  ; @UNITXINA (address)
MATH_UNIT3INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT3INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT3INB_ADDR = $D7C3  ; @UNITXINB (address)
!addr UNIT3INB_ADDR = $D7C3  ; @UNITXINB (address)
MATH_UNIT3INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT3INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT4INA_ADDR = $D7C4  ; @UNITXINA (address)
!addr UNIT4INA_ADDR = $D7C4  ; @UNITXINA (address)
MATH_UNIT4INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT4INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT4INB_ADDR = $D7C4  ; @UNITXINB (address)
!addr UNIT4INB_ADDR = $D7C4  ; @UNITXINB (address)
MATH_UNIT4INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT4INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT5INA_ADDR = $D7C5  ; @UNITXINA (address)
!addr UNIT5INA_ADDR = $D7C5  ; @UNITXINA (address)
MATH_UNIT5INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT5INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT5INB_ADDR = $D7C5  ; @UNITXINB (address)
!addr UNIT5INB_ADDR = $D7C5  ; @UNITXINB (address)
MATH_UNIT5INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT5INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT6INA_ADDR = $D7C6  ; @UNITXINA (address)
!addr UNIT6INA_ADDR = $D7C6  ; @UNITXINA (address)
MATH_UNIT6INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT6INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT6INB_ADDR = $D7C6  ; @UNITXINB (address)
!addr UNIT6INB_ADDR = $D7C6  ; @UNITXINB (address)
MATH_UNIT6INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT6INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT7INA_ADDR = $D7C7  ; @UNITXINA (address)
!addr UNIT7INA_ADDR = $D7C7  ; @UNITXINA (address)
MATH_UNIT7INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT7INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT7INB_ADDR = $D7C7  ; @UNITXINB (address)
!addr UNIT7INB_ADDR = $D7C7  ; @UNITXINB (address)
MATH_UNIT7INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT7INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT8INA_ADDR = $D7C8  ; @UNITXINA (address)
!addr UNIT8INA_ADDR = $D7C8  ; @UNITXINA (address)
MATH_UNIT8INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT8INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT8INB_ADDR = $D7C8  ; @UNITXINB (address)
!addr UNIT8INB_ADDR = $D7C8  ; @UNITXINB (address)
MATH_UNIT8INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT8INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT9INA_ADDR = $D7C9  ; @UNITXINA (address)
!addr UNIT9INA_ADDR = $D7C9  ; @UNITXINA (address)
MATH_UNIT9INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNIT9INA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNIT9INB_ADDR = $D7C9  ; @UNITXINB (address)
!addr UNIT9INB_ADDR = $D7C9  ; @UNITXINB (address)
MATH_UNIT9INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNIT9INB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNITAINA_ADDR = $D7CA  ; @UNITXINA (address)
!addr UNITAINA_ADDR = $D7CA  ; @UNITXINA (address)
MATH_UNITAINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNITAINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNITAINB_ADDR = $D7CA  ; @UNITXINB (address)
!addr UNITAINB_ADDR = $D7CA  ; @UNITXINB (address)
MATH_UNITAINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNITAINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNITBINA_ADDR = $D7CB  ; @UNITXINA (address)
!addr UNITBINA_ADDR = $D7CB  ; @UNITXINA (address)
MATH_UNITBINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNITBINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNITBINB_ADDR = $D7CB  ; @UNITXINB (address)
!addr UNITBINB_ADDR = $D7CB  ; @UNITXINB (address)
MATH_UNITBINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNITBINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNITCINA_ADDR = $D7CC  ; @UNITXINA (address)
!addr UNITCINA_ADDR = $D7CC  ; @UNITXINA (address)
MATH_UNITCINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNITCINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNITCINB_ADDR = $D7CC  ; @UNITXINB (address)
!addr UNITCINB_ADDR = $D7CC  ; @UNITXINB (address)
MATH_UNITCINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNITCINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNITDINA_ADDR = $D7CD  ; @UNITXINA (address)
!addr UNITDINA_ADDR = $D7CD  ; @UNITXINA (address)
MATH_UNITDINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNITDINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNITDINB_ADDR = $D7CD  ; @UNITXINB (address)
!addr UNITDINB_ADDR = $D7CD  ; @UNITXINB (address)
MATH_UNITDINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNITDINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNITEINA_ADDR = $D7CE  ; @UNITXINA (address)
!addr UNITEINA_ADDR = $D7CE  ; @UNITXINA (address)
MATH_UNITEINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNITEINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNITEINB_ADDR = $D7CE  ; @UNITXINB (address)
!addr UNITEINB_ADDR = $D7CE  ; @UNITXINB (address)
MATH_UNITEINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNITEINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNITFINA_ADDR = $D7CF  ; @UNITXINA (address)
!addr UNITFINA_ADDR = $D7CF  ; @UNITXINA (address)
MATH_UNITFINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr UNITFINA_MASK = %00001111  ; @UNITXINA (bit mask)
!addr MATH_UNITFINB_ADDR = $D7CF  ; @UNITXINB (address)
!addr UNITFINB_ADDR = $D7CF  ; @UNITXINB (address)
MATH_UNITFINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr UNITFINB_MASK = %11110000  ; @UNITXINB (bit mask)
!addr MATH_UNIT0OUT_ADDR = $D7D0  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (address)
!addr UNIT0OUT_ADDR = $D7D0  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (address)
MATH_UNIT0OUT_MASK = %00001111  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (bit mask)
!addr UNIT0OUT_MASK = %00001111  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (bit mask)
!addr MATH_U0_LOWOUT_ADDR = $D7D0  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
!addr U0_LOWOUT_ADDR = $D7D0  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
MATH_U0_LOWOUT_MASK = %00010000  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
!addr U0_LOWOUT_MASK = %00010000  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
!addr MATH_U0_HIOUT_ADDR = $D7D0  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
!addr U0_HIOUT_ADDR = $D7D0  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
MATH_U0_HIOUT_MASK = %00100000  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
!addr U0_HIOUT_MASK = %00100000  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
!addr MATH_U0_MLADD_ADDR = $D7D0  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (address)
!addr U0_MLADD_ADDR = $D7D0  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (address)
MATH_U0_MLADD_MASK = %01000000  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (bit mask)
!addr U0_MLADD_MASK = %01000000  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (bit mask)
!addr MATH_U0_LATCH_ADDR = $D7D0  ; If set, Math Function Unit X's output is latched. (address)
!addr U0_LATCH_ADDR = $D7D0  ; If set, Math Function Unit X's output is latched. (address)
MATH_U0_LATCH_MASK = %10000000  ; If set, Math Function Unit X's output is latched. (bit mask)
!addr U0_LATCH_MASK = %10000000  ; If set, Math Function Unit X's output is latched. (bit mask)
!addr MATH_UNIT1OUT_ADDR = $D7D1  ; @UNITXOUT (address)
!addr UNIT1OUT_ADDR = $D7D1  ; @UNITXOUT (address)
MATH_UNIT1OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT1OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U1_LOWOUT_ADDR = $D7D1  ; @UXLOWOUT (address)
!addr U1_LOWOUT_ADDR = $D7D1  ; @UXLOWOUT (address)
MATH_U1_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U1_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U1_HIOUT_ADDR = $D7D1  ; @UXHIOUT (address)
!addr U1_HIOUT_ADDR = $D7D1  ; @UXHIOUT (address)
MATH_U1_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U1_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U1_MLADD_ADDR = $D7D1  ; @UXMLADD (address)
!addr U1_MLADD_ADDR = $D7D1  ; @UXMLADD (address)
MATH_U1_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr U1_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr MATH_U1_LATCH_ADDR = $D7D1  ; @UXLATCH (address)
!addr U1_LATCH_ADDR = $D7D1  ; @UXLATCH (address)
MATH_U1_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U1_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT2OUT_ADDR = $D7D2  ; @UNITXOUT (address)
!addr UNIT2OUT_ADDR = $D7D2  ; @UNITXOUT (address)
MATH_UNIT2OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT2OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U2_LOWOUT_ADDR = $D7D2  ; @UXLOWOUT (address)
!addr U2_LOWOUT_ADDR = $D7D2  ; @UXLOWOUT (address)
MATH_U2_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U2_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U2_HIOUT_ADDR = $D7D2  ; @UXHIOUT (address)
!addr U2_HIOUT_ADDR = $D7D2  ; @UXHIOUT (address)
MATH_U2_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U2_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U2_MLADD_ADDR = $D7D2  ; @UXMLADD (address)
!addr U2_MLADD_ADDR = $D7D2  ; @UXMLADD (address)
MATH_U2_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr U2_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr MATH_U2_LATCH_ADDR = $D7D2  ; @UXLATCH (address)
!addr U2_LATCH_ADDR = $D7D2  ; @UXLATCH (address)
MATH_U2_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U2_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT3OUT_ADDR = $D7D3  ; @UNITXOUT (address)
!addr UNIT3OUT_ADDR = $D7D3  ; @UNITXOUT (address)
MATH_UNIT3OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT3OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U3_LOWOUT_ADDR = $D7D3  ; @UXLOWOUT (address)
!addr U3_LOWOUT_ADDR = $D7D3  ; @UXLOWOUT (address)
MATH_U3_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U3_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U3_HIOUT_ADDR = $D7D3  ; @UXHIOUT (address)
!addr U3_HIOUT_ADDR = $D7D3  ; @UXHIOUT (address)
MATH_U3_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U3_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U3_MLADD_ADDR = $D7D3  ; @UXMLADD (address)
!addr U3_MLADD_ADDR = $D7D3  ; @UXMLADD (address)
MATH_U3_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr U3_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr MATH_U3_LATCH_ADDR = $D7D3  ; @UXLATCH (address)
!addr U3_LATCH_ADDR = $D7D3  ; @UXLATCH (address)
MATH_U3_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U3_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT4OUT_ADDR = $D7D4  ; @UNITXOUT (address)
!addr UNIT4OUT_ADDR = $D7D4  ; @UNITXOUT (address)
MATH_UNIT4OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT4OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U4_LOWOUT_ADDR = $D7D4  ; @UXLOWOUT (address)
!addr U4_LOWOUT_ADDR = $D7D4  ; @UXLOWOUT (address)
MATH_U4_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U4_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U4_HIOUT_ADDR = $D7D4  ; @UXHIOUT (address)
!addr U4_HIOUT_ADDR = $D7D4  ; @UXHIOUT (address)
MATH_U4_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U4_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U4_MLADD_ADDR = $D7D4  ; @UXMLADD (address)
!addr U4_MLADD_ADDR = $D7D4  ; @UXMLADD (address)
MATH_U4_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr U4_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr MATH_U4_LATCH_ADDR = $D7D4  ; @UXLATCH (address)
!addr U4_LATCH_ADDR = $D7D4  ; @UXLATCH (address)
MATH_U4_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U4_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT5OUT_ADDR = $D7D5  ; @UNITXOUT (address)
!addr UNIT5OUT_ADDR = $D7D5  ; @UNITXOUT (address)
MATH_UNIT5OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT5OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U5_LOWOUT_ADDR = $D7D5  ; @UXLOWOUT (address)
!addr U5_LOWOUT_ADDR = $D7D5  ; @UXLOWOUT (address)
MATH_U5_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U5_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U5_HIOUT_ADDR = $D7D5  ; @UXHIOUT (address)
!addr U5_HIOUT_ADDR = $D7D5  ; @UXHIOUT (address)
MATH_U5_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U5_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U5_MLADD_ADDR = $D7D5  ; @UXMLADD (address)
!addr U5_MLADD_ADDR = $D7D5  ; @UXMLADD (address)
MATH_U5_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr U5_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr MATH_U5_LATCH_ADDR = $D7D5  ; @UXLATCH (address)
!addr U5_LATCH_ADDR = $D7D5  ; @UXLATCH (address)
MATH_U5_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U5_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT6OUT_ADDR = $D7D6  ; @UNITXOUT (address)
!addr UNIT6OUT_ADDR = $D7D6  ; @UNITXOUT (address)
MATH_UNIT6OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT6OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U6_LOWOUT_ADDR = $D7D6  ; @UXLOWOUT (address)
!addr U6_LOWOUT_ADDR = $D7D6  ; @UXLOWOUT (address)
MATH_U6_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U6_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U6_HIOUT_ADDR = $D7D6  ; @UXHIOUT (address)
!addr U6_HIOUT_ADDR = $D7D6  ; @UXHIOUT (address)
MATH_U6_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U6_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U6_MLADD_ADDR = $D7D6  ; @UXMLADD (address)
!addr U6_MLADD_ADDR = $D7D6  ; @UXMLADD (address)
MATH_U6_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr U6_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr MATH_U6_LATCH_ADDR = $D7D6  ; @UXLATCH (address)
!addr U6_LATCH_ADDR = $D7D6  ; @UXLATCH (address)
MATH_U6_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U6_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT7OUT_ADDR = $D7D7  ; @UNITXOUT (address)
!addr UNIT7OUT_ADDR = $D7D7  ; @UNITXOUT (address)
MATH_UNIT7OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT7OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U7_LOWOUT_ADDR = $D7D7  ; @UXLOWOUT (address)
!addr U7_LOWOUT_ADDR = $D7D7  ; @UXLOWOUT (address)
MATH_U7_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U7_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U7_HIOUT_ADDR = $D7D7  ; @UXHIOUT (address)
!addr U7_HIOUT_ADDR = $D7D7  ; @UXHIOUT (address)
MATH_U7_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U7_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U7_MLADD_ADDR = $D7D7  ; @UXMLADD (address)
!addr U7_MLADD_ADDR = $D7D7  ; @UXMLADD (address)
MATH_U7_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr U7_MLADD_MASK = %01000000  ; @UXMLADD (bit mask)
!addr MATH_U7_LATCH_ADDR = $D7D7  ; @UXLATCH (address)
!addr U7_LATCH_ADDR = $D7D7  ; @UXLATCH (address)
MATH_U7_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U7_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT8OUT_ADDR = $D7D8  ; @UNITXOUT (address)
!addr UNIT8OUT_ADDR = $D7D8  ; @UNITXOUT (address)
MATH_UNIT8OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT8OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U8_LOWOUT_ADDR = $D7D8  ; @UXLOWOUT (address)
!addr U8_LOWOUT_ADDR = $D7D8  ; @UXLOWOUT (address)
MATH_U8_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U8_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U8_HIOUT_ADDR = $D7D8  ; @UXHIOUT (address)
!addr U8_HIOUT_ADDR = $D7D8  ; @UXHIOUT (address)
MATH_U8_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U8_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U8_BSADD_ADDR = $D7D8  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (address)
!addr U8_BSADD_ADDR = $D7D8  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (address)
MATH_U8_BSADD_MASK = %01000000  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (bit mask)
!addr U8_BSADD_MASK = %01000000  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (bit mask)
!addr MATH_U8_LATCH_ADDR = $D7D8  ; @UXLATCH (address)
!addr U8_LATCH_ADDR = $D7D8  ; @UXLATCH (address)
MATH_U8_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U8_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNIT9OUT_ADDR = $D7D9  ; @UNITXOUT (address)
!addr UNIT9OUT_ADDR = $D7D9  ; @UNITXOUT (address)
MATH_UNIT9OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNIT9OUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_U9_LOWOUT_ADDR = $D7D9  ; @UXLOWOUT (address)
!addr U9_LOWOUT_ADDR = $D7D9  ; @UXLOWOUT (address)
MATH_U9_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr U9_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_U9_HIOUT_ADDR = $D7D9  ; @UXHIOUT (address)
!addr U9_HIOUT_ADDR = $D7D9  ; @UXHIOUT (address)
MATH_U9_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr U9_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_U9_BSADD_ADDR = $D7D9  ; @UXBSADD (address)
!addr U9_BSADD_ADDR = $D7D9  ; @UXBSADD (address)
MATH_U9_BSADD_MASK = %01000000  ; @UXBSADD (bit mask)
!addr U9_BSADD_MASK = %01000000  ; @UXBSADD (bit mask)
!addr MATH_U9_LATCH_ADDR = $D7D9  ; @UXLATCH (address)
!addr U9_LATCH_ADDR = $D7D9  ; @UXLATCH (address)
MATH_U9_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr U9_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNITAOUT_ADDR = $D7DA  ; @UNITXOUT (address)
!addr UNITAOUT_ADDR = $D7DA  ; @UNITXOUT (address)
MATH_UNITAOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNITAOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_UA_LOWOUT_ADDR = $D7DA  ; @UXLOWOUT (address)
!addr UA_LOWOUT_ADDR = $D7DA  ; @UXLOWOUT (address)
MATH_UA_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr UA_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_UA_HIOUT_ADDR = $D7DA  ; @UXHIOUT (address)
!addr UA_HIOUT_ADDR = $D7DA  ; @UXHIOUT (address)
MATH_UA_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr UA_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_UA_BSADD_ADDR = $D7DA  ; @UXBSADD (address)
!addr UA_BSADD_ADDR = $D7DA  ; @UXBSADD (address)
MATH_UA_BSADD_MASK = %01000000  ; @UXBSADD (bit mask)
!addr UA_BSADD_MASK = %01000000  ; @UXBSADD (bit mask)
!addr MATH_UA_LATCH_ADDR = $D7DA  ; @UXLATCH (address)
!addr UA_LATCH_ADDR = $D7DA  ; @UXLATCH (address)
MATH_UA_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr UA_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNITBOUT_ADDR = $D7DB  ; @UNITXOUT (address)
!addr UNITBOUT_ADDR = $D7DB  ; @UNITXOUT (address)
MATH_UNITBOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNITBOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_UB_LOWOUT_ADDR = $D7DB  ; @UXLOWOUT (address)
!addr UB_LOWOUT_ADDR = $D7DB  ; @UXLOWOUT (address)
MATH_UB_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr UB_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_UB_HIOUT_ADDR = $D7DB  ; @UXHIOUT (address)
!addr UB_HIOUT_ADDR = $D7DB  ; @UXHIOUT (address)
MATH_UB_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr UB_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_UB_BSADD_ADDR = $D7DB  ; @UXBSADD (address)
!addr UB_BSADD_ADDR = $D7DB  ; @UXBSADD (address)
MATH_UB_BSADD_MASK = %01000000  ; @UXBSADD (bit mask)
!addr UB_BSADD_MASK = %01000000  ; @UXBSADD (bit mask)
!addr MATH_UB_LATCH_ADDR = $D7DB  ; @UXLATCH (address)
!addr UB_LATCH_ADDR = $D7DB  ; @UXLATCH (address)
MATH_UB_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr UB_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNITCOUT_ADDR = $D7DC  ; @UNITXOUT (address)
!addr UNITCOUT_ADDR = $D7DC  ; @UNITXOUT (address)
MATH_UNITCOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNITCOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_UC_LOWOUT_ADDR = $D7DC  ; @UXLOWOUT (address)
!addr UC_LOWOUT_ADDR = $D7DC  ; @UXLOWOUT (address)
MATH_UC_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr UC_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_UC_HIOUT_ADDR = $D7DC  ; @UXHIOUT (address)
!addr UC_HIOUT_ADDR = $D7DC  ; @UXHIOUT (address)
MATH_UC_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr UC_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_UC_DVADD_ADDR = $D7DC  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (address)
!addr UC_DVADD_ADDR = $D7DC  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (address)
MATH_UC_DVADD_MASK = %01000000  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (bit mask)
!addr UC_DVADD_MASK = %01000000  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (bit mask)
!addr MATH_UC_LATCH_ADDR = $D7DC  ; @UXLATCH (address)
!addr UC_LATCH_ADDR = $D7DC  ; @UXLATCH (address)
MATH_UC_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr UC_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNITDOUT_ADDR = $D7DD  ; @UNITXOUT (address)
!addr UNITDOUT_ADDR = $D7DD  ; @UNITXOUT (address)
MATH_UNITDOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNITDOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_UD_LOWOUT_ADDR = $D7DD  ; @UXLOWOUT (address)
!addr UD_LOWOUT_ADDR = $D7DD  ; @UXLOWOUT (address)
MATH_UD_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr UD_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_UD_HIOUT_ADDR = $D7DD  ; @UXHIOUT (address)
!addr UD_HIOUT_ADDR = $D7DD  ; @UXHIOUT (address)
MATH_UD_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr UD_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_UD_DVADD_ADDR = $D7DD  ;  (address)
!addr UD_DVADD_ADDR = $D7DD  ;  (address)
MATH_UD_DVADD_MASK = %01000000  ;  (bit mask)
!addr UD_DVADD_MASK = %01000000  ;  (bit mask)
!addr MATH_UD_LATCH_ADDR = $D7DD  ; @UXLATCH (address)
!addr UD_LATCH_ADDR = $D7DD  ; @UXLATCH (address)
MATH_UD_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr UD_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNITEOUT_ADDR = $D7DE  ; @UNITXOUT (address)
!addr UNITEOUT_ADDR = $D7DE  ; @UNITXOUT (address)
MATH_UNITEOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNITEOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_UE_LOWOUT_ADDR = $D7DE  ; @UXLOWOUT (address)
!addr UE_LOWOUT_ADDR = $D7DE  ; @UXLOWOUT (address)
MATH_UE_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr UE_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_UE_HIOUT_ADDR = $D7DE  ; @UXHIOUT (address)
!addr UE_HIOUT_ADDR = $D7DE  ; @UXHIOUT (address)
MATH_UE_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr UE_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_UE_DVADD_ADDR = $D7DE  ;  (address)
!addr UE_DVADD_ADDR = $D7DE  ;  (address)
MATH_UE_DVADD_MASK = %01000000  ;  (bit mask)
!addr UE_DVADD_MASK = %01000000  ;  (bit mask)
!addr MATH_UE_LATCH_ADDR = $D7DE  ; @UXLATCH (address)
!addr UE_LATCH_ADDR = $D7DE  ; @UXLATCH (address)
MATH_UE_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr UE_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_UNITFOUT_ADDR = $D7DF  ; @UNITXOUT (address)
!addr UNITFOUT_ADDR = $D7DF  ; @UNITXOUT (address)
MATH_UNITFOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr UNITFOUT_MASK = %00001111  ; @UNITXOUT (bit mask)
!addr MATH_UF_LOWOUT_ADDR = $D7DF  ; @UXLOWOUT (address)
!addr UF_LOWOUT_ADDR = $D7DF  ; @UXLOWOUT (address)
MATH_UF_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr UF_LOWOUT_MASK = %00010000  ; @UXLOWOUT (bit mask)
!addr MATH_UF_HIOUT_ADDR = $D7DF  ; @UXHIOUT (address)
!addr UF_HIOUT_ADDR = $D7DF  ; @UXHIOUT (address)
MATH_UF_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr UF_HIOUT_MASK = %00100000  ; @UXHIOUT (bit mask)
!addr MATH_UF_DVADD_ADDR = $D7DF  ;  (address)
!addr UF_DVADD_ADDR = $D7DF  ;  (address)
MATH_UF_DVADD_MASK = %01000000  ;  (bit mask)
!addr UF_DVADD_MASK = %01000000  ;  (bit mask)
!addr MATH_UF_LATCH_ADDR = $D7DF  ; @UXLATCH (address)
!addr UF_LATCH_ADDR = $D7DF  ; @UXLATCH (address)
MATH_UF_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr UF_LATCH_MASK = %10000000  ; @UXLATCH (bit mask)
!addr MATH_LATCHINT = $D7E0  ; Latch interval for latched outputs (in CPU cycles)
!addr LATCHINT = $D7E0  ; Latch interval for latched outputs (in CPU cycles)
!addr MATH_WREN_ADDR = $D7E1  ; Enable setting of math registers (must normally be set) (address)
!addr WREN_ADDR = $D7E1  ; Enable setting of math registers (must normally be set) (address)
MATH_WREN_MASK = %00000001  ; Enable setting of math registers (must normally be set) (bit mask)
!addr WREN_MASK = %00000001  ; Enable setting of math registers (must normally be set) (bit mask)
!addr MATH_CALCEN_ADDR = $D7E1  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (address)
!addr CALCEN_ADDR = $D7E1  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (address)
MATH_CALCEN_MASK = %00000010  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (bit mask)
!addr CALCEN_MASK = %00000010  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (bit mask)
!addr MATH_RESERVED = $D7E2  ; Reserved
!addr GS_MATH_RESERVED = $D7E3  ; Reserved
!addr MATH_ITERCNT = $D7E4  ; Iteration Counter (32 bit)
!addr GS_MATH_ITERCNT = $D7E5  ; Iteration Counter (32 bit)
!addr GS_MATH_ITERCNT_2 = $D7E6  ; Iteration Counter (32 bit)
!addr GS_MATH_ITERCNT_3 = $D7E7  ; Iteration Counter (32 bit)
!addr MATH_ITERCMP = $D7E8  ; Math iteration counter comparator (32 bit)
!addr GS_MATH_ITERCMP = $D7E9  ; Math iteration counter comparator (32 bit)
!addr GS_MATH_ITERCMP_2 = $D7EA  ; Math iteration counter comparator (32 bit)
!addr GS_MATH_ITERCMP_3 = $D7EB  ; Math iteration counter comparator (32 bit)
!addr CPU_IECBUSACT_ADDR = $D7F1  ; IEC bus is active (address)
!addr IECBUSACT_ADDR = $D7F1  ; IEC bus is active (address)
CPU_IECBUSACT_MASK = %00000001  ; IEC bus is active (bit mask)
!addr IECBUSACT_MASK = %00000001  ; IEC bus is active (bit mask)
!addr CPU_PHIPERFRAME = $D7F2  ; Count the number of PHI cycles per video frame (LSB)
!addr GS_CPU_PHIPERFRAME = $D7F5  ; Count the number of PHI cycles per video frame (MSB)
!addr CPU_CYCPERFRAME = $D7F6  ; Count the number of usable (proceed=1) CPU cycles per video frame (LSB)
!addr GS_CPU_CYCPERFRAME = $D7F9  ; Count the number of usable (proceed=1) CPU cycles per video frame (MSB)
!addr CPU_FRAMECOUNT = $D7FA  ; Count number of elapsed video frames
!addr FRAMECOUNT = $D7FA  ; Count number of elapsed video frames
!addr CPU_CARTEN_ADDR = $D7FB  ; 1= enable cartridges (address)
!addr CARTEN_ADDR = $D7FB  ; 1= enable cartridges (address)
CPU_CARTEN_MASK = %00000010  ; 1= enable cartridges (bit mask)
!addr CARTEN_MASK = %00000010  ; 1= enable cartridges (bit mask)
!addr CPU_POWEREN_ADDR = $D7FD  ; Set to zero to power off computer on supported systems. WRITE ONLY. (address)
!addr POWEREN_ADDR = $D7FD  ; Set to zero to power off computer on supported systems. WRITE ONLY. (address)
CPU_POWEREN_MASK = %00000001  ; Set to zero to power off computer on supported systems. WRITE ONLY. (bit mask)
!addr POWEREN_MASK = %00000001  ; Set to zero to power off computer on supported systems. WRITE ONLY. (bit mask)
!addr CPU_NOGAME_ADDR = $D7FD  ; Override for /GAME : Must be 0 to enable /GAME signal (address)
!addr NOGAME_ADDR = $D7FD  ; Override for /GAME : Must be 0 to enable /GAME signal (address)
CPU_NOGAME_MASK = %01000000  ; Override for /GAME : Must be 0 to enable /GAME signal (bit mask)
!addr NOGAME_MASK = %01000000  ; Override for /GAME : Must be 0 to enable /GAME signal (bit mask)
!addr CPU_NOEXROM_ADDR = $D7FD  ; Override for /EXROM : Must be 0 to enable /EXROM signal (address)
!addr NOEXROM_ADDR = $D7FD  ; Override for /EXROM : Must be 0 to enable /EXROM signal (address)
CPU_NOEXROM_MASK = %10000000  ; Override for /EXROM : Must be 0 to enable /EXROM signal (bit mask)
!addr NOEXROM_MASK = %10000000  ; Override for /EXROM : Must be 0 to enable /EXROM signal (bit mask)
!addr CPU_PREFETCH_ADDR = $D7FE  ; Enable expansion RAM pre-fetch logic (address)
!addr PREFETCH_ADDR = $D7FE  ; Enable expansion RAM pre-fetch logic (address)
CPU_PREFETCH_MASK = %00000001  ; Enable expansion RAM pre-fetch logic (bit mask)
!addr PREFETCH_MASK = %00000001  ; Enable expansion RAM pre-fetch logic (bit mask)
!addr CPU_OCEANA_ADDR = $D7FE  ; Enable Ocean Type A cartridge emulation (address)
!addr OCEANA_ADDR = $D7FE  ; Enable Ocean Type A cartridge emulation (address)
CPU_OCEANA_MASK = %00000010  ; Enable Ocean Type A cartridge emulation (bit mask)
!addr OCEANA_MASK = %00000010  ; Enable Ocean Type A cartridge emulation (bit mask)
!addr ETHCOMMAND_DEBUGCPU = $DC  ; Select CPU debug stream via ethernet when \$D6E1.3 is set
!addr DEBUGCPU = $DC  ; Select CPU debug stream via ethernet when \$D6E1.3 is set
!addr CIA1_PORTA = $DC00  ; Port A
!addr CIA1_PORTB = $DC01  ; Port B
!addr CIA1_DDRA = $DC02  ; Port A DDR
!addr CIA1_DDRB = $DC03  ; Port B DDR
!addr CIA1_TIMERA = $DC04  ; Timer A counter (16 bit)
!addr C64_CIA1_TIMERA = $DC05  ; Timer A counter (16 bit)
!addr CIA1_TIMERB = $DC06  ; Timer B counter (16 bit)
!addr C64_CIA1_TIMERB = $DC07  ; Timer B counter (16 bit)
!addr CIA1_TODJIF_ADDR = $DC08  ; TOD tenths of seconds (address)
CIA1_TODJIF_MASK = %00001111  ; TOD tenths of seconds (bit mask)
!addr CIA1_TODSEC_ADDR = $DC09  ; TOD seconds (address)
CIA1_TODSEC_MASK = %00111111  ; TOD seconds (bit mask)
!addr CIA1_TODMIN_ADDR = $DC0A  ; TOD minutes (address)
!addr TODMIN_ADDR = $DC0A  ; TOD minutes (address)
CIA1_TODMIN_MASK = %00111111  ; TOD minutes (bit mask)
!addr TODMIN_MASK = %00111111  ; TOD minutes (bit mask)
!addr CIA1_TODHOUR_ADDR = $DC0B  ; TOD hours (address)
CIA1_TODHOUR_MASK = %00011111  ; TOD hours (bit mask)
!addr CIA1_TODAMPM_ADDR = $DC0B  ; TOD PM flag (address)
CIA1_TODAMPM_MASK = %10000000  ; TOD PM flag (bit mask)
!addr CIA1_SDR = $DC0C  ; shift register data register(writing starts sending)
!addr CIA1_TA_ADDR = $DC0D  ; Timer A underflow (address)
CIA1_TA_MASK = %00000001  ; Timer A underflow (bit mask)
!addr CIA1_TB_ADDR = $DC0D  ; Timer B underflow (address)
CIA1_TB_MASK = %00000010  ; Timer B underflow (bit mask)
!addr CIA1_ALRM_ADDR = $DC0D  ; TOD alarm (address)
CIA1_ALRM_MASK = %00000100  ; TOD alarm (bit mask)
!addr CIA1_SP_ADDR = $DC0D  ; shift register full/empty (address)
CIA1_SP_MASK = %00001000  ; shift register full/empty (bit mask)
!addr CIA1_FLG_ADDR = $DC0D  ; FLAG edge detected (address)
CIA1_FLG_MASK = %00010000  ; FLAG edge detected (bit mask)
!addr CIA1_IR_ADDR = $DC0D  ; Interrupt flag (address)
!addr IR_ADDR = $DC0D  ; Interrupt flag (address)
CIA1_IR_MASK = %10000000  ; Interrupt flag (bit mask)
!addr IR_MASK = %10000000  ; Interrupt flag (bit mask)
!addr CIA1_STRTA_ADDR = $DC0E  ; Timer A start (address)
CIA1_STRTA_MASK = %00000001  ; Timer A start (bit mask)
!addr CIA1_PBONA_ADDR = $DC0E  ; Timer A PB6 out (address)
CIA1_PBONA_MASK = %00000010  ; Timer A PB6 out (bit mask)
!addr CIA1_OMODA_ADDR = $DC0E  ; Timer A toggle or pulse (address)
CIA1_OMODA_MASK = %00000100  ; Timer A toggle or pulse (bit mask)
!addr CIA1_RMODA_ADDR = $DC0E  ; Timer A one-shot mode (address)
CIA1_RMODA_MASK = %00001000  ; Timer A one-shot mode (bit mask)
!addr CIA1_IMODA_ADDR = $DC0E  ; Timer A Timer A tick source (address)
CIA1_IMODA_MASK = %00100000  ; Timer A Timer A tick source (bit mask)
!addr CIA1_SPMOD_ADDR = $DC0E  ; Serial port direction (address)
CIA1_SPMOD_MASK = %01000000  ; Serial port direction (bit mask)
!addr CIA1_TOD50_ADDR = $DC0E  ; 50/60Hz select for TOD clock (address)
CIA1_TOD50_MASK = %10000000  ; 50/60Hz select for TOD clock (bit mask)
!addr CIA1_STRTB_ADDR = $DC0F  ; Timer B start (address)
CIA1_STRTB_MASK = %00000001  ; Timer B start (bit mask)
!addr CIA1_PBONB_ADDR = $DC0F  ; Timer B PB7 out (address)
CIA1_PBONB_MASK = %00000010  ; Timer B PB7 out (bit mask)
!addr CIA1_OMODB_ADDR = $DC0F  ; Timer B toggle or pulse (address)
CIA1_OMODB_MASK = %00000100  ; Timer B toggle or pulse (bit mask)
!addr CIA1_RMODB_ADDR = $DC0F  ; Timer B one-shot mode (address)
CIA1_RMODB_MASK = %00001000  ; Timer B one-shot mode (bit mask)
!addr CIA1_LOAD_ADDR = $DC0F  ; Strobe input to force-load timers (address)
CIA1_LOAD_MASK = %00010000  ; Strobe input to force-load timers (bit mask)
!addr CIA1_IMODB_ADDR = $DC0F  ; Timer B Timer A tick source (address)
CIA1_IMODB_MASK = %01100000  ; Timer B Timer A tick source (bit mask)
!addr CIA2_TODEDIT_ADDR = $DC0F  ; TOD alarm edit (address)
CIA2_TODEDIT_MASK = %10000000  ; TOD alarm edit (bit mask)
!addr CIA1_TALATCH = $DC10  ; Timer A latch value (16 bit)
!addr GS_CIA1_TALATCH = $DC11  ; Timer A latch value (16 bit)
!addr GS_CIA1_TALATCH_2 = $DC12  ; Timer B latch value (16 bit)
!addr GS_CIA1_TALATCH_3 = $DC13  ; Timer B latch value (16 bit)
!addr GS_CIA1_TALATCH_4 = $DC14  ; Timer A current value (16 bit)
!addr GS_CIA1_TALATCH_5 = $DC15  ; Timer A current value (16 bit)
!addr GS_CIA1_TALATCH_6 = $DC16  ; Timer B current value (16 bit)
!addr GS_CIA1_TALATCH_7 = $DC17  ; Timer B current value (16 bit)
!addr GS_CIA1_TODJIF_ADDR = $DC18  ; TOD 10ths of seconds value (address)
GS_CIA1_TODJIF_MASK = %00001111  ; TOD 10ths of seconds value (bit mask)
!addr CIA1_IMTB_ADDR = $DC18  ; Interrupt mask for Timer B (address)
CIA1_IMTB_MASK = %00010000  ; Interrupt mask for Timer B (bit mask)
!addr CIA1_IMALRM_ADDR = $DC18  ; Interrupt mask for TOD alarm (address)
CIA1_IMALRM_MASK = %00100000  ; Interrupt mask for TOD alarm (bit mask)
!addr CIA1_IMSP_ADDR = $DC18  ; Interrupt mask for shift register (serial port) (address)
CIA1_IMSP_MASK = %01000000  ; Interrupt mask for shift register (serial port) (bit mask)
!addr CIA1_IMFLG_ADDR = $DC18  ; Interrupt mask for FLAG line (address)
CIA1_IMFLG_MASK = %10000000  ; Interrupt mask for FLAG line (bit mask)
!addr CIA1_TODSEC = $DC19  ; TOD Alarm seconds value
!addr CIA1_TODMIN = $DC1A  ; TOD Alarm minutes value
!addr GS_CIA1_TODHOUR_ADDR = $DC1B  ; TOD hours value (address)
GS_CIA1_TODHOUR_MASK = %01111111  ; TOD hours value (bit mask)
!addr GS_CIA1_TODAMPM_ADDR = $DC1B  ; TOD AM/PM flag (address)
GS_CIA1_TODAMPM_MASK = %10000000  ; TOD AM/PM flag (bit mask)
!addr CIA1_ALRMJIF = $DC1C  ; TOD Alarm 10ths of seconds value
!addr CIA1_ALRMSEC = $DC1D  ; TOD Alarm seconds value
!addr CIA1_ALRMMIN = $DC1E  ; TOD Alarm minutes value
!addr CIA1_ALRMHOUR_ADDR = $DC1F  ; TOD Alarm hours value (address)
CIA1_ALRMHOUR_MASK = %01111111  ; TOD Alarm hours value (bit mask)
!addr CIA1_ALRMAMPM_ADDR = $DC1F  ; TOD Alarm AM/PM flag (address)
CIA1_ALRMAMPM_MASK = %10000000  ; TOD Alarm AM/PM flag (bit mask)
!addr CIA2_PORTA = $DD00  ; Port A
!addr CIA2_PORTB = $DD01  ; Port B
!addr CIA2_DDRA = $DD02  ; Port A DDR
!addr CIA2_DDRB = $DD03  ; Port B DDR
!addr CIA2_TIMERA = $DD04  ; Timer A counter (16 bit)
!addr C64_CIA2_TIMERA = $DD05  ; Timer A counter (16 bit)
!addr CIA2_TIMERB = $DD06  ; Timer B counter (16 bit)
!addr C64_CIA2_TIMERB = $DD07  ; Timer B counter (16 bit)
!addr CIA2_TODJIF_ADDR = $DD08  ; TOD tenths of seconds (address)
CIA2_TODJIF_MASK = %00001111  ; TOD tenths of seconds (bit mask)
!addr CIA2_TODSEC_ADDR = $DD09  ; TOD seconds (address)
CIA2_TODSEC_MASK = %00111111  ; TOD seconds (bit mask)
!addr CIA2_TODHOUR_ADDR = $DD0B  ; TOD hours (address)
CIA2_TODHOUR_MASK = %00011111  ; TOD hours (bit mask)
!addr CIA2_TODAMPM_ADDR = $DD0B  ; TOD PM flag (address)
CIA2_TODAMPM_MASK = %10000000  ; TOD PM flag (bit mask)
!addr CIA2_SDR = $DD0C  ; shift register data register(writing starts sending)
!addr CIA2_TA_ADDR = $DD0D  ; Timer A underflow (address)
CIA2_TA_MASK = %00000001  ; Timer A underflow (bit mask)
!addr CIA2_TB_ADDR = $DD0D  ; Timer B underflow (address)
CIA2_TB_MASK = %00000010  ; Timer B underflow (bit mask)
!addr CIA2_ALRM_ADDR = $DD0D  ; TOD alarm (address)
CIA2_ALRM_MASK = %00000100  ; TOD alarm (bit mask)
!addr CIA2_SP_ADDR = $DD0D  ; shift register full/empty (address)
CIA2_SP_MASK = %00001000  ; shift register full/empty (bit mask)
!addr CIA2_FLG_ADDR = $DD0D  ; FLAG edge detected (address)
CIA2_FLG_MASK = %00010000  ; FLAG edge detected (bit mask)
!addr CIA2_STRTA_ADDR = $DD0E  ; Timer A start (address)
CIA2_STRTA_MASK = %00000001  ; Timer A start (bit mask)
!addr CIA2_PBONA_ADDR = $DD0E  ; Timer A PB6 out (address)
CIA2_PBONA_MASK = %00000010  ; Timer A PB6 out (bit mask)
!addr CIA2_OMODA_ADDR = $DD0E  ; Timer A toggle or pulse (address)
CIA2_OMODA_MASK = %00000100  ; Timer A toggle or pulse (bit mask)
!addr CIA2_RMODA_ADDR = $DD0E  ; Timer A one-shot mode (address)
CIA2_RMODA_MASK = %00001000  ; Timer A one-shot mode (bit mask)
!addr CIA2_IMODA_ADDR = $DD0E  ; Timer A Timer A tick source (address)
CIA2_IMODA_MASK = %00100000  ; Timer A Timer A tick source (bit mask)
!addr CIA2_SPMOD_ADDR = $DD0E  ; Serial port direction (address)
CIA2_SPMOD_MASK = %01000000  ; Serial port direction (bit mask)
!addr CIA2_TOD50_ADDR = $DD0E  ; 50/60Hz select for TOD clock (address)
CIA2_TOD50_MASK = %10000000  ; 50/60Hz select for TOD clock (bit mask)
!addr CIA2_STRTB_ADDR = $DD0F  ; Timer B start (address)
CIA2_STRTB_MASK = %00000001  ; Timer B start (bit mask)
!addr CIA2_PBONB_ADDR = $DD0F  ; Timer B PB7 out (address)
CIA2_PBONB_MASK = %00000010  ; Timer B PB7 out (bit mask)
!addr CIA2_OMODB_ADDR = $DD0F  ; Timer B toggle or pulse (address)
CIA2_OMODB_MASK = %00000100  ; Timer B toggle or pulse (bit mask)
!addr CIA2_RMODB_ADDR = $DD0F  ; Timer B one-shot mode (address)
CIA2_RMODB_MASK = %00001000  ; Timer B one-shot mode (bit mask)
!addr CIA2_LOAD_ADDR = $DD0F  ; Strobe input to force-load timers (address)
CIA2_LOAD_MASK = %00010000  ; Strobe input to force-load timers (bit mask)
!addr CIA2_IMODB_ADDR = $DD0F  ; Timer B Timer A tick source (address)
CIA2_IMODB_MASK = %01100000  ; Timer B Timer A tick source (bit mask)
!addr C64_CIA2_TODEDIT_ADDR = $DD0F  ; TOD alarm edit (address)
C64_CIA2_TODEDIT_MASK = %10000000  ; TOD alarm edit (bit mask)
!addr CIA2_TALATCH = $DD10  ; Timer A latch value (16 bit)
!addr GS_CIA2_TALATCH = $DD11  ; Timer A latch value (16 bit)
!addr GS_CIA2_TALATCH_2 = $DD12  ; Timer B latch value (16 bit)
!addr GS_CIA2_TALATCH_3 = $DD13  ; Timer B latch value (16 bit)
!addr GS_CIA2_TALATCH_4 = $DD14  ; Timer A current value (16 bit)
!addr GS_CIA2_TALATCH_5 = $DD15  ; Timer A current value (16 bit)
!addr GS_CIA2_TALATCH_6 = $DD16  ; Timer B current value (16 bit)
!addr GS_CIA2_TALATCH_7 = $DD17  ; Timer B current value (16 bit)
!addr GS_CIA2_TODJIF_ADDR = $DD18  ; TOD 10ths of seconds value (address)
GS_CIA2_TODJIF_MASK = %00001111  ; TOD 10ths of seconds value (bit mask)
!addr CIA2_IMTB_ADDR = $DD18  ; Interrupt mask for Timer B (address)
CIA2_IMTB_MASK = %00010000  ; Interrupt mask for Timer B (bit mask)
!addr CIA2_IMALRM_ADDR = $DD18  ; Interrupt mask for TOD alarm (address)
CIA2_IMALRM_MASK = %00100000  ; Interrupt mask for TOD alarm (bit mask)
!addr CIA2_IMSP_ADDR = $DD18  ; Interrupt mask for shift register (serial port) (address)
CIA2_IMSP_MASK = %01000000  ; Interrupt mask for shift register (serial port) (bit mask)
!addr CIA2_IMFLG_ADDR = $DD18  ; Interrupt mask for FLAG line (address)
CIA2_IMFLG_MASK = %10000000  ; Interrupt mask for FLAG line (bit mask)
!addr CIA2_TODSEC = $DD19  ; TOD Alarm seconds value
!addr CIA2_TODMIN = $DD1A  ; TOD Alarm minutes value
!addr GS_CIA2_TODHOUR_ADDR = $DD1B  ; TOD hours value (address)
GS_CIA2_TODHOUR_MASK = %01111111  ; TOD hours value (bit mask)
!addr GS_CIA2_TODAMPM_ADDR = $DD1B  ; TOD AM/PM flag (address)
GS_CIA2_TODAMPM_MASK = %10000000  ; TOD AM/PM flag (bit mask)
!addr CIA2_ALRMJIF = $DD1C  ; TOD Alarm 10ths of seconds value
!addr CIA2_DD00DELAY_ADDR = $DD1C  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (address)
!addr DD00DELAY_ADDR = $DD1C  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (address)
CIA2_DD00DELAY_MASK = %10000000  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (bit mask)
!addr DD00DELAY_MASK = %10000000  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (bit mask)
!addr CIA2_ALRMSEC = $DD1D  ; TOD Alarm seconds value
!addr CIA2_ALRMMIN = $DD1E  ; TOD Alarm minutes value
!addr CIA2_ALRMHOUR_ADDR = $DD1F  ; TOD Alarm hours value (address)
CIA2_ALRMHOUR_MASK = %01111111  ; TOD Alarm hours value (bit mask)
!addr CIA2_ALRMAMPM_ADDR = $DD1F  ; TOD Alarm AM/PM flag (address)
CIA2_ALRMAMPM_MASK = %10000000  ; TOD Alarm AM/PM flag (bit mask)
!addr ETHCOMMAND_RXONLYONE = $DE  ; Receive exactly one ethernet frame only, and keep all signals states (for debugging ethernet sub-system)
!addr RXONLYONE = $DE  ; Receive exactly one ethernet frame only, and keep all signals states (for debugging ethernet sub-system)
!addr ETHCOMMAND_FRAME1K = $F1  ; Select ~1KiB frames for video/cpu debug stream frames (for receivers that do not support MTUs of greater than 2KiB)
!addr FRAME1K = $F1  ; Select ~1KiB frames for video/cpu debug stream frames (for receivers that do not support MTUs of greater than 2KiB)
!addr ETHCOMMAND_FRAME2K = $F2  ; Select ~2KiB frames for video/cpu debug stream frames, for optimal performance.
!addr FRAME2K = $F2  ; Select ~2KiB frames for video/cpu debug stream frames, for optimal performance.
!addr SUMMARY_CHARWRITE = $FF7E000  ; VIC-IV CHARROM write area
!addr CHARWRITE = $FF7E000  ; VIC-IV CHARROM write area
!addr SUMMARY_COLOURRAM = $FF80000  ; Colour RAM (32KB or 64KB)
!addr COLOURRAM = $FF80000  ; Colour RAM (32KB or 64KB)
!addr RTC_RTCSEC = $FFD7110  ; Real-time Clock seconds value (binary coded decimal)
!addr RTCSEC = $FFD7110  ; Real-time Clock seconds value (binary coded decimal)
!addr RTC_RTC = $FFD7110  ; Real-time Clock
!addr RTC = $FFD7110  ; Real-time Clock
!addr RTC_RTCMIN = $FFD7111  ; Real-time Clock minutes value (binary coded decimal)
!addr RTCMIN = $FFD7111  ; Real-time Clock minutes value (binary coded decimal)
!addr RTC_RTCHOUR = $FFD7112  ; Real-time Clock hours value (binary coded decimal)
!addr RTCHOUR = $FFD7112  ; Real-time Clock hours value (binary coded decimal)
!addr RTC_RTCDAY = $FFD7113  ; Real-time Clock day of month value (binary coded decimal)
!addr RTCDAY = $FFD7113  ; Real-time Clock day of month value (binary coded decimal)
!addr RTC_RTCMONTH = $FFD7114  ; Real-time Clock month value (binary coded decimal)
!addr RTCMONTH = $FFD7114  ; Real-time Clock month value (binary coded decimal)
!addr RTC_RTCYEAR = $FFD7115  ; Real-time Clock year value (binary coded decimal)
!addr RTCYEAR = $FFD7115  ; Real-time Clock year value (binary coded decimal)
!addr RTC_NVRAM = $FFD7140  ; 64-bytes of non-volatile RAM. Can be used for storing machine configuration.
!addr NVRAM = $FFD7140  ; 64-bytes of non-volatile RAM. Can be used for storing machine configuration.
!addr SUMMARY_HYPERVISOR = $FFF8000  ; 16KB Hyppo/Hypervisor ROM
!addr HYPERVISOR = $FFF8000  ; 16KB Hyppo/Hypervisor ROM
