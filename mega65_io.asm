// Generated from: ../mega65-core/iomap.txt
// Date: 2022-06-11

.var ETHCOMMAND_STOPTX = $00  // Immediately stop transmitting the current ethernet frame. Will cause a partially sent frame to be received, most likely resulting in the loss of that frame.
.var STOPTX = $00  // Immediately stop transmitting the current ethernet frame. Will cause a partially sent frame to be received, most likely resulting in the loss of that frame.
.var CPU_PORTDDR = $0000000  // 6510/45GS10 CPU port DDR
.var PORTDDR = $0000000  // 6510/45GS10 CPU port DDR
.var CPU_PORT = $0000001  // 6510/45GS10 CPU port data
.var PORT = $0000001  // 6510/45GS10 CPU port data
.var ETHCOMMAND_STARTTX = $01  // Transmit packet
.var STARTTX = $01  // Transmit packet
.var ETHCOMMAND_RXNORMAL = $D0  // Disable the effects of RXONLYONE
.var RXNORMAL = $D0  // Disable the effects of RXONLYONE
.var VIC2_S0X = $D000  // sprite N horizontal position
.var S0X = $D000  // sprite N horizontal position
.var VIC2_S0Y = $D001  // sprite N vertical position
.var S0Y = $D001  // sprite N vertical position
.var VIC2_S1X = $D002  // @SNX
.var S1X = $D002  // @SNX
.var VIC2_S1Y = $D003  // @SNY
.var S1Y = $D003  // @SNY
.var VIC2_S2X = $D004  // @SNX
.var S2X = $D004  // @SNX
.var VIC2_S2Y = $D005  // @SNY
.var S2Y = $D005  // @SNY
.var VIC2_S3X = $D006  // @SNX
.var S3X = $D006  // @SNX
.var VIC2_S3Y = $D007  // @SNY
.var S3Y = $D007  // @SNY
.var VIC2_S4X = $D008  // @SNX
.var S4X = $D008  // @SNX
.var VIC2_S4Y = $D009  // @SNY
.var S4Y = $D009  // @SNY
.var VIC2_S5X = $D00A  // @SNX
.var S5X = $D00A  // @SNX
.var VIC2_S5Y = $D00B  // @SNY
.var S5Y = $D00B  // @SNY
.var VIC2_S6X = $D00C  // @SNX
.var S6X = $D00C  // @SNX
.var VIC2_S6Y = $D00D  // @SNY
.var S6Y = $D00D  // @SNY
.var VIC2_S7X = $D00E  // @SNX
.var S7X = $D00E  // @SNX
.var VIC2_S7Y = $D00F  // @SNY
.var S7Y = $D00F  // @SNY
.var VIC2_SXMSB = $D010  // sprite horizontal position MSBs
.var SXMSB = $D010  // sprite horizontal position MSBs
.var VIC2_YSCL_ADDR = $D011  // 24/25 vertical smooth scroll (address)
.var YSCL_ADDR = $D011  // 24/25 vertical smooth scroll (address)
.var VIC2_YSCL_MASK = %00000111  // 24/25 vertical smooth scroll (bit mask)
.var YSCL_MASK = %00000111  // 24/25 vertical smooth scroll (bit mask)
.var VIC2_RSEL_ADDR = $D011  // 24/25 row select (address)
.var RSEL_ADDR = $D011  // 24/25 row select (address)
.var VIC2_RSEL_MASK = %00001000  // 24/25 row select (bit mask)
.var RSEL_MASK = %00001000  // 24/25 row select (bit mask)
.var VIC2_BLNK_ADDR = $D011  // disable display (address)
.var BLNK_ADDR = $D011  // disable display (address)
.var VIC2_BLNK_MASK = %00010000  // disable display (bit mask)
.var BLNK_MASK = %00010000  // disable display (bit mask)
.var VIC2_BMM_ADDR = $D011  // bitmap mode (address)
.var BMM_ADDR = $D011  // bitmap mode (address)
.var VIC2_BMM_MASK = %00100000  // bitmap mode (bit mask)
.var BMM_MASK = %00100000  // bitmap mode (bit mask)
.var VIC2_ECM_ADDR = $D011  // extended background mode (address)
.var ECM_ADDR = $D011  // extended background mode (address)
.var VIC2_ECM_MASK = %01000000  // extended background mode (bit mask)
.var ECM_MASK = %01000000  // extended background mode (bit mask)
.var VIC2_RC_ADDR = $D011  // raster compare bit 8 (address)
.var RC_ADDR = $D011  // raster compare bit 8 (address)
.var VIC2_RC_MASK = %10000000  // raster compare bit 8 (bit mask)
.var RC_MASK = %10000000  // raster compare bit 8 (bit mask)
.var VIC2_RC = $D012  // raster compare bits 0 to 7
.var RC = $D012  // raster compare bits 0 to 7
.var VIC2_LPX = $D013  // Coarse horizontal beam position (was lightpen X)
.var LPX = $D013  // Coarse horizontal beam position (was lightpen X)
.var VIC2_LPY = $D014  // Coarse vertical beam position (was lightpen Y)
.var LPY = $D014  // Coarse vertical beam position (was lightpen Y)
.var VIC2_SE = $D015  // sprite enable bits
.var SE = $D015  // sprite enable bits
.var VIC2_XSCL_ADDR = $D016  // horizontal smooth scroll (address)
.var XSCL_ADDR = $D016  // horizontal smooth scroll (address)
.var VIC2_XSCL_MASK = %00000111  // horizontal smooth scroll (bit mask)
.var XSCL_MASK = %00000111  // horizontal smooth scroll (bit mask)
.var VIC2_CSEL_ADDR = $D016  // 38/40 column select (address)
.var CSEL_ADDR = $D016  // 38/40 column select (address)
.var VIC2_CSEL_MASK = %00001000  // 38/40 column select (bit mask)
.var CSEL_MASK = %00001000  // 38/40 column select (bit mask)
.var VIC2_MCM_ADDR = $D016  // Multi-colour mode (address)
.var MCM_ADDR = $D016  // Multi-colour mode (address)
.var VIC2_MCM_MASK = %00010000  // Multi-colour mode (bit mask)
.var MCM_MASK = %00010000  // Multi-colour mode (bit mask)
.var VIC2_RST_ADDR = $D016  // Disables video output on MAX Machine(tm) VIC-II 6566. Ignored on normal C64s and the MEGA65 (address)
.var VIC2_RST_MASK = %00100000  // Disables video output on MAX Machine(tm) VIC-II 6566. Ignored on normal C64s and the MEGA65 (bit mask)
.var VIC2_SEXY = $D017  // sprite vertical expansion enable bits
.var SEXY = $D017  // sprite vertical expansion enable bits
.var VIC2_CB_ADDR = $D018  // character set address location ($\times$ 1KiB) (address)
.var CB_ADDR = $D018  // character set address location ($\times$ 1KiB) (address)
.var VIC2_CB_MASK = %00001110  // character set address location ($\times$ 1KiB) (bit mask)
.var CB_MASK = %00001110  // character set address location ($\times$ 1KiB) (bit mask)
.var VIC2_VS_ADDR = $D018  // screen address ($\times$ 1KiB) (address)
.var VS_ADDR = $D018  // screen address ($\times$ 1KiB) (address)
.var VIC2_VS_MASK = %11110000  // screen address ($\times$ 1KiB) (bit mask)
.var VS_MASK = %11110000  // screen address ($\times$ 1KiB) (bit mask)
.var VIC2_RIRQ_ADDR = $D019  // raster compare indicate or acknowledge (address)
.var RIRQ_ADDR = $D019  // raster compare indicate or acknowledge (address)
.var VIC2_RIRQ_MASK = %00000001  // raster compare indicate or acknowledge (bit mask)
.var RIRQ_MASK = %00000001  // raster compare indicate or acknowledge (bit mask)
.var VIC2_ISBC_ADDR = $D019  // sprite:bitmap collision indicate or acknowledge (address)
.var ISBC_ADDR = $D019  // sprite:bitmap collision indicate or acknowledge (address)
.var VIC2_ISBC_MASK = %00000010  // sprite:bitmap collision indicate or acknowledge (bit mask)
.var ISBC_MASK = %00000010  // sprite:bitmap collision indicate or acknowledge (bit mask)
.var VIC2_ISSC_ADDR = $D019  // sprite:sprite collision indicate or acknowledge (address)
.var ISSC_ADDR = $D019  // sprite:sprite collision indicate or acknowledge (address)
.var VIC2_ISSC_MASK = %00000100  // sprite:sprite collision indicate or acknowledge (bit mask)
.var ISSC_MASK = %00000100  // sprite:sprite collision indicate or acknowledge (bit mask)
.var VIC2_ILP_ADDR = $D019  // light pen indicate or acknowledge (address)
.var ILP_ADDR = $D019  // light pen indicate or acknowledge (address)
.var VIC2_ILP_MASK = %00001000  // light pen indicate or acknowledge (bit mask)
.var ILP_MASK = %00001000  // light pen indicate or acknowledge (bit mask)
.var VIC2_MRIRQ_ADDR = $D01A  // mask raster IRQ (address)
.var MRIRQ_ADDR = $D01A  // mask raster IRQ (address)
.var VIC2_MRIRQ_MASK = %00000001  // mask raster IRQ (bit mask)
.var MRIRQ_MASK = %00000001  // mask raster IRQ (bit mask)
.var VIC2_MISBC_ADDR = $D01A  // mask sprite:bitmap collision IRQ (address)
.var MISBC_ADDR = $D01A  // mask sprite:bitmap collision IRQ (address)
.var VIC2_MISBC_MASK = %00000010  // mask sprite:bitmap collision IRQ (bit mask)
.var MISBC_MASK = %00000010  // mask sprite:bitmap collision IRQ (bit mask)
.var VIC2_MISSC_ADDR = $D01A  // mask sprite:sprite collision IRQ (address)
.var MISSC_ADDR = $D01A  // mask sprite:sprite collision IRQ (address)
.var VIC2_MISSC_MASK = %00000100  // mask sprite:sprite collision IRQ (bit mask)
.var MISSC_MASK = %00000100  // mask sprite:sprite collision IRQ (bit mask)
.var VIC2_BSP = $D01B  // sprite background priority bits
.var BSP = $D01B  // sprite background priority bits
.var VIC2_SCM = $D01C  // sprite multicolour enable bits
.var SCM = $D01C  // sprite multicolour enable bits
.var VIC2_SEXX = $D01D  // sprite horizontal expansion enable bits
.var SEXX = $D01D  // sprite horizontal expansion enable bits
.var VIC2_SSC = $D01E  // sprite/sprite collision indicate bits
.var SSC = $D01E  // sprite/sprite collision indicate bits
.var VIC2_SBC = $D01F  // sprite/foreground collision indicate bits
.var _SBC = $D01F  // sprite/foreground collision indicate bits
.var VIC2_BORDERCOL_ADDR = $D020  // display border colour (16 colour) (address)
.var VIC2_BORDERCOL_MASK = %00001111  // display border colour (16 colour) (bit mask)
.var VIC3_BORDERCOL_ADDR = $D020  // display border colour (256 colour) (address)
.var VIC3_BORDERCOL_MASK = %11111111  // display border colour (256 colour) (bit mask)
.var VIC4_BORDERCOL_ADDR = $D020  // display border colour (256 colour) (address)
.var VIC4_BORDERCOL_MASK = %11111111  // display border colour (256 colour) (bit mask)
.var VIC2_SCREENCOL_ADDR = $D021  // screen colour (16 colour) (address)
.var VIC2_SCREENCOL_MASK = %00001111  // screen colour (16 colour) (bit mask)
.var VIC3_SCREENCOL_ADDR = $D021  // screen colour (256 colour) (address)
.var VIC3_SCREENCOL_MASK = %11111111  // screen colour (256 colour) (bit mask)
.var VIC4_SCREENCOL_ADDR = $D021  // screen colour (256 colour) (address)
.var VIC4_SCREENCOL_MASK = %11111111  // screen colour (256 colour) (bit mask)
.var VIC2_MC1_ADDR = $D022  // multi-colour 1 (16 colour) (address)
.var VIC2_MC1_MASK = %00001111  // multi-colour 1 (16 colour) (bit mask)
.var VIC3_MC1_ADDR = $D022  // multi-colour 1 (256 colour) (address)
.var VIC3_MC1_MASK = %11111111  // multi-colour 1 (256 colour) (bit mask)
.var VIC4_MC1_ADDR = $D022  // multi-colour 1 (256 colour) (address)
.var VIC4_MC1_MASK = %11111111  // multi-colour 1 (256 colour) (bit mask)
.var VIC2_MC2_ADDR = $D023  // multi-colour 2 (16 colour) (address)
.var VIC2_MC2_MASK = %00001111  // multi-colour 2 (16 colour) (bit mask)
.var VIC3_MC2_ADDR = $D023  // multi-colour 2 (256 colour) (address)
.var VIC3_MC2_MASK = %11111111  // multi-colour 2 (256 colour) (bit mask)
.var VIC4_MC2_ADDR = $D023  // multi-colour 2 (256 colour) (address)
.var VIC4_MC2_MASK = %11111111  // multi-colour 2 (256 colour) (bit mask)
.var VIC2_MC3_ADDR = $D024  // multi-colour 3 (16 colour) (address)
.var VIC2_MC3_MASK = %00001111  // multi-colour 3 (16 colour) (bit mask)
.var VIC3_MC3_ADDR = $D024  // multi-colour 3 (256 colour) (address)
.var VIC3_MC3_MASK = %11111111  // multi-colour 3 (256 colour) (bit mask)
.var VIC4_MC3_ADDR = $D024  // multi-colour 3 (256 colour) (address)
.var VIC4_MC3_MASK = %11111111  // multi-colour 3 (256 colour) (bit mask)
.var VIC2_SPRMC0 = $D025  // Sprite multi-colour 0
.var VIC3_SPRMC0 = $D025  // Sprite multi-colour 0 (8-bit for selection of any palette colour)
.var VIC4_SPRMC0 = $D025  // Sprite multi-colour 0 (8-bit for selection of any palette colour)
.var VIC2_SPRMC1 = $D026  // Sprite multi-colour 1
.var VIC3_SPRMC1 = $D026  // Sprite multi-colour 1 (8-bit for selection of any palette colour)
.var VIC4_SPRMC1 = $D026  // Sprite multi-colour 1 (8-bit for selection of any palette colour)
.var VIC2_SPR0COL = $D027  // sprite N colour / 16-colour sprite transparency colour (lower nybl)
.var SPR0COL = $D027  // sprite N colour / 16-colour sprite transparency colour (lower nybl)
.var VIC2_SPR1COL = $D028  // @SPRNCOL
.var SPR1COL = $D028  // @SPRNCOL
.var VIC2_SPR2COL = $D029  // @SPRNCOL
.var SPR2COL = $D029  // @SPRNCOL
.var VIC2_SPR3COL = $D02A  // @SPRNCOL
.var SPR3COL = $D02A  // @SPRNCOL
.var VIC2_SPR4COL = $D02B  // @SPRNCOL
.var SPR4COL = $D02B  // @SPRNCOL
.var VIC2_SPR5COL = $D02C  // @SPRNCOL
.var SPR5COL = $D02C  // @SPRNCOL
.var VIC2_SPR6COL = $D02D  // @SPRNCOL
.var SPR6COL = $D02D  // @SPRNCOL
.var VIC2_SPR7COL = $D02E  // @SPRNCOL
.var SPR7COL = $D02E  // @SPRNCOL
.var VIC3_KEY = $D02F  // Write $A5 then $96 to enable C65/VIC-III IO registers
.var VIC4_KEY = $D02F  // Write $45 then $54 to map 45E100 ethernet controller buffers to $D000-$DFFF
.var GS_VIC4_KEY = $D02F  // Write $47 then $53 to enable C65GS/VIC-IV IO registers
.var SUMMARY_VIC_III = $D030  // Control Register A
.var VIC2_C128_FAST_ADDR = $D030  // 2MHz select (for C128 2MHz emulation) (address)
.var C128_FAST_ADDR = $D030  // 2MHz select (for C128 2MHz emulation) (address)
.var VIC2_C128_FAST_MASK = %00000001  // 2MHz select (for C128 2MHz emulation) (bit mask)
.var C128_FAST_MASK = %00000001  // 2MHz select (for C128 2MHz emulation) (bit mask)
.var VIC3_CRAM2K_ADDR = $D030  // Map 2nd KB of colour RAM @ $DC00-$DFFF (address)
.var CRAM2K_ADDR = $D030  // Map 2nd KB of colour RAM @ $DC00-$DFFF (address)
.var VIC3_CRAM2K_MASK = %00000001  // Map 2nd KB of colour RAM @ $DC00-$DFFF (bit mask)
.var CRAM2K_MASK = %00000001  // Map 2nd KB of colour RAM @ $DC00-$DFFF (bit mask)
.var VIC3_EXTSYNC_ADDR = $D030  // Enable external video sync (genlock input) (address)
.var EXTSYNC_ADDR = $D030  // Enable external video sync (genlock input) (address)
.var VIC3_EXTSYNC_MASK = %00000010  // Enable external video sync (genlock input) (bit mask)
.var EXTSYNC_MASK = %00000010  // Enable external video sync (genlock input) (bit mask)
.var VIC3_PAL_ADDR = $D030  // Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (address)
.var PAL_ADDR = $D030  // Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (address)
.var VIC3_PAL_MASK = %00000100  // Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (bit mask)
.var PAL_MASK = %00000100  // Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (bit mask)
.var VIC3_ROM8_ADDR = $D030  // Map C65 ROM @ $8000 (address)
.var ROM8_ADDR = $D030  // Map C65 ROM @ $8000 (address)
.var VIC3_ROM8_MASK = %00001000  // Map C65 ROM @ $8000 (bit mask)
.var ROM8_MASK = %00001000  // Map C65 ROM @ $8000 (bit mask)
.var VIC3_ROMA_ADDR = $D030  // Map C65 ROM @ $A000 (address)
.var ROMA_ADDR = $D030  // Map C65 ROM @ $A000 (address)
.var VIC3_ROMA_MASK = %00010000  // Map C65 ROM @ $A000 (bit mask)
.var ROMA_MASK = %00010000  // Map C65 ROM @ $A000 (bit mask)
.var VIC3_ROMC_ADDR = $D030  // Map C65 ROM @ $C000 (address)
.var ROMC_ADDR = $D030  // Map C65 ROM @ $C000 (address)
.var VIC3_ROMC_MASK = %00100000  // Map C65 ROM @ $C000 (bit mask)
.var ROMC_MASK = %00100000  // Map C65 ROM @ $C000 (bit mask)
.var VIC3_CROM9_ADDR = $D030  // Select between C64 and C65 charset. (address)
.var CROM9_ADDR = $D030  // Select between C64 and C65 charset. (address)
.var VIC3_CROM9_MASK = %01000000  // Select between C64 and C65 charset. (bit mask)
.var CROM9_MASK = %01000000  // Select between C64 and C65 charset. (bit mask)
.var VIC3_ROME_ADDR = $D030  // Map C65 ROM @ $E000 (address)
.var ROME_ADDR = $D030  // Map C65 ROM @ $E000 (address)
.var VIC3_ROME_MASK = %10000000  // Map C65 ROM @ $E000 (bit mask)
.var ROME_MASK = %10000000  // Map C65 ROM @ $E000 (bit mask)
.var C65_SUMMARY_VIC_III = $D031  // Control Register B
.var VIC3_INT_ADDR = $D031  // Enable VIC-III interlaced mode (address)
.var INT_ADDR = $D031  // Enable VIC-III interlaced mode (address)
.var VIC3_INT_MASK = %00000001  // Enable VIC-III interlaced mode (bit mask)
.var INT_MASK = %00000001  // Enable VIC-III interlaced mode (bit mask)
.var VIC3_MONO_ADDR = $D031  // Enable VIC-III MONO video output (not implemented) (address)
.var MONO_ADDR = $D031  // Enable VIC-III MONO video output (not implemented) (address)
.var VIC3_MONO_MASK = %00000010  // Enable VIC-III MONO video output (not implemented) (bit mask)
.var MONO_MASK = %00000010  // Enable VIC-III MONO video output (not implemented) (bit mask)
.var VIC3_H1280_ADDR = $D031  // Enable 1280 horizontal pixels (not implemented) (address)
.var H1280_ADDR = $D031  // Enable 1280 horizontal pixels (not implemented) (address)
.var VIC3_H1280_MASK = %00000100  // Enable 1280 horizontal pixels (not implemented) (bit mask)
.var H1280_MASK = %00000100  // Enable 1280 horizontal pixels (not implemented) (bit mask)
.var VIC3_V400_ADDR = $D031  // Enable 400 vertical pixels (address)
.var V400_ADDR = $D031  // Enable 400 vertical pixels (address)
.var VIC3_V400_MASK = %00001000  // Enable 400 vertical pixels (bit mask)
.var V400_MASK = %00001000  // Enable 400 vertical pixels (bit mask)
.var VIC3_BPM_ADDR = $D031  // Bit-Plane Mode (address)
.var BPM_ADDR = $D031  // Bit-Plane Mode (address)
.var VIC3_BPM_MASK = %00010000  // Bit-Plane Mode (bit mask)
.var BPM_MASK = %00010000  // Bit-Plane Mode (bit mask)
.var VIC3_ATTR_ADDR = $D031  // Enable extended attributes and 8 bit colour entries (address)
.var ATTR_ADDR = $D031  // Enable extended attributes and 8 bit colour entries (address)
.var VIC3_ATTR_MASK = %00100000  // Enable extended attributes and 8 bit colour entries (bit mask)
.var ATTR_MASK = %00100000  // Enable extended attributes and 8 bit colour entries (bit mask)
.var VIC3_FAST_ADDR = $D031  // Enable C65 FAST mode (~3.5MHz) (address)
.var FAST_ADDR = $D031  // Enable C65 FAST mode (~3.5MHz) (address)
.var VIC3_FAST_MASK = %01000000  // Enable C65 FAST mode (~3.5MHz) (bit mask)
.var FAST_MASK = %01000000  // Enable C65 FAST mode (~3.5MHz) (bit mask)
.var VIC3_H640_ADDR = $D031  // Enable C64 640 horizontal pixels / 80 column mode (address)
.var H640_ADDR = $D031  // Enable C64 640 horizontal pixels / 80 column mode (address)
.var VIC3_H640_MASK = %10000000  // Enable C64 640 horizontal pixels / 80 column mode (bit mask)
.var H640_MASK = %10000000  // Enable C64 640 horizontal pixels / 80 column mode (bit mask)
.var VIC3_B0ADEVN_ADDR = $D033  // Bitplane X address, even lines (address)
.var B0ADEVN_ADDR = $D033  // Bitplane X address, even lines (address)
.var VIC3_B0ADEVN_MASK = %00001110  // Bitplane X address, even lines (bit mask)
.var B0ADEVN_MASK = %00001110  // Bitplane X address, even lines (bit mask)
.var VIC3_B0ADODD_ADDR = $D033  // Bitplane X address, odd lines (address)
.var B0ADODD_ADDR = $D033  // Bitplane X address, odd lines (address)
.var VIC3_B0ADODD_MASK = %11100000  // Bitplane X address, odd lines (bit mask)
.var B0ADODD_MASK = %11100000  // Bitplane X address, odd lines (bit mask)
.var VIC3_B1ADEVN_ADDR = $D034  // @BXADEVN (address)
.var B1ADEVN_ADDR = $D034  // @BXADEVN (address)
.var VIC3_B1ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var B1ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var VIC3_B1ADODD_ADDR = $D034  // @BXADODD (address)
.var B1ADODD_ADDR = $D034  // @BXADODD (address)
.var VIC3_B1ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var B1ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var VIC3_B2ADEVN_ADDR = $D035  // @BXADEVN (address)
.var B2ADEVN_ADDR = $D035  // @BXADEVN (address)
.var VIC3_B2ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var B2ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var VIC3_B2ADODD_ADDR = $D035  // @BXADODD (address)
.var B2ADODD_ADDR = $D035  // @BXADODD (address)
.var VIC3_B2ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var B2ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var VIC3_B3ADEVN_ADDR = $D036  // @BXADEVN (address)
.var B3ADEVN_ADDR = $D036  // @BXADEVN (address)
.var VIC3_B3ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var B3ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var VIC3_B3ADODD_ADDR = $D036  // @BXADODD (address)
.var B3ADODD_ADDR = $D036  // @BXADODD (address)
.var VIC3_B3ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var B3ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var VIC3_B4ADEVN_ADDR = $D037  // @BXADEVN (address)
.var B4ADEVN_ADDR = $D037  // @BXADEVN (address)
.var VIC3_B4ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var B4ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var VIC3_B4ADODD_ADDR = $D037  // @BXADODD (address)
.var B4ADODD_ADDR = $D037  // @BXADODD (address)
.var VIC3_B4ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var B4ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var VIC3_B5ADEVN_ADDR = $D038  // @BXADEVN (address)
.var B5ADEVN_ADDR = $D038  // @BXADEVN (address)
.var VIC3_B5ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var B5ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var VIC3_B5ADODD_ADDR = $D038  // @BXADODD (address)
.var B5ADODD_ADDR = $D038  // @BXADODD (address)
.var VIC3_B5ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var B5ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var VIC3_B6ADEVN_ADDR = $D039  // @BXADEVN (address)
.var B6ADEVN_ADDR = $D039  // @BXADEVN (address)
.var VIC3_B6ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var B6ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var VIC3_B6ADODD_ADDR = $D039  // @BXADODD (address)
.var B6ADODD_ADDR = $D039  // @BXADODD (address)
.var VIC3_B6ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var B6ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var VIC3_B7ADEVN_ADDR = $D03A  // @BXADEVN (address)
.var B7ADEVN_ADDR = $D03A  // @BXADEVN (address)
.var VIC3_B7ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var B7ADEVN_MASK = %00001110  // @BXADEVN (bit mask)
.var VIC3_B7ADODD_ADDR = $D03A  // @BXADODD (address)
.var B7ADODD_ADDR = $D03A  // @BXADODD (address)
.var VIC3_B7ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var B7ADODD_MASK = %11100000  // @BXADODD (bit mask)
.var VIC3_BPCOMP = $D03B  // Complement bitplane flags
.var BPCOMP = $D03B  // Complement bitplane flags
.var VIC3_BPX = $D03C  // Bitplane X
.var BPX = $D03C  // Bitplane X
.var VIC3_BPY = $D03D  // Bitplane Y
.var BPY = $D03D  // Bitplane Y
.var VIC3_HPOS = $D03E  // Bitplane X Offset
.var HPOS = $D03E  // Bitplane X Offset
.var VIC3_VPOS = $D03F  // Bitplane Y Offset
.var VPOS = $D03F  // Bitplane Y Offset
.var VIC3_B0PIX = $D040  // Display Address Translater (DAT) Bitplane N port
.var B0PIX = $D040  // Display Address Translater (DAT) Bitplane N port
.var VIC3_B1PIX = $D041  // @BNPIX
.var B1PIX = $D041  // @BNPIX
.var VIC3_B2PIX = $D042  // @BNPIX
.var B2PIX = $D042  // @BNPIX
.var VIC3_B3PIX = $D043  // @BNPIX
.var B3PIX = $D043  // @BNPIX
.var VIC3_B4PIX = $D044  // @BNPIX
.var B4PIX = $D044  // @BNPIX
.var VIC3_B5PIX = $D045  // @BNPIX
.var B5PIX = $D045  // @BNPIX
.var VIC3_B6PIX = $D046  // @BNPIX
.var B6PIX = $D046  // @BNPIX
.var VIC3_B7PIX = $D047  // @BNPIX
.var B7PIX = $D047  // @BNPIX
.var VIC4_TBDRPOS = $D048  // top border position
.var TBDRPOS = $D048  // top border position
.var VIC4_TBDRPOS_ADDR = $D049  // top border position MSB (address)
.var TBDRPOS_ADDR = $D049  // top border position MSB (address)
.var VIC4_TBDRPOS_MASK = %00001111  // top border position MSB (bit mask)
.var TBDRPOS_MASK = %00001111  // top border position MSB (bit mask)
.var VIC4_SPRBPMEN_ADDR = $D049  // Sprite bitplane-modify-mode enables (address)
.var VIC4_SPRBPMEN_MASK = %11110000  // Sprite bitplane-modify-mode enables (bit mask)
.var VIC4_BBDRPOS = $D04A  // bottom border position
.var BBDRPOS = $D04A  // bottom border position
.var VIC4_BBDRPOS_ADDR = $D04B  // bottom border position (address)
.var BBDRPOS_ADDR = $D04B  // bottom border position (address)
.var VIC4_BBDRPOS_MASK = %00001111  // bottom border position (bit mask)
.var BBDRPOS_MASK = %00001111  // bottom border position (bit mask)
.var GS_VIC4_SPRBPMEN_ADDR = $D04B  // Sprite bitplane-modify-mode enables (address)
.var GS_VIC4_SPRBPMEN_MASK = %11110000  // Sprite bitplane-modify-mode enables (bit mask)
.var VIC4_TEXTXPOS = $D04C  // character generator horizontal position
.var TEXTXPOS = $D04C  // character generator horizontal position
.var VIC4_TEXTXPOS_ADDR = $D04D  // character generator horizontal position (address)
.var TEXTXPOS_ADDR = $D04D  // character generator horizontal position (address)
.var VIC4_TEXTXPOS_MASK = %00001111  // character generator horizontal position (bit mask)
.var TEXTXPOS_MASK = %00001111  // character generator horizontal position (bit mask)
.var VIC4_SPRTILEN_ADDR = $D04D  // Sprite horizontal tile enables. (address)
.var VIC4_SPRTILEN_MASK = %11110000  // Sprite horizontal tile enables. (bit mask)
.var VIC4_TEXTYPOS = $D04E  // Character generator vertical position
.var TEXTYPOS = $D04E  // Character generator vertical position
.var VIC4_TEXTYPOS_ADDR = $D04F  // Character generator vertical position (address)
.var TEXTYPOS_ADDR = $D04F  // Character generator vertical position (address)
.var VIC4_TEXTYPOS_MASK = %00001111  // Character generator vertical position (bit mask)
.var TEXTYPOS_MASK = %00001111  // Character generator vertical position (bit mask)
.var GS_VIC4_SPRTILEN_ADDR = $D04F  // Sprite 7-4 horizontal tile enables (address)
.var GS_VIC4_SPRTILEN_MASK = %11110000  // Sprite 7-4 horizontal tile enables (bit mask)
.var VIC4_XPOSLSB = $D050  // Read horizontal raster scan position LSB
.var XPOSLSB = $D050  // Read horizontal raster scan position LSB
.var VIC4_XPOSMSB_ADDR = $D051  // Read horizontal raster scan position MSB (address)
.var XPOSMSB_ADDR = $D051  // Read horizontal raster scan position MSB (address)
.var VIC4_XPOSMSB_MASK = %00111111  // Read horizontal raster scan position MSB (bit mask)
.var XPOSMSB_MASK = %00111111  // Read horizontal raster scan position MSB (bit mask)
.var VIC4_DBLRR_ADDR = $D051  // When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (address)
.var DBLRR_ADDR = $D051  // When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (address)
.var VIC4_DBLRR_MASK = %01000000  // When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (bit mask)
.var DBLRR_MASK = %01000000  // When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (bit mask)
.var VIC4_NORRDEL_ADDR = $D051  // When clear, raster rewrite double buffering is used (address)
.var NORRDEL_ADDR = $D051  // When clear, raster rewrite double buffering is used (address)
.var VIC4_NORRDEL_MASK = %10000000  // When clear, raster rewrite double buffering is used (bit mask)
.var NORRDEL_MASK = %10000000  // When clear, raster rewrite double buffering is used (bit mask)
.var VIC4_FNRASTERLSB = $D052  // Read physical raster position
.var FNRASTERLSB = $D052  // Read physical raster position
.var VIC4_FN_RASTER_MSB_ADDR = $D053  // Read physical raster position (address)
.var FN_RASTER_MSB_ADDR = $D053  // Read physical raster position (address)
.var VIC4_FN_RASTER_MSB_MASK = %00000111  // Read physical raster position (bit mask)
.var FN_RASTER_MSB_MASK = %00000111  // Read physical raster position (bit mask)
.var VIC4_SHDEMU_ADDR = $D053  // Enable simulated shadow-mask (PALEMU must also be enabled) (address)
.var SHDEMU_ADDR = $D053  // Enable simulated shadow-mask (PALEMU must also be enabled) (address)
.var VIC4_SHDEMU_MASK = %01000000  // Enable simulated shadow-mask (PALEMU must also be enabled) (bit mask)
.var SHDEMU_MASK = %01000000  // Enable simulated shadow-mask (PALEMU must also be enabled) (bit mask)
.var VIC4_FNRST_ADDR = $D053  // Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (address)
.var FNRST_ADDR = $D053  // Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (address)
.var VIC4_FNRST_MASK = %10000000  // Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (bit mask)
.var FNRST_MASK = %10000000  // Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (bit mask)
.var SUMMARY_VIC_IV = $D054  // Control register C
.var VIC_IV = $D054  // Control register C
.var VIC4_CHR16_ADDR = $D054  // enable 16-bit character numbers (two screen bytes per character) (address)
.var CHR16_ADDR = $D054  // enable 16-bit character numbers (two screen bytes per character) (address)
.var VIC4_CHR16_MASK = %00000001  // enable 16-bit character numbers (two screen bytes per character) (bit mask)
.var CHR16_MASK = %00000001  // enable 16-bit character numbers (two screen bytes per character) (bit mask)
.var VIC4_FCLRLO_ADDR = $D054  // enable full-colour mode for character numbers <=$FF (address)
.var FCLRLO_ADDR = $D054  // enable full-colour mode for character numbers <=$FF (address)
.var VIC4_FCLRLO_MASK = %00000010  // enable full-colour mode for character numbers <=$FF (bit mask)
.var FCLRLO_MASK = %00000010  // enable full-colour mode for character numbers <=$FF (bit mask)
.var VIC4_FCLRHI_ADDR = $D054  // enable full-colour mode for character numbers >$FF (address)
.var FCLRHI_ADDR = $D054  // enable full-colour mode for character numbers >$FF (address)
.var VIC4_FCLRHI_MASK = %00000100  // enable full-colour mode for character numbers >$FF (bit mask)
.var FCLRHI_MASK = %00000100  // enable full-colour mode for character numbers >$FF (bit mask)
.var VIC4_SMTH_ADDR = $D054  // video output horizontal smoothing enable (address)
.var SMTH_ADDR = $D054  // video output horizontal smoothing enable (address)
.var VIC4_SMTH_MASK = %00001000  // video output horizontal smoothing enable (bit mask)
.var SMTH_MASK = %00001000  // video output horizontal smoothing enable (bit mask)
.var VIC4_SPR640_ADDR = $D054  // Sprite H640 enable; (address)
.var SPR640_ADDR = $D054  // Sprite H640 enable; (address)
.var VIC4_SPR640_MASK = %00010000  // Sprite H640 enable; (bit mask)
.var SPR640_MASK = %00010000  // Sprite H640 enable; (bit mask)
.var VIC4_PALEMU_ADDR = $D054  // Enable PAL CRT-like scan-line emulation (address)
.var PALEMU_ADDR = $D054  // Enable PAL CRT-like scan-line emulation (address)
.var VIC4_PALEMU_MASK = %00100000  // Enable PAL CRT-like scan-line emulation (bit mask)
.var PALEMU_MASK = %00100000  // Enable PAL CRT-like scan-line emulation (bit mask)
.var VIC4_VFAST_ADDR = $D054  // C65GS FAST mode (48MHz) (address)
.var VFAST_ADDR = $D054  // C65GS FAST mode (48MHz) (address)
.var VIC4_VFAST_MASK = %01000000  // C65GS FAST mode (48MHz) (bit mask)
.var VFAST_MASK = %01000000  // C65GS FAST mode (48MHz) (bit mask)
.var VIC4_ALPHEN_ADDR = $D054  // Alpha compositor enable (address)
.var ALPHEN_ADDR = $D054  // Alpha compositor enable (address)
.var VIC4_ALPHEN_MASK = %10000000  // Alpha compositor enable (bit mask)
.var ALPHEN_MASK = %10000000  // Alpha compositor enable (bit mask)
.var VIC4_SPRHGTEN = $D055  // sprite extended height enable (one bit per sprite)
.var SPRHGTEN = $D055  // sprite extended height enable (one bit per sprite)
.var VIC4_SPRHGHT = $D056  // Sprite extended height size (sprite pixels high)
.var SPRHGHT = $D056  // Sprite extended height size (sprite pixels high)
.var VIC4_SPRX64EN = $D057  // Sprite extended width enables (8 bytes per sprite row = 64 pixels wide for normal sprites or 16 pixels wide for 16-colour sprite mode)
.var SPRX64EN = $D057  // Sprite extended width enables (8 bytes per sprite row = 64 pixels wide for normal sprites or 16 pixels wide for 16-colour sprite mode)
.var VIC4_LINESTEPLSB = $D058  // number of bytes to advance between each text row (LSB)
.var LINESTEPLSB = $D058  // number of bytes to advance between each text row (LSB)
.var VIC4_LINESTEPMSB = $D059  // number of bytes to advance between each text row (MSB)
.var LINESTEPMSB = $D059  // number of bytes to advance between each text row (MSB)
.var VIC4_CHRXSCL = $D05A  // Horizontal hardware scale of text mode (pixel 120ths per pixel)
.var CHRXSCL = $D05A  // Horizontal hardware scale of text mode (pixel 120ths per pixel)
.var VIC4_CHRYSCL = $D05B  // Vertical scaling of text mode (number of physical rasters per char text row)
.var CHRYSCL = $D05B  // Vertical scaling of text mode (number of physical rasters per char text row)
.var VIC4_SDBDRWD_LSB = $D05C  // Width of single side border (LSB)
.var SDBDRWD_LSB = $D05C  // Width of single side border (LSB)
.var VIC4_SDBDRWD_MSB_ADDR = $D05D  // side border width (MSB) (address)
.var SDBDRWD_MSB_ADDR = $D05D  // side border width (MSB) (address)
.var VIC4_SDBDRWD_MSB_MASK = %00111111  // side border width (MSB) (bit mask)
.var SDBDRWD_MSB_MASK = %00111111  // side border width (MSB) (bit mask)
.var VIC4_RST_DELEN_ADDR = $D05D  // Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (address)
.var RST_DELEN_ADDR = $D05D  // Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (address)
.var VIC4_RST_DELEN_MASK = %01000000  // Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (bit mask)
.var RST_DELEN_MASK = %01000000  // Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (bit mask)
.var VIC4_HOTREG_ADDR = $D05D  // Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (address)
.var HOTREG_ADDR = $D05D  // Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (address)
.var VIC4_HOTREG_MASK = %10000000  // Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (bit mask)
.var HOTREG_MASK = %10000000  // Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (bit mask)
.var VIC4_CHRCOUNT = $D05E  // Number of characters to display per row (LSB)
.var CHRCOUNT = $D05E  // Number of characters to display per row (LSB)
.var VIC4_SPRXSMSBS = $D05F  // Sprite H640 X Super-MSBs
.var SPRXSMSBS = $D05F  // Sprite H640 X Super-MSBs
.var VIC4_SCRNPTRLSB = $D060  // screen RAM precise base address (bits 0 - 7)
.var SCRNPTRLSB = $D060  // screen RAM precise base address (bits 0 - 7)
.var VIC4_SCRNPTRMSB = $D061  // screen RAM precise base address (bits 15 - 8)
.var SCRNPTRMSB = $D061  // screen RAM precise base address (bits 15 - 8)
.var VIC4_SCRNPTRBNK = $D062  // screen RAM precise base address (bits 23 - 16)
.var SCRNPTRBNK = $D062  // screen RAM precise base address (bits 23 - 16)
.var VIC4_SCRNPTRMB_ADDR = $D063  // screen RAM precise base address (bits 31 - 24) (address)
.var SCRNPTRMB_ADDR = $D063  // screen RAM precise base address (bits 31 - 24) (address)
.var VIC4_SCRNPTRMB_MASK = %00001111  // screen RAM precise base address (bits 31 - 24) (bit mask)
.var SCRNPTRMB_MASK = %00001111  // screen RAM precise base address (bits 31 - 24) (bit mask)
.var VIC4_CHRCOUNT_ADDR = $D063  // Number of characters to display per (address)
.var CHRCOUNT_ADDR = $D063  // Number of characters to display per (address)
.var VIC4_CHRCOUNT_MASK = %00110000  // Number of characters to display per (bit mask)
.var CHRCOUNT_MASK = %00110000  // Number of characters to display per (bit mask)
.var VIC4_EXGLYPH_ADDR = $D063  // source full-colour character data from expansion RAM (address)
.var EXGLYPH_ADDR = $D063  // source full-colour character data from expansion RAM (address)
.var VIC4_EXGLYPH_MASK = %10000000  // source full-colour character data from expansion RAM (bit mask)
.var EXGLYPH_MASK = %10000000  // source full-colour character data from expansion RAM (bit mask)
.var VIC4_COLPTRLSB = $D064  // colour RAM base address (bits 0 - 7)
.var COLPTRLSB = $D064  // colour RAM base address (bits 0 - 7)
.var VIC4_COLPTRMSB = $D065  // colour RAM base address (bits 15 - 8)
.var COLPTRMSB = $D065  // colour RAM base address (bits 15 - 8)
.var DEBUG_SBPDEBUG = $D067  // Sprite/bitplane first X DEBUG WILL BE REMOVED
.var SBPDEBUG = $D067  // Sprite/bitplane first X DEBUG WILL BE REMOVED
.var VIC4_CHARPTRLSB = $D068  // Character set precise base address (bits 0 - 7)
.var CHARPTRLSB = $D068  // Character set precise base address (bits 0 - 7)
.var VIC4_CHARPTRMSB = $D069  // Character set precise base address (bits 15 - 8)
.var CHARPTRMSB = $D069  // Character set precise base address (bits 15 - 8)
.var VIC4_CHARPTRBNK = $D06A  // Character set precise base address (bits 23 - 16)
.var CHARPTRBNK = $D06A  // Character set precise base address (bits 23 - 16)
.var VIC4_SPR16EN = $D06B  // sprite 16-colour mode enables
.var SPR16EN = $D06B  // sprite 16-colour mode enables
.var VIC4_SPRPTRADRLSB = $D06C  // sprite pointer address (bits 7 - 0)
.var SPRPTRADRLSB = $D06C  // sprite pointer address (bits 7 - 0)
.var VIC4_SPRPTRADRMSB = $D06D  // sprite pointer address (bits 15 - 8)
.var SPRPTRADRMSB = $D06D  // sprite pointer address (bits 15 - 8)
.var VIC4_SPRPTRBNK_ADDR = $D06E  // sprite pointer address (bits 23 - 16) (address)
.var SPRPTRBNK_ADDR = $D06E  // sprite pointer address (bits 23 - 16) (address)
.var VIC4_SPRPTRBNK_MASK = %01111111  // sprite pointer address (bits 23 - 16) (bit mask)
.var SPRPTRBNK_MASK = %01111111  // sprite pointer address (bits 23 - 16) (bit mask)
.var VIC4_SPR_PTR16_ADDR = $D06E  // 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (address)
.var SPR_PTR16_ADDR = $D06E  // 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (address)
.var VIC4_SPR_PTR16_MASK = %10000000  // 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (bit mask)
.var SPR_PTR16_MASK = %10000000  // 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (bit mask)
.var VIC4_RASLINE0_ADDR = $D06F  // first VIC-II raster line (address)
.var RASLINE0_ADDR = $D06F  // first VIC-II raster line (address)
.var VIC4_RASLINE0_MASK = %00111111  // first VIC-II raster line (bit mask)
.var RASLINE0_MASK = %00111111  // first VIC-II raster line (bit mask)
.var VIC4_VGAHDTV_ADDR = $D06F  // Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (address)
.var VGAHDTV_ADDR = $D06F  // Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (address)
.var VIC4_VGAHDTV_MASK = %01000000  // Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (bit mask)
.var VGAHDTV_MASK = %01000000  // Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (bit mask)
.var VIC4_PALNTSC_ADDR = $D06F  // NTSC emulation mode (max raster = 262) (address)
.var PALNTSC_ADDR = $D06F  // NTSC emulation mode (max raster = 262) (address)
.var VIC4_PALNTSC_MASK = %10000000  // NTSC emulation mode (max raster = 262) (bit mask)
.var PALNTSC_MASK = %10000000  // NTSC emulation mode (max raster = 262) (bit mask)
.var VIC4_ABTPALSEL_ADDR = $D070  // VIC-IV bitmap/text palette bank (alternate palette) (address)
.var ABTPALSEL_ADDR = $D070  // VIC-IV bitmap/text palette bank (alternate palette) (address)
.var VIC4_ABTPALSEL_MASK = %00000011  // VIC-IV bitmap/text palette bank (alternate palette) (bit mask)
.var ABTPALSEL_MASK = %00000011  // VIC-IV bitmap/text palette bank (alternate palette) (bit mask)
.var VIC4_SPRPALSEL_ADDR = $D070  // sprite palette bank (address)
.var SPRPALSEL_ADDR = $D070  // sprite palette bank (address)
.var VIC4_SPRPALSEL_MASK = %00001100  // sprite palette bank (bit mask)
.var SPRPALSEL_MASK = %00001100  // sprite palette bank (bit mask)
.var VIC4_BTPALSEL_ADDR = $D070  // bitmap/text palette bank (address)
.var BTPALSEL_ADDR = $D070  // bitmap/text palette bank (address)
.var VIC4_BTPALSEL_MASK = %00110000  // bitmap/text palette bank (bit mask)
.var BTPALSEL_MASK = %00110000  // bitmap/text palette bank (bit mask)
.var VIC4_MAPEDPAL_ADDR = $D070  // palette bank mapped at $D100-$D3FF (address)
.var MAPEDPAL_ADDR = $D070  // palette bank mapped at $D100-$D3FF (address)
.var VIC4_MAPEDPAL_MASK = %11000000  // palette bank mapped at $D100-$D3FF (bit mask)
.var MAPEDPAL_MASK = %11000000  // palette bank mapped at $D100-$D3FF (bit mask)
.var VIC4_BP16ENS = $D071  // VIC-IV 16-colour bitplane enable flags
.var BP16ENS = $D071  // VIC-IV 16-colour bitplane enable flags
.var VIC4_SPRYADJ = $D072  // Sprite Y position adjustment
.var SPRYADJ = $D072  // Sprite Y position adjustment
.var VIC4_ALPHADELAY_ADDR = $D073  // Alpha delay for compositor (address)
.var ALPHADELAY_ADDR = $D073  // Alpha delay for compositor (address)
.var VIC4_ALPHADELAY_MASK = %00001111  // Alpha delay for compositor (bit mask)
.var ALPHADELAY_MASK = %00001111  // Alpha delay for compositor (bit mask)
.var VIC4_RASTERHEIGHT_ADDR = $D073  // physical rasters per VIC-II raster (1 to 16) (address)
.var RASTERHEIGHT_ADDR = $D073  // physical rasters per VIC-II raster (1 to 16) (address)
.var VIC4_RASTERHEIGHT_MASK = %11110000  // physical rasters per VIC-II raster (1 to 16) (bit mask)
.var RASTERHEIGHT_MASK = %11110000  // physical rasters per VIC-II raster (1 to 16) (bit mask)
.var VIC4_SPRENALPHA = $D074  // Sprite alpha-blend enable
.var SPRENALPHA = $D074  // Sprite alpha-blend enable
.var VIC4_SPRALPHAVAL = $D075  // Sprite alpha-blend value
.var SPRALPHAVAL = $D075  // Sprite alpha-blend value
.var VIC4_SPRENV400 = $D076  // Sprite V400 enables
.var SPRENV400 = $D076  // Sprite V400 enables
.var VIC4_SRPYMSBS = $D077  // Sprite V400 Y position MSBs
.var SRPYMSBS = $D077  // Sprite V400 Y position MSBs
.var VIC4_SPRYSMSBS = $D078  // Sprite V400 Y position super MSBs
.var SPRYSMSBS = $D078  // Sprite V400 Y position super MSBs
.var VIC4_RSTCOMP = $D079  // Raster compare value
.var RSTCOMP = $D079  // Raster compare value
.var VIC4_RSTCMP_ADDR = $D07A  // Raster compare value MSB (address)
.var RSTCMP_ADDR = $D07A  // Raster compare value MSB (address)
.var VIC4_RSTCMP_MASK = %00000111  // Raster compare value MSB (bit mask)
.var RSTCMP_MASK = %00000111  // Raster compare value MSB (bit mask)
.var VIC4_SPTR_CONT_ADDR = $D07A  // Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (address)
.var SPTR_CONT_ADDR = $D07A  // Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (address)
.var VIC4_SPTR_CONT_MASK = %00001000  // Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (bit mask)
.var SPTR_CONT_MASK = %00001000  // Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (bit mask)
.var VIC4_RESV_ADDR = $D07A  // Reserved. (address)
.var VIC4_RESV_MASK = %00110000  // Reserved. (bit mask)
.var VIC4_EXTIRQS_ADDR = $D07A  // Enable additional IRQ sources, e.g., raster X position. (address)
.var EXTIRQS_ADDR = $D07A  // Enable additional IRQ sources, e.g., raster X position. (address)
.var VIC4_EXTIRQS_MASK = %01000000  // Enable additional IRQ sources, e.g., raster X position. (bit mask)
.var EXTIRQS_MASK = %01000000  // Enable additional IRQ sources, e.g., raster X position. (bit mask)
.var VIC4_FNRST_CMP_ADDR = $D07A  // Raster compare is in physical rasters if set, or VIC-II raster if clear (address)
.var FNRST_CMP_ADDR = $D07A  // Raster compare is in physical rasters if set, or VIC-II raster if clear (address)
.var VIC4_FNRST_CMP_MASK = %10000000  // Raster compare is in physical rasters if set, or VIC-II raster if clear (bit mask)
.var FNRST_CMP_MASK = %10000000  // Raster compare is in physical rasters if set, or VIC-II raster if clear (bit mask)
.var VIC4_Number = $D07B  // of text rows to display
.var Number = $D07B  // of text rows to display
.var VIC4_BIT_PBANK_ADDR = $D07C  // Set which 128KB bank bitplanes (address)
.var BIT_PBANK_ADDR = $D07C  // Set which 128KB bank bitplanes (address)
.var VIC4_BIT_PBANK_MASK = %00000111  // Set which 128KB bank bitplanes (bit mask)
.var BIT_PBANK_MASK = %00000111  // Set which 128KB bank bitplanes (bit mask)
.var GS_VIC4_RESV_ADDR = $D07C  // @RESV (address)
.var GS_VIC4_RESV_MASK = %00001000  // @RESV (bit mask)
.var VIC4_HSYNCP_ADDR = $D07C  // hsync polarity (address)
.var HSYNCP_ADDR = $D07C  // hsync polarity (address)
.var VIC4_HSYNCP_MASK = %00010000  // hsync polarity (bit mask)
.var HSYNCP_MASK = %00010000  // hsync polarity (bit mask)
.var VIC4_VSYNCP_ADDR = $D07C  // vsync polarity (address)
.var VSYNCP_ADDR = $D07C  // vsync polarity (address)
.var VIC4_VSYNCP_MASK = %00100000  // vsync polarity (bit mask)
.var VSYNCP_MASK = %00100000  // vsync polarity (bit mask)
.var VIC4_DEBUGC_ADDR = $D07C  // VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (address)
.var DEBUGC_ADDR = $D07C  // VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (address)
.var VIC4_DEBUGC_MASK = %11000000  // VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (bit mask)
.var DEBUGC_MASK = %11000000  // VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (bit mask)
.var DEBUG_DEBUGOUT = $D07D  // VIC-IV debug value read-back (read only)
.var DEBUGOUT = $D07D  // VIC-IV debug value read-back (read only)
.var DEBUG_DEBUGX = $D07D  // VIC-IV debug X position (LSB) (write only)
.var DEBUGX = $D07D  // VIC-IV debug X position (LSB) (write only)
.var DEBUG_DEBUGY = $D07E  // VIC-IV debug Y position (LSB)
.var DEBUGY = $D07E  // VIC-IV debug Y position (LSB)
.var DEBUG_DEBUGX_ADDR = $D07F  // VIC-IV debug X position (MSB) (address)
.var DEBUGX_ADDR = $D07F  // VIC-IV debug X position (MSB) (address)
.var DEBUG_DEBUGX_MASK = %00001111  // VIC-IV debug X position (MSB) (bit mask)
.var DEBUGX_MASK = %00001111  // VIC-IV debug X position (MSB) (bit mask)
.var DEBUG_DEBUGY_ADDR = $D07F  // VIC-IV debug Y position (MSB) (address)
.var DEBUGY_ADDR = $D07F  // VIC-IV debug Y position (MSB) (address)
.var DEBUG_DEBUGY_MASK = %11110000  // VIC-IV debug Y position (MSB) (bit mask)
.var DEBUGY_MASK = %11110000  // VIC-IV debug Y position (MSB) (bit mask)
.var DEBUG_DEBUGOOF_ADDR = $D07F  // VIC-IV debug out-of-frame signal enable (address)
.var DEBUGOOF_ADDR = $D07F  // VIC-IV debug out-of-frame signal enable (address)
.var DEBUG_DEBUGOOF_MASK = %10000000  // VIC-IV debug out-of-frame signal enable (bit mask)
.var DEBUGOOF_MASK = %10000000  // VIC-IV debug out-of-frame signal enable (bit mask)
.var FDC_DS_ADDR = $D080  // Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (address)
.var DS_ADDR = $D080  // Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (address)
.var FDC_DS_MASK = %00000111  // Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (bit mask)
.var DS_MASK = %00000111  // Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (bit mask)
.var FDC_SIDE_ADDR = $D080  // Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (address)
.var SIDE_ADDR = $D080  // Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (address)
.var FDC_SIDE_MASK = %00001000  // Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (bit mask)
.var SIDE_MASK = %00001000  // Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (bit mask)
.var FDC_SWAP_ADDR = $D080  // Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (address)
.var SWAP_ADDR = $D080  // Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (address)
.var FDC_SWAP_MASK = %00010000  // Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (bit mask)
.var SWAP_MASK = %00010000  // Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (bit mask)
.var FDC_MOTOR_ADDR = $D080  // Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (address)
.var MOTOR_ADDR = $D080  // Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (address)
.var FDC_MOTOR_MASK = %00100000  // Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (bit mask)
.var MOTOR_MASK = %00100000  // Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (bit mask)
.var FDC_LED_ADDR = $D080  // Drive LED blinks when set (address)
.var FDC_LED_MASK = %01000000  // Drive LED blinks when set (bit mask)
.var FDC_IRQ_ADDR = $D080  // When set, enables interrupts to occur. Clearing clears any pending interrupt and disables interrupts until set again. (address)
.var FDC_IRQ_MASK = %10000000  // When set, enables interrupts to occur. Clearing clears any pending interrupt and disables interrupts until set again. (bit mask)
.var FDC_COMMAND = $D081  // F011 FDC command register
.var FDC_NOBUF_ADDR = $D081  // Reset the sector buffer read/write pointers (address)
.var NOBUF_ADDR = $D081  // Reset the sector buffer read/write pointers (address)
.var FDC_NOBUF_MASK = %00000001  // Reset the sector buffer read/write pointers (bit mask)
.var NOBUF_MASK = %00000001  // Reset the sector buffer read/write pointers (bit mask)
.var FDC_ALT_ADDR = $D081  // Selects alternate DPLL read recovery method (not implemented) (address)
.var ALT_ADDR = $D081  // Selects alternate DPLL read recovery method (not implemented) (address)
.var FDC_ALT_MASK = %00000010  // Selects alternate DPLL read recovery method (not implemented) (bit mask)
.var ALT_MASK = %00000010  // Selects alternate DPLL read recovery method (not implemented) (bit mask)
.var FDC_ALGO_ADDR = $D081  // Selects reading and writing algorithm (currently ignored). (address)
.var ALGO_ADDR = $D081  // Selects reading and writing algorithm (currently ignored). (address)
.var FDC_ALGO_MASK = %00000100  // Selects reading and writing algorithm (currently ignored). (bit mask)
.var ALGO_MASK = %00000100  // Selects reading and writing algorithm (currently ignored). (bit mask)
.var FDC_DIR_ADDR = $D081  // Sets the stepping direction (inward vs (address)
.var DIR_ADDR = $D081  // Sets the stepping direction (inward vs (address)
.var FDC_DIR_MASK = %00001000  // Sets the stepping direction (inward vs (bit mask)
.var DIR_MASK = %00001000  // Sets the stepping direction (inward vs (bit mask)
.var FDC_STEP_ADDR = $D081  // Writing 1 causes the head to step in the indicated direction (address)
.var STEP_ADDR = $D081  // Writing 1 causes the head to step in the indicated direction (address)
.var FDC_STEP_MASK = %00010000  // Writing 1 causes the head to step in the indicated direction (bit mask)
.var STEP_MASK = %00010000  // Writing 1 causes the head to step in the indicated direction (bit mask)
.var FDC_FREE_ADDR = $D081  // Command is a free-format (low level) operation (address)
.var FREE_ADDR = $D081  // Command is a free-format (low level) operation (address)
.var FDC_FREE_MASK = %00100000  // Command is a free-format (low level) operation (bit mask)
.var FREE_MASK = %00100000  // Command is a free-format (low level) operation (bit mask)
.var FDC_RDCMD_ADDR = $D081  // Command is a read operation if set (address)
.var RDCMD_ADDR = $D081  // Command is a read operation if set (address)
.var FDC_RDCMD_MASK = %01000000  // Command is a read operation if set (bit mask)
.var RDCMD_MASK = %01000000  // Command is a read operation if set (bit mask)
.var FDC_WRCMD_ADDR = $D081  // Command is a write operation if set (address)
.var WRCMD_ADDR = $D081  // Command is a write operation if set (address)
.var FDC_WRCMD_MASK = %10000000  // Command is a write operation if set (bit mask)
.var WRCMD_MASK = %10000000  // Command is a write operation if set (bit mask)
.var FDC_TK0_ADDR = $D082  // F011 Head is over track 0 flag (read only) (address)
.var TK0_ADDR = $D082  // F011 Head is over track 0 flag (read only) (address)
.var FDC_TK0_MASK = %00000001  // F011 Head is over track 0 flag (read only) (bit mask)
.var TK0_MASK = %00000001  // F011 Head is over track 0 flag (read only) (bit mask)
.var FDC_PROT_ADDR = $D082  // F011 Disk write protect flag (read only) (address)
.var PROT_ADDR = $D082  // F011 Disk write protect flag (read only) (address)
.var FDC_PROT_MASK = %00000010  // F011 Disk write protect flag (read only) (bit mask)
.var PROT_MASK = %00000010  // F011 Disk write protect flag (read only) (bit mask)
.var FDC_LOST_ADDR = $D082  // F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (address)
.var LOST_ADDR = $D082  // F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (address)
.var FDC_LOST_MASK = %00000100  // F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (bit mask)
.var LOST_MASK = %00000100  // F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (bit mask)
.var FDC_CRC_ADDR = $D082  // F011 FDC CRC check failure flag (read only) (address)
.var CRC_ADDR = $D082  // F011 FDC CRC check failure flag (read only) (address)
.var FDC_CRC_MASK = %00001000  // F011 FDC CRC check failure flag (read only) (bit mask)
.var CRC_MASK = %00001000  // F011 FDC CRC check failure flag (read only) (bit mask)
.var FDC_RNF_ADDR = $D082  // F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (address)
.var RNF_ADDR = $D082  // F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (address)
.var FDC_RNF_MASK = %00010000  // F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (bit mask)
.var RNF_MASK = %00010000  // F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (bit mask)
.var FDC_EQ_ADDR = $D082  // F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (address)
.var EQ_ADDR = $D082  // F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (address)
.var FDC_EQ_MASK = %00100000  // F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (bit mask)
.var EQ_MASK = %00100000  // F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (bit mask)
.var FDC_DRQ_ADDR = $D082  // F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (address)
.var DRQ_ADDR = $D082  // F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (address)
.var FDC_DRQ_MASK = %01000000  // F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (bit mask)
.var DRQ_MASK = %01000000  // F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (bit mask)
.var FDC_BUSY_ADDR = $D082  // F011 FDC busy flag (command is being executed) (read only) (address)
.var BUSY_ADDR = $D082  // F011 FDC busy flag (command is being executed) (read only) (address)
.var FDC_BUSY_MASK = %10000000  // F011 FDC busy flag (command is being executed) (read only) (bit mask)
.var BUSY_MASK = %10000000  // F011 FDC busy flag (command is being executed) (read only) (bit mask)
.var FDC_DSKCHG_ADDR = $D083  // F011 disk change sense (read only) (address)
.var DSKCHG_ADDR = $D083  // F011 disk change sense (read only) (address)
.var FDC_DSKCHG_MASK = %00000001  // F011 disk change sense (read only) (bit mask)
.var DSKCHG_MASK = %00000001  // F011 disk change sense (read only) (bit mask)
.var C65_FDC_IRQ_ADDR = $D083  // The floppy controller has generated an interrupt (read only). Note that interrupts are not currently implemented on the 45GS27. (address)
.var C65_FDC_IRQ_MASK = %00000010  // The floppy controller has generated an interrupt (read only). Note that interrupts are not currently implemented on the 45GS27. (bit mask)
.var FDC_INDEX_ADDR = $D083  // F011 Index hole sense (read only) (address)
.var INDEX_ADDR = $D083  // F011 Index hole sense (read only) (address)
.var FDC_INDEX_MASK = %00000100  // F011 Index hole sense (read only) (bit mask)
.var INDEX_MASK = %00000100  // F011 Index hole sense (read only) (bit mask)
.var FDC_DISKIN_ADDR = $D083  // F011 Disk sense (read only) (address)
.var DISKIN_ADDR = $D083  // F011 Disk sense (read only) (address)
.var FDC_DISKIN_MASK = %00001000  // F011 Disk sense (read only) (bit mask)
.var DISKIN_MASK = %00001000  // F011 Disk sense (read only) (bit mask)
.var FDC_WGATE_ADDR = $D083  // F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (address)
.var WGATE_ADDR = $D083  // F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (address)
.var FDC_WGATE_MASK = %00010000  // F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (bit mask)
.var WGATE_MASK = %00010000  // F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (bit mask)
.var FDC_RUN_ADDR = $D083  // F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (address)
.var RUN_ADDR = $D083  // F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (address)
.var FDC_RUN_MASK = %00100000  // F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (bit mask)
.var RUN_MASK = %00100000  // F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (bit mask)
.var FDC_WTREQ_ADDR = $D083  // F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (address)
.var WTREQ_ADDR = $D083  // F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (address)
.var FDC_WTREQ_MASK = %01000000  // F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (bit mask)
.var WTREQ_MASK = %01000000  // F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (bit mask)
.var FDC_RDREQ_ADDR = $D083  // F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (address)
.var RDREQ_ADDR = $D083  // F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (address)
.var FDC_RDREQ_MASK = %10000000  // F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (bit mask)
.var RDREQ_MASK = %10000000  // F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (bit mask)
.var FDC_TRACK = $D084  // F011 FDC track selection register
.var TRACK = $D084  // F011 FDC track selection register
.var FDC_SECTOR = $D085  // F011 FDC sector selection register
.var SECTOR = $D085  // F011 FDC sector selection register
.var FDC_SIDE = $D086  // F011 FDC side selection register
.var SIDE = $D086  // F011 FDC side selection register
.var FDC_DATA = $D087  // F011 FDC data register (read/write) for accessing the floppy controller's 512 byte sector buffer
.var FDC_CLOCK = $D088  // Set or read the clock pattern to be used when writing address and data marks. Should normally be left $FF
.var CLOCK = $D088  // Set or read the clock pattern to be used when writing address and data marks. Should normally be left $FF
.var FDC_STEP = $D089  // Set or read the track stepping rate in 62.5 microsecond steps (normally 128, i.e., 8 milliseconds).
.var STEP = $D089  // Set or read the track stepping rate in 62.5 microsecond steps (normally 128, i.e., 8 milliseconds).
.var FDC_PCODE = $D08A  // (Read only) returns the protection code of the most recently read sector. Was intended for rudimentary copy protection. Not implemented.
.var PCODE = $D08A  // (Read only) returns the protection code of the most recently read sector. Was intended for rudimentary copy protection. Not implemented.
.var SUMMARY_REC = $D0A0  // Reserved for C65 RAM Expansion Controller.
.var REC = $D0A0  // Reserved for C65 RAM Expansion Controller.
.var VIC3_PALRED = $D100  // red palette values (reversed nybl order)
.var PALRED = $D100  // red palette values (reversed nybl order)
.var VIC3_PALGREEN = $D200  // green palette values (reversed nybl order)
.var PALGREEN = $D200  // green palette values (reversed nybl order)
.var VIC3_PALBLUE = $D300  // blue palette values (reversed nybl order)
.var PALBLUE = $D300  // blue palette values (reversed nybl order)
.var ETHCOMMAND_DEBUGVIC = $D4  // Select VIC-IV debug stream via ethernet when \$D6E1.3 is set
.var DEBUGVIC = $D4  // Select VIC-IV debug stream via ethernet when \$D6E1.3 is set
.var UART_DATA = $D600  // UART data register (read or write)
.var UART_RXRDY_ADDR = $D601  // UART RX byte ready flag (clear by reading \$D600) (address)
.var RXRDY_ADDR = $D601  // UART RX byte ready flag (clear by reading \$D600) (address)
.var UART_RXRDY_MASK = %00000001  // UART RX byte ready flag (clear by reading \$D600) (bit mask)
.var RXRDY_MASK = %00000001  // UART RX byte ready flag (clear by reading \$D600) (bit mask)
.var UART_RXOVRRUN_ADDR = $D601  // UART RX overrun flag (clear by reading \$D600) (address)
.var RXOVRRUN_ADDR = $D601  // UART RX overrun flag (clear by reading \$D600) (address)
.var UART_RXOVRRUN_MASK = %00000010  // UART RX overrun flag (clear by reading \$D600) (bit mask)
.var RXOVRRUN_MASK = %00000010  // UART RX overrun flag (clear by reading \$D600) (bit mask)
.var UART_PTYERR_ADDR = $D601  // UART RX parity error flag (clear by reading \$D600) (address)
.var PTYERR_ADDR = $D601  // UART RX parity error flag (clear by reading \$D600) (address)
.var UART_PTYERR_MASK = %00000100  // UART RX parity error flag (clear by reading \$D600) (bit mask)
.var PTYERR_MASK = %00000100  // UART RX parity error flag (clear by reading \$D600) (bit mask)
.var UART_FRMERR_ADDR = $D601  // UART RX framing error flag (clear by reading \$D600) (address)
.var FRMERR_ADDR = $D601  // UART RX framing error flag (clear by reading \$D600) (address)
.var UART_FRMERR_MASK = %00001000  // UART RX framing error flag (clear by reading \$D600) (bit mask)
.var FRMERR_MASK = %00001000  // UART RX framing error flag (clear by reading \$D600) (bit mask)
.var UART_PTYEVEN_ADDR = $D602  // UART Parity: 1=even, 0=odd (address)
.var PTYEVEN_ADDR = $D602  // UART Parity: 1=even, 0=odd (address)
.var UART_PTYEVEN_MASK = %00000001  // UART Parity: 1=even, 0=odd (bit mask)
.var PTYEVEN_MASK = %00000001  // UART Parity: 1=even, 0=odd (bit mask)
.var UART_PTYEN_ADDR = $D602  // UART Parity enable: 1=enabled (address)
.var PTYEN_ADDR = $D602  // UART Parity enable: 1=enabled (address)
.var UART_PTYEN_MASK = %00000010  // UART Parity enable: 1=enabled (bit mask)
.var PTYEN_MASK = %00000010  // UART Parity enable: 1=enabled (bit mask)
.var UART_CHARSZ_ADDR = $D602  // UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (address)
.var CHARSZ_ADDR = $D602  // UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (address)
.var UART_CHARSZ_MASK = %00001100  // UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (bit mask)
.var CHARSZ_MASK = %00001100  // UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (bit mask)
.var UART_SYNCMOD_ADDR = $D602  // UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (address)
.var SYNCMOD_ADDR = $D602  // UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (address)
.var UART_SYNCMOD_MASK = %00110000  // UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (bit mask)
.var SYNCMOD_MASK = %00110000  // UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (bit mask)
.var UART_RXEN_ADDR = $D602  // UART enable receive (address)
.var RXEN_ADDR = $D602  // UART enable receive (address)
.var UART_RXEN_MASK = %01000000  // UART enable receive (bit mask)
.var RXEN_MASK = %01000000  // UART enable receive (bit mask)
.var UART_TXEN_ADDR = $D602  // UART enable transmit (address)
.var TXEN_ADDR = $D602  // UART enable transmit (address)
.var UART_TXEN_MASK = %10000000  // UART enable transmit (bit mask)
.var TXEN_MASK = %10000000  // UART enable transmit (bit mask)
.var UART_DIVISOR = $D603  // UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
.var C65_UART_DIVISOR = $D604  // UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
.var UART_IMRXNMI_ADDR = $D605  // UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (address)
.var IMRXNMI_ADDR = $D605  // UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (address)
.var UART_IMRXNMI_MASK = %00010000  // UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (bit mask)
.var IMRXNMI_MASK = %00010000  // UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (bit mask)
.var UART_IMTXNMI_ADDR = $D605  // UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (address)
.var IMTXNMI_ADDR = $D605  // UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (address)
.var UART_IMTXNMI_MASK = %00100000  // UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (bit mask)
.var IMTXNMI_MASK = %00100000  // UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (bit mask)
.var UART_IMRXIRQ_ADDR = $D605  // UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (address)
.var IMRXIRQ_ADDR = $D605  // UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (address)
.var UART_IMRXIRQ_MASK = %01000000  // UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
.var IMRXIRQ_MASK = %01000000  // UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
.var UART_IMTXIRQ_ADDR = $D605  // UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (address)
.var IMTXIRQ_ADDR = $D605  // UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (address)
.var UART_IMTXIRQ_MASK = %10000000  // UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
.var IMTXIRQ_MASK = %10000000  // UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
.var UART_IFRXNMI_ADDR = $D606  // UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (address)
.var IFRXNMI_ADDR = $D606  // UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (address)
.var UART_IFRXNMI_MASK = %00010000  // UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (bit mask)
.var IFRXNMI_MASK = %00010000  // UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (bit mask)
.var UART_IFTXNMI_ADDR = $D606  // UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (address)
.var IFTXNMI_ADDR = $D606  // UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (address)
.var UART_IFTXNMI_MASK = %00100000  // UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (bit mask)
.var IFTXNMI_MASK = %00100000  // UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (bit mask)
.var UART_IFRXIRQ_ADDR = $D606  // UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (address)
.var IFRXIRQ_ADDR = $D606  // UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (address)
.var UART_IFRXIRQ_MASK = %01000000  // UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
.var IFRXIRQ_MASK = %01000000  // UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
.var UART_IFTXIRQ_ADDR = $D606  // UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (address)
.var IFTXIRQ_ADDR = $D606  // UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (address)
.var UART_IFTXIRQ_MASK = %10000000  // UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
.var IFTXIRQ_MASK = %10000000  // UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
.var UART_CAPLOCK_ADDR = $D607  // C65 capslock key sense (address)
.var CAPLOCK_ADDR = $D607  // C65 capslock key sense (address)
.var UART_CAPLOCK_MASK = %00000001  // C65 capslock key sense (bit mask)
.var CAPLOCK_MASK = %00000001  // C65 capslock key sense (bit mask)
.var UART_KEYCOL8_ADDR = $D607  // C65 keyboard column 8 select (address)
.var KEYCOL8_ADDR = $D607  // C65 keyboard column 8 select (address)
.var UART_KEYCOL8_MASK = %00000010  // C65 keyboard column 8 select (bit mask)
.var KEYCOL8_MASK = %00000010  // C65 keyboard column 8 select (bit mask)
.var UART_PORTEDDR_ADDR = $D608  // C65 keyboard extra lines Data Direction Register (DDR) (address)
.var PORTEDDR_ADDR = $D608  // C65 keyboard extra lines Data Direction Register (DDR) (address)
.var UART_PORTEDDR_MASK = %00000011  // C65 keyboard extra lines Data Direction Register (DDR) (bit mask)
.var PORTEDDR_MASK = %00000011  // C65 keyboard extra lines Data Direction Register (DDR) (bit mask)
.var UARTMISC_UFAST_ADDR = $D609  // C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (address)
.var UFAST_ADDR = $D609  // C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (address)
.var UARTMISC_UFAST_MASK = %00000001  // C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (bit mask)
.var UFAST_MASK = %00000001  // C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (bit mask)
.var UARTMISC_PORTF_ADDR = $D60B  // PMOD port A on FPGA board (data) (Nexys4 boards only) (address)
.var PORTF_ADDR = $D60B  // PMOD port A on FPGA board (data) (Nexys4 boards only) (address)
.var UARTMISC_PORTF_MASK = %00111111  // PMOD port A on FPGA board (data) (Nexys4 boards only) (bit mask)
.var PORTF_MASK = %00111111  // PMOD port A on FPGA board (data) (Nexys4 boards only) (bit mask)
.var UARTMISC_OSKZON_ADDR = $D60B  // Display hardware zoom of region under first touch point always (address)
.var OSKZON_ADDR = $D60B  // Display hardware zoom of region under first touch point always (address)
.var UARTMISC_OSKZON_MASK = %01000000  // Display hardware zoom of region under first touch point always (bit mask)
.var OSKZON_MASK = %01000000  // Display hardware zoom of region under first touch point always (bit mask)
.var UARTMISC_OSKZEN_ADDR = $D60B  // Display hardware zoom of region under first touch point for on-screen keyboard (address)
.var OSKZEN_ADDR = $D60B  // Display hardware zoom of region under first touch point for on-screen keyboard (address)
.var UARTMISC_OSKZEN_MASK = %10000000  // Display hardware zoom of region under first touch point for on-screen keyboard (bit mask)
.var OSKZEN_MASK = %10000000  // Display hardware zoom of region under first touch point for on-screen keyboard (bit mask)
.var UARTMISC_PORTFDDR_ADDR = $D60C  // PMOD port A on FPGA board (DDR) (address)
.var UARTMISC_PORTFDDR_MASK = %00111111  // PMOD port A on FPGA board (DDR) (bit mask)
.var GS_UARTMISC_PORTFDDR_ADDR = $D60C  // On Screen Keyboard (OSK) Zoom Control Data Direction Register (DDR). Must be set to output to control these features. (address)
.var GS_UARTMISC_PORTFDDR_MASK = %11000000  // On Screen Keyboard (OSK) Zoom Control Data Direction Register (DDR). Must be set to output to control these features. (bit mask)
.var UARTMISC_CONN41_ADDR = $D60D  // Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (address)
.var CONN41_ADDR = $D60D  // Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (address)
.var UARTMISC_CONN41_MASK = %00000001  // Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (bit mask)
.var CONN41_MASK = %00000001  // Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (bit mask)
.var UARTMISC_RST41_ADDR = $D60D  // Internal 1541 drive reset (1=reset, 0=operate) (address)
.var RST41_ADDR = $D60D  // Internal 1541 drive reset (1=reset, 0=operate) (address)
.var UARTMISC_RST41_MASK = %00000010  // Internal 1541 drive reset (1=reset, 0=operate) (bit mask)
.var RST41_MASK = %00000010  // Internal 1541 drive reset (1=reset, 0=operate) (bit mask)
.var UARTMISC_SDDATA_ADDR = $D60D  // SD card MOSI/MISO (address)
.var SDDATA_ADDR = $D60D  // SD card MOSI/MISO (address)
.var UARTMISC_SDDATA_MASK = %00000100  // SD card MOSI/MISO (bit mask)
.var SDDATA_MASK = %00000100  // SD card MOSI/MISO (bit mask)
.var UARTMISC_SDCLK_ADDR = $D60D  // SD card SCLK (address)
.var SDCLK_ADDR = $D60D  // SD card SCLK (address)
.var UARTMISC_SDCLK_MASK = %00001000  // SD card SCLK (bit mask)
.var SDCLK_MASK = %00001000  // SD card SCLK (bit mask)
.var UARTMISC_SDCS_ADDR = $D60D  // SD card CS_BO (address)
.var SDCS_ADDR = $D60D  // SD card CS_BO (address)
.var UARTMISC_SDCS_MASK = %00010000  // SD card CS_BO (bit mask)
.var SDCS_MASK = %00010000  // SD card CS_BO (bit mask)
.var UARTMISC_SDBSH_ADDR = $D60D  // Enable SD card bitbash mode (address)
.var SDBSH_ADDR = $D60D  // Enable SD card bitbash mode (address)
.var UARTMISC_SDBSH_MASK = %00100000  // Enable SD card bitbash mode (bit mask)
.var SDBSH_MASK = %00100000  // Enable SD card bitbash mode (bit mask)
.var UARTMISC_HDSDA_ADDR = $D60D  // HDMI I2C control interface SDA data line (address)
.var HDSDA_ADDR = $D60D  // HDMI I2C control interface SDA data line (address)
.var UARTMISC_HDSDA_MASK = %01000000  // HDMI I2C control interface SDA data line (bit mask)
.var HDSDA_MASK = %01000000  // HDMI I2C control interface SDA data line (bit mask)
.var UARTMISC_HDSCL_ADDR = $D60D  // HDMI I2C control interface SCL clock (address)
.var HDSCL_ADDR = $D60D  // HDMI I2C control interface SCL clock (address)
.var UARTMISC_HDSCL_MASK = %10000000  // HDMI I2C control interface SCL clock (bit mask)
.var HDSCL_MASK = %10000000  // HDMI I2C control interface SCL clock (bit mask)
.var UARTMISC_BASHDDR = $D60E  // Data Direction Register (DDR) for \$D60D bit bashing port.
.var BASHDDR = $D60E  // Data Direction Register (DDR) for \$D60D bit bashing port.
.var UARTMISC_KEYLEFT_ADDR = $D60F  // Directly read C65 Cursor left key (address)
.var KEYLEFT_ADDR = $D60F  // Directly read C65 Cursor left key (address)
.var UARTMISC_KEYLEFT_MASK = %00000001  // Directly read C65 Cursor left key (bit mask)
.var KEYLEFT_MASK = %00000001  // Directly read C65 Cursor left key (bit mask)
.var UARTMISC_KEYUP_ADDR = $D60F  // Directly read C65 Cursor up key (address)
.var KEYUP_ADDR = $D60F  // Directly read C65 Cursor up key (address)
.var UARTMISC_KEYUP_MASK = %00000010  // Directly read C65 Cursor up key (bit mask)
.var KEYUP_MASK = %00000010  // Directly read C65 Cursor up key (bit mask)
.var UARTMISC_REALHW_ADDR = $D60F  // Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (address)
.var REALHW_ADDR = $D60F  // Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (address)
.var UARTMISC_REALHW_MASK = %00100000  // Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (bit mask)
.var REALHW_MASK = %00100000  // Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (bit mask)
.var UARTMISC_OSKDIM_ADDR = $D60F  // Light or heavy dimming of background material behind on-screen keyboard (address)
.var OSKDIM_ADDR = $D60F  // Light or heavy dimming of background material behind on-screen keyboard (address)
.var UARTMISC_OSKDIM_MASK = %01000000  // Light or heavy dimming of background material behind on-screen keyboard (bit mask)
.var OSKDIM_MASK = %01000000  // Light or heavy dimming of background material behind on-screen keyboard (bit mask)
.var UARTMISC_ACCESSKEY_ADDR = $D60F  // Enable accessible keyboard input via joystick port 2 fire button (address)
.var ACCESSKEY_ADDR = $D60F  // Enable accessible keyboard input via joystick port 2 fire button (address)
.var UARTMISC_ACCESSKEY_MASK = %10000000  // Enable accessible keyboard input via joystick port 2 fire button (bit mask)
.var ACCESSKEY_MASK = %10000000  // Enable accessible keyboard input via joystick port 2 fire button (bit mask)
.var UARTMISC_ASCIIKEY = $D610  // Last key press as ASCII (hardware accelerated keyboard scanner). Write to clear event ready for next.
.var ASCIIKEY = $D610  // Last key press as ASCII (hardware accelerated keyboard scanner). Write to clear event ready for next.
.var UARTMISC_MRSHFT_ADDR = $D611  // Right shift key state (hardware accelerated keyboard scanner). (address)
.var MRSHFT_ADDR = $D611  // Right shift key state (hardware accelerated keyboard scanner). (address)
.var UARTMISC_MRSHFT_MASK = %00000001  // Right shift key state (hardware accelerated keyboard scanner). (bit mask)
.var MRSHFT_MASK = %00000001  // Right shift key state (hardware accelerated keyboard scanner). (bit mask)
.var UARTMISC_MLSHFT_ADDR = $D611  // Left shift key state (hardware accelerated keyboard scanner). (address)
.var MLSHFT_ADDR = $D611  // Left shift key state (hardware accelerated keyboard scanner). (address)
.var UARTMISC_MLSHFT_MASK = %00000010  // Left shift key state (hardware accelerated keyboard scanner). (bit mask)
.var MLSHFT_MASK = %00000010  // Left shift key state (hardware accelerated keyboard scanner). (bit mask)
.var UARTMISC_MCTRL_ADDR = $D611  // CTRL key state (hardware accelerated keyboard scanner). (address)
.var MCTRL_ADDR = $D611  // CTRL key state (hardware accelerated keyboard scanner). (address)
.var UARTMISC_MCTRL_MASK = %00000100  // CTRL key state (hardware accelerated keyboard scanner). (bit mask)
.var MCTRL_MASK = %00000100  // CTRL key state (hardware accelerated keyboard scanner). (bit mask)
.var UARTMISC_MMEGA_ADDR = $D611  // MEGA/C= key state (hardware accelerated keyboard scanner). (address)
.var MMEGA_ADDR = $D611  // MEGA/C= key state (hardware accelerated keyboard scanner). (address)
.var UARTMISC_MMEGA_MASK = %00001000  // MEGA/C= key state (hardware accelerated keyboard scanner). (bit mask)
.var MMEGA_MASK = %00001000  // MEGA/C= key state (hardware accelerated keyboard scanner). (bit mask)
.var UARTMISC_MALT_ADDR = $D611  // ALT key state (hardware accelerated keyboard scanner). (address)
.var MALT_ADDR = $D611  // ALT key state (hardware accelerated keyboard scanner). (address)
.var UARTMISC_MALT_MASK = %00010000  // ALT key state (hardware accelerated keyboard scanner). (bit mask)
.var MALT_MASK = %00010000  // ALT key state (hardware accelerated keyboard scanner). (bit mask)
.var UARTMISC_MSCRL_ADDR = $D611  // NOSCRL key state (hardware accelerated keyboard scanner). (address)
.var MSCRL_ADDR = $D611  // NOSCRL key state (hardware accelerated keyboard scanner). (address)
.var UARTMISC_MSCRL_MASK = %00100000  // NOSCRL key state (hardware accelerated keyboard scanner). (bit mask)
.var MSCRL_MASK = %00100000  // NOSCRL key state (hardware accelerated keyboard scanner). (bit mask)
.var UARTMISC_MCAPS_ADDR = $D611  // CAPS LOCK key state (hardware accelerated keyboard scanner). (address)
.var MCAPS_ADDR = $D611  // CAPS LOCK key state (hardware accelerated keyboard scanner). (address)
.var UARTMISC_MCAPS_MASK = %01000000  // CAPS LOCK key state (hardware accelerated keyboard scanner). (bit mask)
.var MCAPS_MASK = %01000000  // CAPS LOCK key state (hardware accelerated keyboard scanner). (bit mask)
.var UARTMISC_WGTKEY_ADDR = $D612  // Enable widget board keyboard/joystick input (address)
.var WGTKEY_ADDR = $D612  // Enable widget board keyboard/joystick input (address)
.var UARTMISC_WGTKEY_MASK = %00000001  // Enable widget board keyboard/joystick input (bit mask)
.var WGTKEY_MASK = %00000001  // Enable widget board keyboard/joystick input (bit mask)
.var UARTMISC_PS2KEY_ADDR = $D612  // Enable ps2 keyboard/joystick input (address)
.var PS2KEY_ADDR = $D612  // Enable ps2 keyboard/joystick input (address)
.var UARTMISC_PS2KEY_MASK = %00000010  // Enable ps2 keyboard/joystick input (bit mask)
.var PS2KEY_MASK = %00000010  // Enable ps2 keyboard/joystick input (bit mask)
.var UARTMISC_PHYKEY_ADDR = $D612  // Enable physical keyboard input (address)
.var PHYKEY_ADDR = $D612  // Enable physical keyboard input (address)
.var UARTMISC_PHYKEY_MASK = %00000100  // Enable physical keyboard input (bit mask)
.var PHYKEY_MASK = %00000100  // Enable physical keyboard input (bit mask)
.var UARTMISC_VRTKEY_ADDR = $D612  // Enable virtual/snythetic keyboard input (address)
.var VRTKEY_ADDR = $D612  // Enable virtual/snythetic keyboard input (address)
.var UARTMISC_VRTKEY_MASK = %00001000  // Enable virtual/snythetic keyboard input (bit mask)
.var VRTKEY_MASK = %00001000  // Enable virtual/snythetic keyboard input (bit mask)
.var UARTMISC_OSKDEBUG_ADDR = $D612  // Debug OSK overlay (WRITE ONLY) (address)
.var OSKDEBUG_ADDR = $D612  // Debug OSK overlay (WRITE ONLY) (address)
.var UARTMISC_OSKDEBUG_MASK = %00010000  // Debug OSK overlay (WRITE ONLY) (bit mask)
.var OSKDEBUG_MASK = %00010000  // Debug OSK overlay (WRITE ONLY) (bit mask)
.var UARTMISC_PS2JOY_ADDR = $D612  // Enable PS/2 / USB keyboard simulated joystick input (address)
.var PS2JOY_ADDR = $D612  // Enable PS/2 / USB keyboard simulated joystick input (address)
.var UARTMISC_PS2JOY_MASK = %00010000  // Enable PS/2 / USB keyboard simulated joystick input (bit mask)
.var PS2JOY_MASK = %00010000  // Enable PS/2 / USB keyboard simulated joystick input (bit mask)
.var UARTMISC_JOYSWAP_ADDR = $D612  // Exchange joystick ports 1 \& 2 (address)
.var JOYSWAP_ADDR = $D612  // Exchange joystick ports 1 \& 2 (address)
.var UARTMISC_JOYSWAP_MASK = %00100000  // Exchange joystick ports 1 \& 2 (bit mask)
.var JOYSWAP_MASK = %00100000  // Exchange joystick ports 1 \& 2 (bit mask)
.var UARTMISC_LJOYA_ADDR = $D612  // Rotate inputs of joystick A by 180 degrees (for left handed use) (address)
.var LJOYA_ADDR = $D612  // Rotate inputs of joystick A by 180 degrees (for left handed use) (address)
.var UARTMISC_LJOYA_MASK = %01000000  // Rotate inputs of joystick A by 180 degrees (for left handed use) (bit mask)
.var LJOYA_MASK = %01000000  // Rotate inputs of joystick A by 180 degrees (for left handed use) (bit mask)
.var UARTMISC_LJOYB_ADDR = $D612  // Rotate inputs of joystick B by 180 degrees (for left handed use) (address)
.var LJOYB_ADDR = $D612  // Rotate inputs of joystick B by 180 degrees (for left handed use) (address)
.var UARTMISC_LJOYB_MASK = %10000000  // Rotate inputs of joystick B by 180 degrees (for left handed use) (bit mask)
.var LJOYB_MASK = %10000000  // Rotate inputs of joystick B by 180 degrees (for left handed use) (bit mask)
.var DEBUG_CRTACSCNT = $D613  // Count of cartridge port memory accesses (read only)
.var CRTACSCNT = $D613  // Count of cartridge port memory accesses (read only)
.var DEBUG_KEYMATRIXPEEK = $D614  // 8-bit segment of combined keyboard matrix (READ)
.var KEYMATRIXPEEK = $D614  // 8-bit segment of combined keyboard matrix (READ)
.var UARTMISC_VIRTKEY1_ADDR = $D615  // Set to \$7F for no key down, else specify virtual key press. (address)
.var VIRTKEY1_ADDR = $D615  // Set to \$7F for no key down, else specify virtual key press. (address)
.var UARTMISC_VIRTKEY1_MASK = %01111111  // Set to \$7F for no key down, else specify virtual key press. (bit mask)
.var VIRTKEY1_MASK = %01111111  // Set to \$7F for no key down, else specify virtual key press. (bit mask)
.var UARTMISC_OSKEN_ADDR = $D615  // Enable display of on-screen keyboard composited overlay (address)
.var OSKEN_ADDR = $D615  // Enable display of on-screen keyboard composited overlay (address)
.var UARTMISC_OSKEN_MASK = %10000000  // Enable display of on-screen keyboard composited overlay (bit mask)
.var OSKEN_MASK = %10000000  // Enable display of on-screen keyboard composited overlay (bit mask)
.var UARTMISC_VIRTKEY2_ADDR = $D616  // Set to \$7F for no key down, else specify 2nd virtual key press. (address)
.var VIRTKEY2_ADDR = $D616  // Set to \$7F for no key down, else specify 2nd virtual key press. (address)
.var UARTMISC_VIRTKEY2_MASK = %01111111  // Set to \$7F for no key down, else specify 2nd virtual key press. (bit mask)
.var VIRTKEY2_MASK = %01111111  // Set to \$7F for no key down, else specify 2nd virtual key press. (bit mask)
.var UARTMISC_OSKALT_ADDR = $D616  // Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (address)
.var OSKALT_ADDR = $D616  // Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (address)
.var UARTMISC_OSKALT_MASK = %10000000  // Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (bit mask)
.var OSKALT_MASK = %10000000  // Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (bit mask)
.var UARTMISC_VIRTKEY3_ADDR = $D617  // Set to \$7F for no key down, else specify 3nd virtual key press. (address)
.var VIRTKEY3_ADDR = $D617  // Set to \$7F for no key down, else specify 3nd virtual key press. (address)
.var UARTMISC_VIRTKEY3_MASK = %01111111  // Set to \$7F for no key down, else specify 3nd virtual key press. (bit mask)
.var VIRTKEY3_MASK = %01111111  // Set to \$7F for no key down, else specify 3nd virtual key press. (bit mask)
.var UARTMISC_OSKTOP_ADDR = $D617  // 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (address)
.var OSKTOP_ADDR = $D617  // 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (address)
.var UARTMISC_OSKTOP_MASK = %10000000  // 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (bit mask)
.var OSKTOP_MASK = %10000000  // 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (bit mask)
.var UARTMISC_KSCNRATE = $D618  // Physical keyboard scan rate (\$00=50MHz, \$FF=~200KHz)
.var KSCNRATE = $D618  // Physical keyboard scan rate (\$00=50MHz, \$FF=~200KHz)
.var UARTMISC_UNUSED = $D619  // port o output value
.var UNUSED = $D619  // port o output value
.var UARTMISC_SYSCTL = $D61A  // System control flags (target specific)
.var SYSCTL = $D61A  // System control flags (target specific)
.var SYSCTL_AUDMUTE_ADDR = $D61A  // Mute digital video audio (MEGA65 R2 only) (address)
.var AUDMUTE_ADDR = $D61A  // Mute digital video audio (MEGA65 R2 only) (address)
.var SYSCTL_AUDMUTE_MASK = %00000001  // Mute digital video audio (MEGA65 R2 only) (bit mask)
.var AUDMUTE_MASK = %00000001  // Mute digital video audio (MEGA65 R2 only) (bit mask)
.var SYSCTL_DVI_ADDR = $D61A  // Control digital video as DVI (disables audio) (address)
.var DVI_ADDR = $D61A  // Control digital video as DVI (disables audio) (address)
.var SYSCTL_DVI_MASK = %00000010  // Control digital video as DVI (disables audio) (bit mask)
.var DVI_MASK = %00000010  // Control digital video as DVI (disables audio) (bit mask)
.var SYSCTL_AUDDBG_ADDR = $D61A  // Visualise audio samples (DEBUG) (address)
.var AUDDBG_ADDR = $D61A  // Visualise audio samples (DEBUG) (address)
.var SYSCTL_AUDDBG_MASK = %00000100  // Visualise audio samples (DEBUG) (bit mask)
.var AUDDBG_MASK = %00000100  // Visualise audio samples (DEBUG) (bit mask)
.var SYSCTL_AUD48K_ADDR = $D61A  // Select 48KHz or 44.1KHz digital video audio sample rate (address)
.var AUD48K_ADDR = $D61A  // Select 48KHz or 44.1KHz digital video audio sample rate (address)
.var SYSCTL_AUD48K_MASK = %00001000  // Select 48KHz or 44.1KHz digital video audio sample rate (bit mask)
.var AUD48K_MASK = %00001000  // Select 48KHz or 44.1KHz digital video audio sample rate (bit mask)
.var SYSCTL_LED_ADDR = $D61A  // Control LED next to U1 on mother board (address)
.var SYSCTL_LED_MASK = %00010000  // Control LED next to U1 on mother board (bit mask)
.var SYSCTL_AUDINV_ADDR = $D61A  // Invert digital video audio sample values (address)
.var AUDINV_ADDR = $D61A  // Invert digital video audio sample values (address)
.var SYSCTL_AUDINV_MASK = %10000000  // Invert digital video audio sample values (bit mask)
.var AUDINV_MASK = %10000000  // Invert digital video audio sample values (bit mask)
.var DEBUG_AMIMOUSDETECT = $D61B  // READ 1351/amiga mouse auto detection DEBUG
.var AMIMOUSDETECT = $D61B  // READ 1351/amiga mouse auto detection DEBUG
.var DEBUG__1541PCLSB = $D61C  // internal 1541 PC LSB
.var _1541PCLSB = $D61C  // internal 1541 PC LSB
.var UARTMISC_Keyboard_ADDR = $D61D  // LED register select (R,G,B channels x 4 = 0 to 11) (address)
.var UARTMISC_Keyboard_MASK = %01111111  // LED register select (R,G,B channels x 4 = 0 to 11) (bit mask)
.var GS_UARTMISC_Keyboard_ADDR = $D61D  // LED control enable (address)
.var GS_UARTMISC_Keyboard_MASK = %10000000  // LED control enable (bit mask)
.var UARTMISC_Keyboard = $D61E  // register value (write only)
.var Keyboard = $D61E  // register value (write only)
.var DEBUG_BUCKYCOPY = $D61F  // DUPLICATE Modifier key state (hardware accelerated keyboard scanner).
.var BUCKYCOPY = $D61F  // DUPLICATE Modifier key state (hardware accelerated keyboard scanner).
.var UARTMISC_POTAX = $D620  // Read Port A paddle X, without having to fiddle with SID/CIA settings.
.var POTAX = $D620  // Read Port A paddle X, without having to fiddle with SID/CIA settings.
.var UARTMISC_POTAY = $D621  // Read Port A paddle Y, without having to fiddle with SID/CIA settings.
.var POTAY = $D621  // Read Port A paddle Y, without having to fiddle with SID/CIA settings.
.var UARTMISC_POTBX = $D622  // Read Port B paddle X, without having to fiddle with SID/CIA settings.
.var POTBX = $D622  // Read Port B paddle X, without having to fiddle with SID/CIA settings.
.var UARTMISC_POTBY = $D623  // Read Port B paddle Y, without having to fiddle with SID/CIA settings.
.var POTBY = $D623  // Read Port B paddle Y, without having to fiddle with SID/CIA settings.
.var DEBUG_POTDEBUG = $D624  // READ ONLY flags for paddles. See c65uart.vhdl for more information.
.var POTDEBUG = $D624  // READ ONLY flags for paddles. See c65uart.vhdl for more information.
.var UARTMISC_J21L = $D625  // J21 pins 1 -- 6, 9 -- 10 input/output values
.var J21L = $D625  // J21 pins 1 -- 6, 9 -- 10 input/output values
.var UARTMISC_J21H = $D626  // J21 pins 11 -- 14 input/output values
.var J21H = $D626  // J21 pins 11 -- 14 input/output values
.var UARTMISC_J21LDDR = $D627  // J21 pins 1 -- 6, 9 -- 10 data direction register
.var J21LDDR = $D627  // J21 pins 1 -- 6, 9 -- 10 data direction register
.var UARTMISC_J21HDDR = $D628  // J21 pins 11 -- 14 data direction register
.var J21HDDR = $D628  // J21 pins 11 -- 14 data direction register
.var UARTMISC_M65MODEL = $D629  // MEGA65 model ID. Can be used to determine the model of MEGA65 a programme is running on, e.g., to enable touch controls on MEGAphone.
.var M65MODEL = $D629  // MEGA65 model ID. Can be used to determine the model of MEGA65 a programme is running on, e.g., to enable touch controls on MEGAphone.
.var KBD_FWDATEL = $D62A  // LSB of keyboard firmware date stamp (days since 1 Jan 2020)
.var KBD_FWDATEH = $D62B  // MSB of keyboard firmware date stamp (days since 1 Jan 2020)
.var KBD_FWGIT0 = $D62C  // LSB of keyboard firmware git commit
.var GS_KBD_FWGIT0 = $D62D  // 2nd byte of keyboard firmware git commit
.var GS_KBD_FWGIT0_2 = $D62E  // 3rd byte of keyboard firmware git commit
.var GS_KBD_FWGIT0_3 = $D62F  // MSB of keyboard firmware git commit
.var FPGA_FWDATEL = $D630  // LSB of MEGA65 FPGA design date stamp (days since 1 Jan 2020)
.var FPGA_FWDATEH = $D631  // MSB of MEGA65 FPGA design date stamp (days since 1 Jan 2020)
.var FPGA_FWGIT0 = $D632  // LSB of MEGA65 FPGA design git commit
.var GS_FPGA_FWGIT0 = $D633  // 2nd byte of MEGA65 FPGA design git commit
.var GS_FPGA_FWGIT0_2 = $D634  // 3rd byte of MEGA65 FPGA design git commit
.var GS_FPGA_FWGIT0_3 = $D635  // MSB of MEGA65 FPGA design git commit
.var AUXFPGA_FWDATEL = $D636  // LSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
.var AUXFPGA_MFWDATEH = $D637  // MSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
.var MFWDATEH = $D637  // MSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
.var AUXFPGA_FWGIT0 = $D638  // LSB of Auxilliary (MAX10) FPGA design git commit
.var GS_AUXFPGA_FWGIT0 = $D639  // 2nd byte of Auxilliary (MAX10) FPGA design git commit
.var GS_AUXFPGA_FWGIT0_2 = $D63A  // 3rd byte of Auxilliary (MAX10) FPGA design git commit
.var GS_AUXFPGA_FWGIT0_3 = $D63B  // MSB of Auxilliary (MAX10) FPGA design git commit
.var SID_SIDMODE_ADDR = $D63C  // Select SID mode: 0=6581, 1=8580 (address)
.var SIDMODE_ADDR = $D63C  // Select SID mode: 0=6581, 1=8580 (address)
.var SID_SIDMODE_MASK = %00001111  // Select SID mode: 0=6581, 1=8580 (bit mask)
.var SIDMODE_MASK = %00001111  // Select SID mode: 0=6581, 1=8580 (bit mask)
.var AUDIOMIX_DCTRKEN_ADDR = $D63C  // Enable DC offset subtraction in audio mixer (address)
.var DCTRKEN_ADDR = $D63C  // Enable DC offset subtraction in audio mixer (address)
.var AUDIOMIX_DCTRKEN_MASK = %00010000  // Enable DC offset subtraction in audio mixer (bit mask)
.var DCTRKEN_MASK = %00010000  // Enable DC offset subtraction in audio mixer (bit mask)
.var DEBUG_RESETSRC_ADDR = $D63C  // Source of last CPU reset (address)
.var RESETSRC_ADDR = $D63C  // Source of last CPU reset (address)
.var DEBUG_RESETSRC_MASK = %11100000  // Source of last CPU reset (bit mask)
.var RESETSRC_MASK = %11100000  // Source of last CPU reset (bit mask)
.var AUDIOMIX_DCTIME = $D63D  // Audio mixer DC-estimation time step. Lower values = faster updating of DC estimation, at the cost of making low-frequencies quieter.
.var DCTIME = $D63D  // Audio mixer DC-estimation time step. Lower values = faster updating of DC estimation, at the cost of making low-frequencies quieter.
.var CPU_HTRAP00 = $D640  // Writing triggers hypervisor trap \$XX
.var HTRAP00 = $D640  // Writing triggers hypervisor trap \$XX
.var HCPU_REGA = $D640  // Hypervisor A register storage
.var REGA = $D640  // Hypervisor A register storage
.var CPU_HTRAP01 = $D641  // @HTRAPXX
.var HTRAP01 = $D641  // @HTRAPXX
.var HCPU_REGX = $D641  // Hypervisor X register storage
.var REGX = $D641  // Hypervisor X register storage
.var CPU_HTRAP02 = $D642  // @HTRAPXX
.var HTRAP02 = $D642  // @HTRAPXX
.var CPU_HTRAP03 = $D643  // @HTRAPXX
.var HTRAP03 = $D643  // @HTRAPXX
.var HCPU_REGZ = $D643  // Hypervisor Z register storage
.var REGZ = $D643  // Hypervisor Z register storage
.var CPU_HTRAP04 = $D644  // @HTRAPXX
.var HTRAP04 = $D644  // @HTRAPXX
.var HCPU_REGB = $D644  // Hypervisor B register storage
.var REGB = $D644  // Hypervisor B register storage
.var CPU_HTRAP05 = $D645  // @HTRAPXX
.var HTRAP05 = $D645  // @HTRAPXX
.var HCPU_SPL = $D645  // Hypervisor SPL register storage
.var SPL = $D645  // Hypervisor SPL register storage
.var CPU_HTRAP06 = $D646  // @HTRAPXX
.var HTRAP06 = $D646  // @HTRAPXX
.var HCPU_SPH = $D646  // Hypervisor SPH register storage
.var SPH = $D646  // Hypervisor SPH register storage
.var CPU_HTRAP07 = $D647  // @HTRAPXX
.var HTRAP07 = $D647  // @HTRAPXX
.var HCPU_PFLAGS = $D647  // Hypervisor P register storage
.var PFLAGS = $D647  // Hypervisor P register storage
.var CPU_HTRAP08 = $D648  // @HTRAPXX
.var HTRAP08 = $D648  // @HTRAPXX
.var HCPU_PCL = $D648  // Hypervisor PC-low register storage
.var PCL = $D648  // Hypervisor PC-low register storage
.var CPU_HTRAP09 = $D649  // @HTRAPXX
.var HTRAP09 = $D649  // @HTRAPXX
.var HCPU_PCH = $D649  // Hypervisor PC-high register storage
.var PCH = $D649  // Hypervisor PC-high register storage
.var CPU_HTRAP0A = $D64A  // @HTRAPXX
.var HTRAP0A = $D64A  // @HTRAPXX
.var HCPU_MAPLO = $D64A  // Hypervisor MAPLO register storage (high bits)
.var CPU_HTRAP0B = $D64B  // @HTRAPXX
.var HTRAP0B = $D64B  // @HTRAPXX
.var GS_HCPU_MAPLO = $D64B  // Hypervisor MAPLO register storage (low bits)
.var CPU_HTRAP0C = $D64C  // @HTRAPXX
.var HTRAP0C = $D64C  // @HTRAPXX
.var HCPU_MAPHI = $D64C  // Hypervisor MAPHI register storage (high bits)
.var CPU_HTRAP0D = $D64D  // @HTRAPXX
.var HTRAP0D = $D64D  // @HTRAPXX
.var GS_HCPU_MAPHI = $D64D  // Hypervisor MAPHI register storage (low bits)
.var CPU_HTRAP0E = $D64E  // @HTRAPXX
.var HTRAP0E = $D64E  // @HTRAPXX
.var HCPU_MAPLOMB = $D64E  // Hypervisor MAPLO mega-byte number register storage
.var MAPLOMB = $D64E  // Hypervisor MAPLO mega-byte number register storage
.var CPU_HTRAP0F = $D64F  // @HTRAPXX
.var HTRAP0F = $D64F  // @HTRAPXX
.var HCPU_MAPHIMB = $D64F  // Hypervisor MAPHI mega-byte number register storage
.var MAPHIMB = $D64F  // Hypervisor MAPHI mega-byte number register storage
.var CPU_HTRAP10 = $D650  // @HTRAPXX
.var HTRAP10 = $D650  // @HTRAPXX
.var HCPU_PORT00 = $D650  // Hypervisor CPU port \$00 value
.var PORT00 = $D650  // Hypervisor CPU port \$00 value
.var CPU_HTRAP11 = $D651  // @HTRAPXX
.var HTRAP11 = $D651  // @HTRAPXX
.var HCPU_PORT01 = $D651  // Hypervisor CPU port \$01 value
.var PORT01 = $D651  // Hypervisor CPU port \$01 value
.var CPU_HTRAP12 = $D652  // @HTRAPXX
.var HTRAP12 = $D652  // @HTRAPXX
.var HCPU_VICMODE_ADDR = $D652  // VIC-II/VIC-III/VIC-IV mode select (address)
.var VICMODE_ADDR = $D652  // VIC-II/VIC-III/VIC-IV mode select (address)
.var HCPU_VICMODE_MASK = %00000011  // VIC-II/VIC-III/VIC-IV mode select (bit mask)
.var VICMODE_MASK = %00000011  // VIC-II/VIC-III/VIC-IV mode select (bit mask)
.var HCPU_EXSID_ADDR = $D652  // 0=Use internal SIDs, 1=Use external(1) SIDs (address)
.var EXSID_ADDR = $D652  // 0=Use internal SIDs, 1=Use external(1) SIDs (address)
.var HCPU_EXSID_MASK = %00000100  // 0=Use internal SIDs, 1=Use external(1) SIDs (bit mask)
.var EXSID_MASK = %00000100  // 0=Use internal SIDs, 1=Use external(1) SIDs (bit mask)
.var CPU_HTRAP13 = $D653  // @HTRAPXX
.var HTRAP13 = $D653  // @HTRAPXX
.var HCPU_DMASRCMB = $D653  // Hypervisor DMAgic source MB
.var DMASRCMB = $D653  // Hypervisor DMAgic source MB
.var CPU_HTRAP14 = $D654  // @HTRAPXX
.var HTRAP14 = $D654  // @HTRAPXX
.var HCPU_DMADSTMB = $D654  // Hypervisor DMAgic destination MB
.var DMADSTMB = $D654  // Hypervisor DMAgic destination MB
.var CPU_HTRAP15 = $D655  // @HTRAPXX
.var HTRAP15 = $D655  // @HTRAPXX
.var HCPU_DMALADDR = $D655  // Hypervisor DMAGic list address bits 0-7
.var CPU_HTRAP16 = $D656  // @HTRAPXX
.var HTRAP16 = $D656  // @HTRAPXX
.var GS_HCPU_DMALADDR = $D656  // Hypervisor DMAGic list address bits 15-8
.var CPU_HTRAP17 = $D657  // @HTRAPXX
.var HTRAP17 = $D657  // @HTRAPXX
.var GS_HCPU_DMALADDR_2 = $D657  // Hypervisor DMAGic list address bits 23-16
.var CPU_HTRAP18 = $D658  // @HTRAPXX
.var HTRAP18 = $D658  // @HTRAPXX
.var GS_HCPU_DMALADDR_3 = $D658  // Hypervisor DMAGic list address bits 27-24
.var CPU_HTRAP19 = $D659  // @HTRAPXX
.var HTRAP19 = $D659  // @HTRAPXX
.var HCPU_VFLOP_ADDR = $D659  // 1=Virtualise SD/Floppy0 access (usually for access via serial debugger interface) (address)
.var HCPU_VFLOP_MASK = %00000001  // 1=Virtualise SD/Floppy0 access (usually for access via serial debugger interface) (bit mask)
.var GS_HCPU_VFLOP_ADDR = $D659  // 1=Virtualise SD/Floppy1 access (usually for access via serial debugger interface) (address)
.var GS_HCPU_VFLOP_MASK = %00000010  // 1=Virtualise SD/Floppy1 access (usually for access via serial debugger interface) (bit mask)
.var CPU_HTRAP1A = $D65A  // @HTRAPXX
.var HTRAP1A = $D65A  // @HTRAPXX
.var CPU_HTRAP1B = $D65B  // @HTRAPXX
.var HTRAP1B = $D65B  // @HTRAPXX
.var CPU_HTRAP1C = $D65C  // @HTRAPXX
.var HTRAP1C = $D65C  // @HTRAPXX
.var CPU_HTRAP1D = $D65D  // @HTRAPXX
.var HTRAP1D = $D65D  // @HTRAPXX
.var CPU_HTRAP1E = $D65E  // @HTRAPXX
.var HTRAP1E = $D65E  // @HTRAPXX
.var CPU_HTRAP1F = $D65F  // @HTRAPXX
.var HTRAP1F = $D65F  // @HTRAPXX
.var CPU_HTRAP20 = $D660  // @HTRAPXX
.var HTRAP20 = $D660  // @HTRAPXX
.var CPU_HTRAP21 = $D661  // @HTRAPXX
.var HTRAP21 = $D661  // @HTRAPXX
.var CPU_HTRAP22 = $D662  // @HTRAPXX
.var HTRAP22 = $D662  // @HTRAPXX
.var CPU_HTRAP23 = $D663  // @HTRAPXX
.var HTRAP23 = $D663  // @HTRAPXX
.var CPU_HTRAP24 = $D664  // @HTRAPXX
.var HTRAP24 = $D664  // @HTRAPXX
.var CPU_HTRAP25 = $D665  // @HTRAPXX
.var HTRAP25 = $D665  // @HTRAPXX
.var CPU_HTRAP26 = $D666  // @HTRAPXX
.var HTRAP26 = $D666  // @HTRAPXX
.var CPU_HTRAP27 = $D667  // @HTRAPXX
.var HTRAP27 = $D667  // @HTRAPXX
.var CPU_HTRAP28 = $D668  // @HTRAPXX
.var HTRAP28 = $D668  // @HTRAPXX
.var CPU_HTRAP29 = $D669  // @HTRAPXX
.var HTRAP29 = $D669  // @HTRAPXX
.var CPU_HTRAP2A = $D66A  // @HTRAPXX
.var HTRAP2A = $D66A  // @HTRAPXX
.var CPU_HTRAP2B = $D66B  // @HTRAPXX
.var HTRAP2B = $D66B  // @HTRAPXX
.var CPU_HTRAP2C = $D66C  // @HTRAPXX
.var HTRAP2C = $D66C  // @HTRAPXX
.var CPU_HTRAP2D = $D66D  // @HTRAPXX
.var HTRAP2D = $D66D  // @HTRAPXX
.var CPU_HTRAP2E = $D66E  // @HTRAPXX
.var HTRAP2E = $D66E  // @HTRAPXX
.var CPU_HTRAP2F = $D66F  // @HTRAPXX
.var HTRAP2F = $D66F  // @HTRAPXX
.var CPU_HTRAP30 = $D670  // @HTRAPXX
.var HTRAP30 = $D670  // @HTRAPXX
.var HCPU_GEORAMBASE = $D670  // Hypervisor GeoRAM base address (x MB)
.var GEORAMBASE = $D670  // Hypervisor GeoRAM base address (x MB)
.var CPU_HTRAP31 = $D671  // @HTRAPXX
.var HTRAP31 = $D671  // @HTRAPXX
.var HCPU_GEORAMMASK = $D671  // Hypervisor GeoRAM address mask (applied to GeoRAM block register)
.var GEORAMMASK = $D671  // Hypervisor GeoRAM address mask (applied to GeoRAM block register)
.var CPU_HTRAP32 = $D672  // @HTRAPXX
.var HTRAP32 = $D672  // @HTRAPXX
.var HCPU_MATRIXEN_ADDR = $D672  // Enable composited Matrix Mode, and disable UART access to serial monitor. (address)
.var MATRIXEN_ADDR = $D672  // Enable composited Matrix Mode, and disable UART access to serial monitor. (address)
.var HCPU_MATRIXEN_MASK = %01000000  // Enable composited Matrix Mode, and disable UART access to serial monitor. (bit mask)
.var MATRIXEN_MASK = %01000000  // Enable composited Matrix Mode, and disable UART access to serial monitor. (bit mask)
.var CPU_HTRAP33 = $D673  // @HTRAPXX
.var HTRAP33 = $D673  // @HTRAPXX
.var CPU_HTRAP34 = $D674  // @HTRAPXX
.var HTRAP34 = $D674  // @HTRAPXX
.var CPU_HTRAP35 = $D675  // @HTRAPXX
.var HTRAP35 = $D675  // @HTRAPXX
.var CPU_HTRAP36 = $D676  // @HTRAPXX
.var HTRAP36 = $D676  // @HTRAPXX
.var CPU_HTRAP37 = $D677  // @HTRAPXX
.var HTRAP37 = $D677  // @HTRAPXX
.var CPU_HTRAP38 = $D678  // @HTRAPXX
.var HTRAP38 = $D678  // @HTRAPXX
.var CPU_HTRAP39 = $D679  // @HTRAPXX
.var HTRAP39 = $D679  // @HTRAPXX
.var CPU_HTRAP3A = $D67A  // @HTRAPXX
.var HTRAP3A = $D67A  // @HTRAPXX
.var CPU_HTRAP3B = $D67B  // @HTRAPXX
.var HTRAP3B = $D67B  // @HTRAPXX
.var CPU_HTRAP3C = $D67C  // @HTRAPXX
.var HTRAP3C = $D67C  // @HTRAPXX
.var HCPU_UARTDATA_ADDR = $D67C  // (write) Hypervisor write serial output to UART monitor (address)
.var UARTDATA_ADDR = $D67C  // (write) Hypervisor write serial output to UART monitor (address)
.var HCPU_UARTDATA_MASK = %11111111  // (write) Hypervisor write serial output to UART monitor (bit mask)
.var UARTDATA_MASK = %11111111  // (write) Hypervisor write serial output to UART monitor (bit mask)
.var CPU_HTRAP3D = $D67D  // @HTRAPXX
.var HTRAP3D = $D67D  // @HTRAPXX
.var HCPU_WATCHDOG = $D67D  // Hypervisor watchdog register: writing any value clears the watch dog
.var WATCHDOG = $D67D  // Hypervisor watchdog register: writing any value clears the watch dog
.var HCPU_RSVD_ADDR = $D67D  // RESERVED (address)
.var RSVD_ADDR = $D67D  // RESERVED (address)
.var HCPU_RSVD_MASK = %00000001  // RESERVED (bit mask)
.var RSVD_MASK = %00000001  // RESERVED (bit mask)
.var HCPU_JMP32EN_ADDR = $D67D  // Hypervisor enable 32-bit JMP/JSR etc (address)
.var JMP32EN_ADDR = $D67D  // Hypervisor enable 32-bit JMP/JSR etc (address)
.var HCPU_JMP32EN_MASK = %00000010  // Hypervisor enable 32-bit JMP/JSR etc (bit mask)
.var JMP32EN_MASK = %00000010  // Hypervisor enable 32-bit JMP/JSR etc (bit mask)
.var HCPU_ROMPROT_ADDR = $D67D  // Hypervisor write protect C65 ROM \$20000-\$3FFFF (address)
.var ROMPROT_ADDR = $D67D  // Hypervisor write protect C65 ROM \$20000-\$3FFFF (address)
.var HCPU_ROMPROT_MASK = %00000100  // Hypervisor write protect C65 ROM \$20000-\$3FFFF (bit mask)
.var ROMPROT_MASK = %00000100  // Hypervisor write protect C65 ROM \$20000-\$3FFFF (bit mask)
.var HCPU_ASCFAST_ADDR = $D67D  // Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (address)
.var ASCFAST_ADDR = $D67D  // Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (address)
.var HCPU_ASCFAST_MASK = %00001000  // Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (bit mask)
.var ASCFAST_MASK = %00001000  // Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (bit mask)
.var HCPU_CPUFAST_ADDR = $D67D  // Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (address)
.var CPUFAST_ADDR = $D67D  // Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (address)
.var HCPU_CPUFAST_MASK = %00010000  // Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (bit mask)
.var CPUFAST_MASK = %00010000  // Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (bit mask)
.var HCPU_F4502_ADDR = $D67D  // Hypervisor force CPU to 4502 personality, even in C64 IO mode. (address)
.var F4502_ADDR = $D67D  // Hypervisor force CPU to 4502 personality, even in C64 IO mode. (address)
.var HCPU_F4502_MASK = %00100000  // Hypervisor force CPU to 4502 personality, even in C64 IO mode. (bit mask)
.var F4502_MASK = %00100000  // Hypervisor force CPU to 4502 personality, even in C64 IO mode. (bit mask)
.var HCPU_PIRQ_ADDR = $D67D  // Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (address)
.var PIRQ_ADDR = $D67D  // Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (address)
.var HCPU_PIRQ_MASK = %01000000  // Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (bit mask)
.var PIRQ_MASK = %01000000  // Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (bit mask)
.var HCPU_PNMI_ADDR = $D67D  // Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (address)
.var PNMI_ADDR = $D67D  // Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (address)
.var HCPU_PNMI_MASK = %10000000  // Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (bit mask)
.var PNMI_MASK = %10000000  // Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (bit mask)
.var CPU_HTRAP3E = $D67E  // @HTRAPXX
.var HTRAP3E = $D67E  // @HTRAPXX
.var HCPU_HICKED = $D67E  // Hypervisor already-upgraded bit (writing sets permanently)
.var HICKED = $D67E  // Hypervisor already-upgraded bit (writing sets permanently)
.var CPU_HTRAP3F = $D67F  // @HTRAPXX
.var HTRAP3F = $D67F  // @HTRAPXX
.var HCPU_ENTEREXIT = $D67F  // Writing trigger return from hypervisor
.var ENTEREXIT = $D67F  // Writing trigger return from hypervisor
.var SD_CMDANDSTAT = $D680  // SD controller status/command
.var CMDANDSTAT = $D680  // SD controller status/command
.var SD_SECTOR0 = $D681  // SD controller SD sector address (LSB)
.var SECTOR0 = $D681  // SD controller SD sector address (LSB)
.var SD_SECTOR1 = $D682  // SD controller SD sector address (2nd byte)
.var SECTOR1 = $D682  // SD controller SD sector address (2nd byte)
.var SD_SECTOR2 = $D683  // SD controller SD sector address (3rd byte)
.var SECTOR2 = $D683  // SD controller SD sector address (3rd byte)
.var SD_SECTOR3 = $D684  // SD controller SD sector address (MSB)
.var SECTOR3 = $D684  // SD controller SD sector address (MSB)
.var SD_FILLVAL = $D686  // WRITE ONLY set fill byte for use in fill mode, instead of SD buffer data
.var FILLVAL = $D686  // WRITE ONLY set fill byte for use in fill mode, instead of SD buffer data
.var SD_BUFBIT8_ADDR = $D689  // (read only) reads bit 8 of the sector buffer pointer (address)
.var BUFBIT8_ADDR = $D689  // (read only) reads bit 8 of the sector buffer pointer (address)
.var SD_BUFBIT8_MASK = %00000001  // (read only) reads bit 8 of the sector buffer pointer (bit mask)
.var BUFBIT8_MASK = %00000001  // (read only) reads bit 8 of the sector buffer pointer (bit mask)
.var SD_BUFFFULL_ADDR = $D689  // (read only) if set, indicates that the sector buffer is full and has not yet been read (address)
.var BUFFFULL_ADDR = $D689  // (read only) if set, indicates that the sector buffer is full and has not yet been read (address)
.var SD_BUFFFULL_MASK = %00000010  // (read only) if set, indicates that the sector buffer is full and has not yet been read (bit mask)
.var BUFFFULL_MASK = %00000010  // (read only) if set, indicates that the sector buffer is full and has not yet been read (bit mask)
.var SD_HNDSHK_ADDR = $D689  // Set/read SD card sd_handshake signal (address)
.var HNDSHK_ADDR = $D689  // Set/read SD card sd_handshake signal (address)
.var SD_HNDSHK_MASK = %00000100  // Set/read SD card sd_handshake signal (bit mask)
.var HNDSHK_MASK = %00000100  // Set/read SD card sd_handshake signal (bit mask)
.var SD_DRDY_ADDR = $D689  // SD Card Data Ready indication (address)
.var DRDY_ADDR = $D689  // SD Card Data Ready indication (address)
.var SD_DRDY_MASK = %00001000  // SD Card Data Ready indication (bit mask)
.var DRDY_MASK = %00001000  // SD Card Data Ready indication (bit mask)
.var SD_RESERVED_ADDR = $D689  // Reserved (address)
.var SD_RESERVED_MASK = %00010000  // Reserved (bit mask)
.var SD_FDCSWAP_ADDR = $D689  // Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (address)
.var FDCSWAP_ADDR = $D689  // Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (address)
.var SD_FDCSWAP_MASK = %00100000  // Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (bit mask)
.var FDCSWAP_MASK = %00100000  // Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (bit mask)
.var SD_BUFFSEL_ADDR = $D689  // Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (address)
.var BUFFSEL_ADDR = $D689  // Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (address)
.var SD_BUFFSEL_MASK = %10000000  // Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (bit mask)
.var BUFFSEL_MASK = %10000000  // Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (bit mask)
.var SD_CDC00_ADDR = $D68A  // (read only) Set if colour RAM at $DC00 (address)
.var CDC00_ADDR = $D68A  // (read only) Set if colour RAM at $DC00 (address)
.var SD_CDC00_MASK = %00000001  // (read only) Set if colour RAM at $DC00 (bit mask)
.var CDC00_MASK = %00000001  // (read only) Set if colour RAM at $DC00 (bit mask)
.var SD_VICIII_ADDR = $D68A  // (read only) Set if VIC-IV or ethernet IO bank visible (address)
.var VICIII_ADDR = $D68A  // (read only) Set if VIC-IV or ethernet IO bank visible (address)
.var SD_VICIII_MASK = %00000010  // (read only) Set if VIC-IV or ethernet IO bank visible (bit mask)
.var VICIII_MASK = %00000010  // (read only) Set if VIC-IV or ethernet IO bank visible (bit mask)
.var SD_VFDC0_ADDR = $D68A  // (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (address)
.var VFDC0_ADDR = $D68A  // (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (address)
.var SD_VFDC0_MASK = %00000100  // (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (bit mask)
.var VFDC0_MASK = %00000100  // (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (bit mask)
.var SD_VFDC1_ADDR = $D68A  // (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (address)
.var VFDC1_ADDR = $D68A  // (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (address)
.var SD_VFDC1_MASK = %00001000  // (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (bit mask)
.var VFDC1_MASK = %00001000  // (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (bit mask)
.var SDFDC_D0IMG_ADDR = $D68B  // F011 drive 0 use disk image if set, otherwise use real floppy drive. (address)
.var D0IMG_ADDR = $D68B  // F011 drive 0 use disk image if set, otherwise use real floppy drive. (address)
.var SDFDC_D0IMG_MASK = %00000001  // F011 drive 0 use disk image if set, otherwise use real floppy drive. (bit mask)
.var D0IMG_MASK = %00000001  // F011 drive 0 use disk image if set, otherwise use real floppy drive. (bit mask)
.var SDFDC_D0P_ADDR = $D68B  // F011 drive 0 media present (address)
.var D0P_ADDR = $D68B  // F011 drive 0 media present (address)
.var SDFDC_D0P_MASK = %00000010  // F011 drive 0 media present (bit mask)
.var D0P_MASK = %00000010  // F011 drive 0 media present (bit mask)
.var SDFDC_D0WP_ADDR = $D68B  // Write enable F011 drive 0 (address)
.var D0WP_ADDR = $D68B  // Write enable F011 drive 0 (address)
.var SDFDC_D0WP_MASK = %00000100  // Write enable F011 drive 0 (bit mask)
.var D0WP_MASK = %00000100  // Write enable F011 drive 0 (bit mask)
.var SDFDC_D1IMG_ADDR = $D68B  // F011 drive 1 use disk image if set, otherwise use real floppy drive. (address)
.var D1IMG_ADDR = $D68B  // F011 drive 1 use disk image if set, otherwise use real floppy drive. (address)
.var SDFDC_D1IMG_MASK = %00001000  // F011 drive 1 use disk image if set, otherwise use real floppy drive. (bit mask)
.var D1IMG_MASK = %00001000  // F011 drive 1 use disk image if set, otherwise use real floppy drive. (bit mask)
.var SDFDC_D1P_ADDR = $D68B  // F011 drive 1 media present (address)
.var D1P_ADDR = $D68B  // F011 drive 1 media present (address)
.var SDFDC_D1P_MASK = %00010000  // F011 drive 1 media present (bit mask)
.var D1P_MASK = %00010000  // F011 drive 1 media present (bit mask)
.var SDFDC_D1WP_ADDR = $D68B  // Write enable F011 drive 1 (address)
.var D1WP_ADDR = $D68B  // Write enable F011 drive 1 (address)
.var SDFDC_D1WP_MASK = %00100000  // Write enable F011 drive 1 (bit mask)
.var D1WP_MASK = %00100000  // Write enable F011 drive 1 (bit mask)
.var F011_MDISK0_ADDR = $D68B  // Enable 64MiB ``MEGA Disk'' for F011 emulated drive 0 (address)
.var F011_MDISK0_MASK = %01000000  // Enable 64MiB ``MEGA Disk'' for F011 emulated drive 0 (bit mask)
.var SDFDC_D0MD_ADDR = $D68B  // F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
.var D0MD_ADDR = $D68B  // F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
.var SDFDC_D0MD_MASK = %01000000  // F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
.var D0MD_MASK = %01000000  // F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
.var GS_F011_MDISK0_ADDR = $D68B  // Enable 64MiB ``MEGA Disk'' for F011 emulated drive 1 (address)
.var GS_F011_MDISK0_MASK = %10000000  // Enable 64MiB ``MEGA Disk'' for F011 emulated drive 1 (bit mask)
.var SDFDC_D1MD_ADDR = $D68B  // F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
.var D1MD_ADDR = $D68B  // F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
.var SDFDC_D1MD_MASK = %10000000  // F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
.var D1MD_MASK = %10000000  // F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
.var F011_DISKADDR0 = $D68C  // Diskimage sector number (bits 0-7)
.var DISKADDR0 = $D68C  // Diskimage sector number (bits 0-7)
.var SDFDC_D0STARTSEC0 = $D68C  // F011 drive 0 disk image address on SD card (LSB)
.var D0STARTSEC0 = $D68C  // F011 drive 0 disk image address on SD card (LSB)
.var F011_DISKADDR1 = $D68D  // Diskimage sector number (bits 8-15)
.var DISKADDR1 = $D68D  // Diskimage sector number (bits 8-15)
.var SDFDC_D0STARTSEC1 = $D68D  // F011 drive 0 disk image address on SD card (2nd byte)
.var D0STARTSEC1 = $D68D  // F011 drive 0 disk image address on SD card (2nd byte)
.var F011_DISKADDR2 = $D68E  // Diskimage sector number (bits 16-23)
.var DISKADDR2 = $D68E  // Diskimage sector number (bits 16-23)
.var SDFDC_D0STARTSEC2 = $D68E  // F011 drive 0 disk image address on SD card (3rd byte)
.var D0STARTSEC2 = $D68E  // F011 drive 0 disk image address on SD card (3rd byte)
.var F011_DISKADDR3 = $D68F  // Diskimage sector number (bits 24-31)
.var DISKADDR3 = $D68F  // Diskimage sector number (bits 24-31)
.var SDFDC_D0STARTSEC3 = $D68F  // F011 drive 0 disk image address on SD card (MSB)
.var D0STARTSEC3 = $D68F  // F011 drive 0 disk image address on SD card (MSB)
.var F011_DISK2ADDR0 = $D690  // Diskimage 2 sector number (bits 0-7)
.var DISK2ADDR0 = $D690  // Diskimage 2 sector number (bits 0-7)
.var SDFDC_D1STARTSEC0 = $D690  // F011 drive 1 disk image address on SD card (LSB)
.var D1STARTSEC0 = $D690  // F011 drive 1 disk image address on SD card (LSB)
.var F011_DISK2ADDR1 = $D691  // Diskimage 2 sector number (bits 8-15)
.var DISK2ADDR1 = $D691  // Diskimage 2 sector number (bits 8-15)
.var SDFDC_D1STARTSEC1 = $D691  // F011 drive 1 disk image address on SD card (2nd byte)
.var D1STARTSEC1 = $D691  // F011 drive 1 disk image address on SD card (2nd byte)
.var F011_DISK2ADDR2 = $D692  // Diskimage 2 sector number (bits 16-23)
.var DISK2ADDR2 = $D692  // Diskimage 2 sector number (bits 16-23)
.var SDFDC_D1STARTSEC2 = $D692  // F011 drive 1 disk image address on SD card (3rd byte)
.var D1STARTSEC2 = $D692  // F011 drive 1 disk image address on SD card (3rd byte)
.var F011_DISK2ADDR3 = $D693  // Diskimage 2 sector number (bits 24-31)
.var DISK2ADDR3 = $D693  // Diskimage 2 sector number (bits 24-31)
.var SDFDC_D1STARTSEC3 = $D693  // F011 drive 1 disk image address on SD card (MSB)
.var D1STARTSEC3 = $D693  // F011 drive 1 disk image address on SD card (MSB)
.var F011_AUTOTUNE = $D696  // Enable automatic track seeking for sector reads and writes
.var AUTOTUNE = $D696  // Enable automatic track seeking for sector reads and writes
.var DEBUG_J21INL = $D69B  // Status of M65 R3 J21 pins
.var J21INL = $D69B  // Status of M65 R3 J21 pins
.var DEBUG_J21INH = $D69C  // Status of M65 R3 J21 pins
.var J21INH = $D69C  // Status of M65 R3 J21 pins
.var DEBUG_DIPSW = $D69D  // Status of M65 R3 DIP switches
.var DIPSW = $D69D  // Status of M65 R3 DIP switches
.var DEBUG_SWSTATUS = $D69E  // Status of switches 0 to 7
.var GS_DEBUG_SWSTATUS = $D69F  // Status of switches 8 to 15
.var FDC_DBGWGATE_ADDR = $D6A0  // Control floppy drive SIDE1 line (address)
.var FDC_DBGWGATE_MASK = %00000001  // Control floppy drive SIDE1 line (bit mask)
.var GS_FDC_DBGWGATE_ADDR = $D6A0  // Control floppy drive WGATE line (address)
.var GS_FDC_DBGWGATE_MASK = %00000010  // Control floppy drive WGATE line (bit mask)
.var FDC_DBGWDATA_ADDR = $D6A0  // Control floppy drive WDATA line (address)
.var DBGWDATA_ADDR = $D6A0  // Control floppy drive WDATA line (address)
.var FDC_DBGWDATA_MASK = %00000100  // Control floppy drive WDATA line (bit mask)
.var DBGWDATA_MASK = %00000100  // Control floppy drive WDATA line (bit mask)
.var FDC_DBGDIR_ADDR = $D6A0  // Control floppy drive STEP line (address)
.var FDC_DBGDIR_MASK = %00001000  // Control floppy drive STEP line (bit mask)
.var GS_FDC_DBGDIR_ADDR = $D6A0  // Control floppy drive STEPDIR line (address)
.var GS_FDC_DBGDIR_MASK = %00010000  // Control floppy drive STEPDIR line (bit mask)
.var FDC_DBGMOTORA_ADDR = $D6A0  // Control floppy drive SELECT line (address)
.var FDC_DBGMOTORA_MASK = %00100000  // Control floppy drive SELECT line (bit mask)
.var GS_FDC_DBGMOTORA_ADDR = $D6A0  // Control floppy drive MOTOR line (address)
.var GS_FDC_DBGMOTORA_MASK = %01000000  // Control floppy drive MOTOR line (bit mask)
.var FDC_DENSITY_ADDR = $D6A0  // Control floppy drive density select line (address)
.var DENSITY_ADDR = $D6A0  // Control floppy drive density select line (address)
.var FDC_DENSITY_MASK = %10000000  // Control floppy drive density select line (bit mask)
.var DENSITY_MASK = %10000000  // Control floppy drive density select line (bit mask)
.var F011_DRV0EN_ADDR = $D6A1  // Use real floppy drive instead of SD card for 1st floppy drive (address)
.var DRV0EN_ADDR = $D6A1  // Use real floppy drive instead of SD card for 1st floppy drive (address)
.var F011_DRV0EN_MASK = %00000001  // Use real floppy drive instead of SD card for 1st floppy drive (bit mask)
.var DRV0EN_MASK = %00000001  // Use real floppy drive instead of SD card for 1st floppy drive (bit mask)
.var SDFDC_USEREAL0_ADDR = $D6A1  // Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (address)
.var USEREAL0_ADDR = $D6A1  // Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (address)
.var SDFDC_USEREAL0_MASK = %00000001  // Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (bit mask)
.var USEREAL0_MASK = %00000001  // Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (bit mask)
.var SDFDC_TARGANY_ADDR = $D6A1  // Read next sector under head if set, ignoring the requested side, track and sector number. (address)
.var TARGANY_ADDR = $D6A1  // Read next sector under head if set, ignoring the requested side, track and sector number. (address)
.var SDFDC_TARGANY_MASK = %00000010  // Read next sector under head if set, ignoring the requested side, track and sector number. (bit mask)
.var TARGANY_MASK = %00000010  // Read next sector under head if set, ignoring the requested side, track and sector number. (bit mask)
.var F011_DRV2EN_ADDR = $D6A1  // Use real floppy drive instead of SD card for 2nd floppy drive (address)
.var DRV2EN_ADDR = $D6A1  // Use real floppy drive instead of SD card for 2nd floppy drive (address)
.var F011_DRV2EN_MASK = %00000100  // Use real floppy drive instead of SD card for 2nd floppy drive (bit mask)
.var DRV2EN_MASK = %00000100  // Use real floppy drive instead of SD card for 2nd floppy drive (bit mask)
.var SDFDC_USEREAL1_ADDR = $D6A1  // Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (address)
.var USEREAL1_ADDR = $D6A1  // Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (address)
.var SDFDC_USEREAL1_MASK = %00000100  // Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (bit mask)
.var USEREAL1_MASK = %00000100  // Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (bit mask)
.var SDFDC_SILENT_ADDR = $D6A1  // Disable floppy spinning and tracking for SD card operations. (address)
.var SILENT_ADDR = $D6A1  // Disable floppy spinning and tracking for SD card operations. (address)
.var SDFDC_SILENT_MASK = %00001000  // Disable floppy spinning and tracking for SD card operations. (bit mask)
.var SILENT_MASK = %00001000  // Disable floppy spinning and tracking for SD card operations. (bit mask)
.var FDC_DATARATE = $D6A2  // Set number of bus cycles per floppy magnetic interval (decrease to increase data rate)
.var DATARATE = $D6A2  // Set number of bus cycles per floppy magnetic interval (decrease to increase data rate)
.var MISCIO_WHEEL3TARGET_ADDR = $D6AC  // Select audio channel volume to be set by thumb wheel #3 (address)
.var WHEEL3TARGET_ADDR = $D6AC  // Select audio channel volume to be set by thumb wheel #3 (address)
.var MISCIO_WHEEL3TARGET_MASK = %00001111  // Select audio channel volume to be set by thumb wheel #3 (bit mask)
.var WHEEL3TARGET_MASK = %00001111  // Select audio channel volume to be set by thumb wheel #3 (bit mask)
.var MISCIO_WHEELBRIGHTEN_ADDR = $D6AC  // Enable control of LCD panel brightness via thumb wheel (address)
.var WHEELBRIGHTEN_ADDR = $D6AC  // Enable control of LCD panel brightness via thumb wheel (address)
.var MISCIO_WHEELBRIGHTEN_MASK = %10000000  // Enable control of LCD panel brightness via thumb wheel (bit mask)
.var WHEELBRIGHTEN_MASK = %10000000  // Enable control of LCD panel brightness via thumb wheel (bit mask)
.var MISCIO_WHEEL1TARGET_ADDR = $D6AD  // Select audio channel volume to be set by thumb wheel #1 (address)
.var WHEEL1TARGET_ADDR = $D6AD  // Select audio channel volume to be set by thumb wheel #1 (address)
.var MISCIO_WHEEL1TARGET_MASK = %00001111  // Select audio channel volume to be set by thumb wheel #1 (bit mask)
.var WHEEL1TARGET_MASK = %00001111  // Select audio channel volume to be set by thumb wheel #1 (bit mask)
.var MISCIO_WHEEL2TARGET_ADDR = $D6AD  // Select audio channel volume to be set by thumb wheel #2 (address)
.var WHEEL2TARGET_ADDR = $D6AD  // Select audio channel volume to be set by thumb wheel #2 (address)
.var MISCIO_WHEEL2TARGET_MASK = %11110000  // Select audio channel volume to be set by thumb wheel #2 (bit mask)
.var WHEEL2TARGET_MASK = %11110000  // Select audio channel volume to be set by thumb wheel #2 (bit mask)
.var SD_FDC_ENC_ADDR = $D6AE  // Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (address)
.var FDC_ENC_ADDR = $D6AE  // Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (address)
.var SD_FDC_ENC_MASK = %00001111  // Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (bit mask)
.var FDC_ENC_MASK = %00001111  // Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (bit mask)
.var SD_AUTO_2XSEL_ADDR = $D6AE  // Automatically select DD or HD decoder for last sector display (address)
.var AUTO_2XSEL_ADDR = $D6AE  // Automatically select DD or HD decoder for last sector display (address)
.var SD_AUTO_2XSEL_MASK = %00010000  // Automatically select DD or HD decoder for last sector display (bit mask)
.var AUTO_2XSEL_MASK = %00010000  // Automatically select DD or HD decoder for last sector display (bit mask)
.var SD_FDC_VARSPD_ADDR = $D6AE  // Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (address)
.var FDC_VARSPD_ADDR = $D6AE  // Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (address)
.var SD_FDC_VARSPD_MASK = %00100000  // Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (bit mask)
.var FDC_VARSPD_MASK = %00100000  // Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (bit mask)
.var SD_FDC_2XSEL_ADDR = $D6AE  // Select HD decoder for last sector display (address)
.var FDC_2XSEL_ADDR = $D6AE  // Select HD decoder for last sector display (address)
.var SD_FDC_2XSEL_MASK = %01000000  // Select HD decoder for last sector display (bit mask)
.var FDC_2XSEL_MASK = %01000000  // Select HD decoder for last sector display (bit mask)
.var SD_FDC_TIBEN_ADDR = $D6AE  // Enable use of Track Info Block settings (address)
.var FDC_TIBEN_ADDR = $D6AE  // Enable use of Track Info Block settings (address)
.var SD_FDC_TIBEN_MASK = %10000000  // Enable use of Track Info Block settings (bit mask)
.var FDC_TIBEN_MASK = %10000000  // Enable use of Track Info Block settings (bit mask)
.var SD_VR_FOUND_ADDR = $D6AF  // Manually set f011_rsector_found signal (indented for virtual F011 mode only) (address)
.var VR_FOUND_ADDR = $D6AF  // Manually set f011_rsector_found signal (indented for virtual F011 mode only) (address)
.var SD_VR_FOUND_MASK = %00000001  // Manually set f011_rsector_found signal (indented for virtual F011 mode only) (bit mask)
.var VR_FOUND_MASK = %00000001  // Manually set f011_rsector_found signal (indented for virtual F011 mode only) (bit mask)
.var SD_VW_FOUND_ADDR = $D6AF  // Manually set f011_wsector_found signal (indented for virtual F011 mode only) (address)
.var VW_FOUND_ADDR = $D6AF  // Manually set f011_wsector_found signal (indented for virtual F011 mode only) (address)
.var SD_VW_FOUND_MASK = %00000010  // Manually set f011_wsector_found signal (indented for virtual F011 mode only) (bit mask)
.var VW_FOUND_MASK = %00000010  // Manually set f011_wsector_found signal (indented for virtual F011 mode only) (bit mask)
.var SD_VEQ_INH_ADDR = $D6AF  // Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (address)
.var VEQ_INH_ADDR = $D6AF  // Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (address)
.var SD_VEQ_INH_MASK = %00000100  // Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (bit mask)
.var VEQ_INH_MASK = %00000100  // Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (bit mask)
.var SD_VRNF_ADDR = $D6AF  // Manually set f011_rnf signal (indented for virtual F011 mode only) (address)
.var VRNF_ADDR = $D6AF  // Manually set f011_rnf signal (indented for virtual F011 mode only) (address)
.var SD_VRNF_MASK = %00001000  // Manually set f011_rnf signal (indented for virtual F011 mode only) (bit mask)
.var VRNF_MASK = %00001000  // Manually set f011_rnf signal (indented for virtual F011 mode only) (bit mask)
.var SD_VDRQ_ADDR = $D6AF  // Manually set f011_drq signal (indented for virtual F011 mode only) (address)
.var VDRQ_ADDR = $D6AF  // Manually set f011_drq signal (indented for virtual F011 mode only) (address)
.var SD_VDRQ_MASK = %00010000  // Manually set f011_drq signal (indented for virtual F011 mode only) (bit mask)
.var VDRQ_MASK = %00010000  // Manually set f011_drq signal (indented for virtual F011 mode only) (bit mask)
.var SD_VLOST_ADDR = $D6AF  // Manually set f011_lost signal (indented for virtual F011 mode only) (address)
.var VLOST_ADDR = $D6AF  // Manually set f011_lost signal (indented for virtual F011 mode only) (address)
.var SD_VLOST_MASK = %00100000  // Manually set f011_lost signal (indented for virtual F011 mode only) (bit mask)
.var VLOST_MASK = %00100000  // Manually set f011_lost signal (indented for virtual F011 mode only) (bit mask)
.var TOUCH_EV1_ADDR = $D6B0  // Touch event 1 is valid (address)
.var EV1_ADDR = $D6B0  // Touch event 1 is valid (address)
.var TOUCH_EV1_MASK = %00000001  // Touch event 1 is valid (bit mask)
.var EV1_MASK = %00000001  // Touch event 1 is valid (bit mask)
.var TOUCH_EV2_ADDR = $D6B0  // Touch event 2 is valid (address)
.var EV2_ADDR = $D6B0  // Touch event 2 is valid (address)
.var TOUCH_EV2_MASK = %00000010  // Touch event 2 is valid (bit mask)
.var EV2_MASK = %00000010  // Touch event 2 is valid (bit mask)
.var TOUCH_UPDN1_ADDR = $D6B0  // Touch event 1 up/down state (address)
.var UPDN1_ADDR = $D6B0  // Touch event 1 up/down state (address)
.var TOUCH_UPDN1_MASK = %00001100  // Touch event 1 up/down state (bit mask)
.var UPDN1_MASK = %00001100  // Touch event 1 up/down state (bit mask)
.var TOUCH_UPDN2_ADDR = $D6B0  // Touch event 2 up/down state (address)
.var UPDN2_ADDR = $D6B0  // Touch event 2 up/down state (address)
.var TOUCH_UPDN2_MASK = %00110000  // Touch event 2 up/down state (bit mask)
.var UPDN2_MASK = %00110000  // Touch event 2 up/down state (bit mask)
.var MISCIO_TCHFLX_ADDR = $D6B0  // Flip X axis of touch interface if set (address)
.var MISCIO_TCHFLX_MASK = %01000000  // Flip X axis of touch interface if set (bit mask)
.var TOUCH_XINV_ADDR = $D6B0  // Invert horizontal axis (address)
.var XINV_ADDR = $D6B0  // Invert horizontal axis (address)
.var TOUCH_XINV_MASK = %01000000  // Invert horizontal axis (bit mask)
.var XINV_MASK = %01000000  // Invert horizontal axis (bit mask)
.var GS_MISCIO_TCHFLX_ADDR = $D6B0  // Flip Y axis of touch interface if set (address)
.var GS_MISCIO_TCHFLX_MASK = %10000000  // Flip Y axis of touch interface if set (bit mask)
.var TOUCH_YINV_ADDR = $D6B0  // Invert vertical axis (address)
.var YINV_ADDR = $D6B0  // Invert vertical axis (address)
.var TOUCH_YINV_MASK = %10000000  // Invert vertical axis (bit mask)
.var YINV_MASK = %10000000  // Invert vertical axis (bit mask)
.var MISCIO_TCHXSCALE = $D6B1  // Set X scale value for touch interface (LSB)
.var TOUCH_CALXSCALELSB = $D6B1  // Touch pad X scaling LSB
.var CALXSCALELSB = $D6B1  // Touch pad X scaling LSB
.var GS_MISCIO_TCHXSCALE = $D6B2  // Set X scale value for touch interface (MSB)
.var TOUCH_CALXSCALEMSB = $D6B2  // Touch pad X scaling MSB
.var CALXSCALEMSB = $D6B2  // Touch pad X scaling MSB
.var MISCIO_TCHYSCALE = $D6B3  // Set Y scale value for touch interface (LSB)
.var TOUCH_CALYSCALELSB = $D6B3  // Touch pad Y scaling LSB
.var CALYSCALELSB = $D6B3  // Touch pad Y scaling LSB
.var GS_MISCIO_TCHYSCALE = $D6B4  // Set Y scale value for touch interface (MSB)
.var TOUCH_CALYSCALEMSB = $D6B4  // Touch pad Y scaling MSB
.var CALYSCALEMSB = $D6B4  // Touch pad Y scaling MSB
.var MISCIO_TCHXDELTA = $D6B5  // Set X delta value for touch interface (LSB)
.var TOUCH_CALXDELTALSB = $D6B5  // Touch pad X delta LSB
.var CALXDELTALSB = $D6B5  // Touch pad X delta LSB
.var MISCIO_TCHYDELTA = $D6B7  // Set Y delta value for touch interface (LSB)
.var TOUCH_CALYDELTALSB = $D6B7  // Touch pad Y delta LSB
.var CALYDELTALSB = $D6B7  // Touch pad Y delta LSB
.var GS_MISCIO_TCHYDELTA = $D6B8  // Set Y delta value for touch interface (MSB)
.var TOUCH_CALYDELTAMSB = $D6B8  // Touch pad Y delta MSB
.var CALYDELTAMSB = $D6B8  // Touch pad Y delta MSB
.var TOUCH_TOUCH1XLSB = $D6B9  // Touch pad touch #1 X LSB
.var TOUCH1XLSB = $D6B9  // Touch pad touch #1 X LSB
.var TOUCH_TOUCH1YLSB = $D6BA  // Touch pad touch #1 Y LSB
.var TOUCH1YLSB = $D6BA  // Touch pad touch #1 Y LSB
.var GS_MISCIO_TCHXDELTA = $D6BB  // Set X delta value for touch interface (MSB)
.var TOUCH_TOUCH1XMSB_ADDR = $D6BB  // Touch pad touch \#1 X MSBs (address)
.var TOUCH1XMSB_ADDR = $D6BB  // Touch pad touch \#1 X MSBs (address)
.var TOUCH_TOUCH1XMSB_MASK = %00000011  // Touch pad touch \#1 X MSBs (bit mask)
.var TOUCH1XMSB_MASK = %00000011  // Touch pad touch \#1 X MSBs (bit mask)
.var TOUCH_TOUCH1YMSB_ADDR = $D6BB  // Touch pad touch \#1 Y MSBs (address)
.var TOUCH1YMSB_ADDR = $D6BB  // Touch pad touch \#1 Y MSBs (address)
.var TOUCH_TOUCH1YMSB_MASK = %00110000  // Touch pad touch \#1 Y MSBs (bit mask)
.var TOUCH1YMSB_MASK = %00110000  // Touch pad touch \#1 Y MSBs (bit mask)
.var TOUCH_TOUCH2XLSB = $D6BC  // Touch pad touch \#2 X LSB
.var TOUCH2XLSB = $D6BC  // Touch pad touch \#2 X LSB
.var TOUCH_TOUCH2YLSB = $D6BD  // Touch pad touch \#2 Y LSB
.var TOUCH2YLSB = $D6BD  // Touch pad touch \#2 Y LSB
.var TOUCH_TOUCH2XMSB_ADDR = $D6BE  // Touch pad touch \#2 X MSBs (address)
.var TOUCH2XMSB_ADDR = $D6BE  // Touch pad touch \#2 X MSBs (address)
.var TOUCH_TOUCH2XMSB_MASK = %00000011  // Touch pad touch \#2 X MSBs (bit mask)
.var TOUCH2XMSB_MASK = %00000011  // Touch pad touch \#2 X MSBs (bit mask)
.var TOUCH_TOUCH2YMSB_ADDR = $D6BE  // Touch pad touch \#2 Y MSBs (address)
.var TOUCH2YMSB_ADDR = $D6BE  // Touch pad touch \#2 Y MSBs (address)
.var TOUCH_TOUCH2YMSB_MASK = %00110000  // Touch pad touch \#2 Y MSBs (bit mask)
.var TOUCH2YMSB_MASK = %00110000  // Touch pad touch \#2 Y MSBs (bit mask)
.var MISCIO_TCHBYTENUM_ADDR = $D6BF  // Select byte number for touch panel communications instrumentation (address)
.var TCHBYTENUM_ADDR = $D6BF  // Select byte number for touch panel communications instrumentation (address)
.var MISCIO_TCHBYTENUM_MASK = %01111111  // Select byte number for touch panel communications instrumentation (bit mask)
.var TCHBYTENUM_MASK = %01111111  // Select byte number for touch panel communications instrumentation (bit mask)
.var MISCIO_TCHI2CEN_ADDR = $D6BF  // Enable/disable touch panel I2C communications (address)
.var TCHI2CEN_ADDR = $D6BF  // Enable/disable touch panel I2C communications (address)
.var MISCIO_TCHI2CEN_MASK = %10000000  // Enable/disable touch panel I2C communications (bit mask)
.var TCHI2CEN_MASK = %10000000  // Enable/disable touch panel I2C communications (bit mask)
.var TOUCH_GESTUREDIR_ADDR = $D6C0  // Touch pad gesture directions (left,right,up,down) (address)
.var GESTUREDIR_ADDR = $D6C0  // Touch pad gesture directions (left,right,up,down) (address)
.var TOUCH_GESTUREDIR_MASK = %00001111  // Touch pad gesture directions (left,right,up,down) (bit mask)
.var GESTUREDIR_MASK = %00001111  // Touch pad gesture directions (left,right,up,down) (bit mask)
.var TOUCH_GESTUREID_ADDR = $D6C0  // Touch pad gesture ID (address)
.var GESTUREID_ADDR = $D6C0  // Touch pad gesture ID (address)
.var TOUCH_GESTUREID_MASK = %11110000  // Touch pad gesture ID (bit mask)
.var GESTUREID_MASK = %11110000  // Touch pad gesture ID (bit mask)
.var FPGA_REGNUM = $D6C4  // Select ICAPE2 FPGA configuration register for reading WRITE ONLY
.var REGNUM = $D6C4  // Select ICAPE2 FPGA configuration register for reading WRITE ONLY
.var FPGA_REGVAL = $D6C4  // Value of selected ICAPE2 register (least significant byte)
.var GS_FPGA_REGVAL = $D6C5  // Value of selected ICAPE2 register
.var GS_FPGA_REGVAL_2 = $D6C6  // Value of selected ICAPE2 register
.var GS_FPGA_REGVAL_3 = $D6C7  // Value of selected ICAPE2 register (most significant byte)
.var FPGA_BOOTADDR0 = $D6C8  // Address of bitstream in boot flash for reconfiguration (least significant byte)
.var BOOTADDR0 = $D6C8  // Address of bitstream in boot flash for reconfiguration (least significant byte)
.var FPGA_BOOTADDR1 = $D6C9  // Address of bitstream in boot flash for reconfiguration
.var BOOTADDR1 = $D6C9  // Address of bitstream in boot flash for reconfiguration
.var FPGA_BOOTADDR2 = $D6CA  // Address of bitstream in boot flash for reconfiguration
.var BOOTADDR2 = $D6CA  // Address of bitstream in boot flash for reconfiguration
.var FPGA_BOOTADDR3 = $D6CB  // Address of bitstream in boot flash for reconfiguration (most significant byte)
.var BOOTADDR3 = $D6CB  // Address of bitstream in boot flash for reconfiguration (most significant byte)
.var QSPI_DB_ADDR = $D6CC  // Data bits for QSPI flash interface (read/write) (address)
.var DB_ADDR = $D6CC  // Data bits for QSPI flash interface (read/write) (address)
.var QSPI_DB_MASK = %00001111  // Data bits for QSPI flash interface (read/write) (bit mask)
.var DB_MASK = %00001111  // Data bits for QSPI flash interface (read/write) (bit mask)
.var QSPI_RESERVED_ADDR = $D6CC  // (set to 0) (address)
.var QSPI_RESERVED_MASK = %00010000  // (set to 0) (bit mask)
.var QSPI_CLOCK_ADDR = $D6CC  // Clock output line for QSPI flash (address)
.var QSPI_CLOCK_MASK = %00100000  // Clock output line for QSPI flash (bit mask)
.var QSPI_CSN_ADDR = $D6CC  // Active-low chip-select for QSPI flash (address)
.var CSN_ADDR = $D6CC  // Active-low chip-select for QSPI flash (address)
.var QSPI_CSN_MASK = %01000000  // Active-low chip-select for QSPI flash (bit mask)
.var CSN_MASK = %01000000  // Active-low chip-select for QSPI flash (bit mask)
.var QSPI_TRI_ADDR = $D6CC  // Tristate DB0-3 (address)
.var TRI_ADDR = $D6CC  // Tristate DB0-3 (address)
.var QSPI_TRI_MASK = %10000000  // Tristate DB0-3 (bit mask)
.var TRI_MASK = %10000000  // Tristate DB0-3 (bit mask)
.var QSPI_CLOCKRUN_ADDR = $D6CD  // Set to cause QSPI clock to free run at CPU clock frequency. (address)
.var CLOCKRUN_ADDR = $D6CD  // Set to cause QSPI clock to free run at CPU clock frequency. (address)
.var QSPI_CLOCKRUN_MASK = %00000001  // Set to cause QSPI clock to free run at CPU clock frequency. (bit mask)
.var CLOCKRUN_MASK = %00000001  // Set to cause QSPI clock to free run at CPU clock frequency. (bit mask)
.var GS_QSPI_CLOCK_ADDR = $D6CD  // Alternate address for direct manipulation of QSPI CLOCK (address)
.var GS_QSPI_CLOCK_MASK = %00000010  // Alternate address for direct manipulation of QSPI CLOCK (bit mask)
.var FPGA_RECONFTRIG = $D6CF  // Write $42 to Trigger FPGA reconfiguration to switch to alternate bitstream.
.var RECONFTRIG = $D6CF  // Write $42 to Trigger FPGA reconfiguration to switch to alternate bitstream.
.var MISC_I2CBUSSELECT = $D6D0  // I2C bus select (bus 0 = temp sensor on Nexys4 boardS)
.var I2CBUSSELECT = $D6D0  // I2C bus select (bus 0 = temp sensor on Nexys4 boardS)
.var MISCIO_I2CBUSSEL = $D6D0  // Select I2C bus number (I2C busses vary between MEGA65 and MEGAphone variants)
.var I2CBUSSEL = $D6D0  // Select I2C bus number (I2C busses vary between MEGA65 and MEGAphone variants)
.var MISCIO_I2CRST_ADDR = $D6D1  // I2C reset (address)
.var I2CRST_ADDR = $D6D1  // I2C reset (address)
.var MISCIO_I2CRST_MASK = %00000001  // I2C reset (bit mask)
.var I2CRST_MASK = %00000001  // I2C reset (bit mask)
.var MISCIO_I2CL_ADDR = $D6D1  // I2C command latch write strobe (write 1 to trigger command) (address)
.var I2CL_ADDR = $D6D1  // I2C command latch write strobe (write 1 to trigger command) (address)
.var MISCIO_I2CL_MASK = %00000010  // I2C command latch write strobe (write 1 to trigger command) (bit mask)
.var I2CL_MASK = %00000010  // I2C command latch write strobe (write 1 to trigger command) (bit mask)
.var MISCIO_I2CRW_ADDR = $D6D1  // I2C Select read (1) or write (0) (address)
.var I2CRW_ADDR = $D6D1  // I2C Select read (1) or write (0) (address)
.var MISCIO_I2CRW_MASK = %00000100  // I2C Select read (1) or write (0) (bit mask)
.var I2CRW_MASK = %00000100  // I2C Select read (1) or write (0) (bit mask)
.var MISCIO_I2CSW_ADDR = $D6D1  // I2C bus 1 swap SDA/SCL pins (address)
.var I2CSW_ADDR = $D6D1  // I2C bus 1 swap SDA/SCL pins (address)
.var MISCIO_I2CSW_MASK = %00100000  // I2C bus 1 swap SDA/SCL pins (bit mask)
.var I2CSW_MASK = %00100000  // I2C bus 1 swap SDA/SCL pins (bit mask)
.var MISCIO_I2CBSY_ADDR = $D6D1  // I2C busy flag (address)
.var I2CBSY_ADDR = $D6D1  // I2C busy flag (address)
.var MISCIO_I2CBSY_MASK = %01000000  // I2C busy flag (bit mask)
.var I2CBSY_MASK = %01000000  // I2C busy flag (bit mask)
.var MISCIO_I2CERR_ADDR = $D6D1  // I2C ack error (address)
.var I2CERR_ADDR = $D6D1  // I2C ack error (address)
.var MISCIO_I2CERR_MASK = %10000000  // I2C ack error (bit mask)
.var I2CERR_MASK = %10000000  // I2C ack error (bit mask)
.var MISCIO_I2CADDR_ADDR = $D6D2  // I2C address (address)
.var I2CADDR_ADDR = $D6D2  // I2C address (address)
.var MISCIO_I2CADDR_MASK = %11111110  // I2C address (bit mask)
.var I2CADDR_MASK = %11111110  // I2C address (bit mask)
.var MISCIO_I2CWDATA = $D6D3  // I2C data write register
.var I2CWDATA = $D6D3  // I2C data write register
.var MISCIO_I2CRDATA = $D6D4  // I2C data read register
.var I2CRDATA = $D6D4  // I2C data read register
.var MISC_SDDEBUGERRLSB = $D6DA  // DEBUG SD card last error code LSB
.var SDDEBUGERRLSB = $D6DA  // DEBUG SD card last error code LSB
.var MISC_SDDEBUGERRMSB = $D6DB  // DEBUG SD card last error code MSB
.var SDDEBUGERRMSB = $D6DB  // DEBUG SD card last error code MSB
.var FPGA_FPGATEMPLSB = $D6DE  // FPGA die temperature sensor (lower nybl)
.var FPGATEMPLSB = $D6DE  // FPGA die temperature sensor (lower nybl)
.var FPGA_FPGATEMPMSB = $D6DF  // FPGA die temperature sensor (upper byte)
.var FPGATEMPMSB = $D6DF  // FPGA die temperature sensor (upper byte)
.var ETH_RST_ADDR = $D6E0  // Write 0 to hold ethernet controller under reset (address)
.var ETH_RST_MASK = %00000001  // Write 0 to hold ethernet controller under reset (bit mask)
.var ETH_TXRST_ADDR = $D6E0  // Write 0 to hold ethernet controller transmit sub-system under reset (address)
.var TXRST_ADDR = $D6E0  // Write 0 to hold ethernet controller transmit sub-system under reset (address)
.var ETH_TXRST_MASK = %00000010  // Write 0 to hold ethernet controller transmit sub-system under reset (bit mask)
.var TXRST_MASK = %00000010  // Write 0 to hold ethernet controller transmit sub-system under reset (bit mask)
.var ETH_DRXD_ADDR = $D6E0  // Read ethernet RX bits currently on the wire (address)
.var DRXD_ADDR = $D6E0  // Read ethernet RX bits currently on the wire (address)
.var ETH_DRXD_MASK = %00000100  // Read ethernet RX bits currently on the wire (bit mask)
.var DRXD_MASK = %00000100  // Read ethernet RX bits currently on the wire (bit mask)
.var ETH_DRXDV_ADDR = $D6E0  // Read ethernet RX data valid (debug) (address)
.var DRXDV_ADDR = $D6E0  // Read ethernet RX data valid (debug) (address)
.var ETH_DRXDV_MASK = %00001000  // Read ethernet RX data valid (debug) (bit mask)
.var DRXDV_MASK = %00001000  // Read ethernet RX data valid (debug) (bit mask)
.var ETH_KEYEN_ADDR = $D6E0  // Allow remote keyboard input via magic ethernet frames (address)
.var KEYEN_ADDR = $D6E0  // Allow remote keyboard input via magic ethernet frames (address)
.var ETH_KEYEN_MASK = %00010000  // Allow remote keyboard input via magic ethernet frames (bit mask)
.var KEYEN_MASK = %00010000  // Allow remote keyboard input via magic ethernet frames (bit mask)
.var ETH_RXBLKD_ADDR = $D6E0  // Indicate if ethernet RX is blocked until RX buffers freed (address)
.var RXBLKD_ADDR = $D6E0  // Indicate if ethernet RX is blocked until RX buffers freed (address)
.var ETH_RXBLKD_MASK = %01000000  // Indicate if ethernet RX is blocked until RX buffers freed (bit mask)
.var RXBLKD_MASK = %01000000  // Indicate if ethernet RX is blocked until RX buffers freed (bit mask)
.var ETH_TXIDLE_ADDR = $D6E0  // Ethernet transmit side is idle, i.e., a packet can be sent. (address)
.var TXIDLE_ADDR = $D6E0  // Ethernet transmit side is idle, i.e., a packet can be sent. (address)
.var ETH_TXIDLE_MASK = %10000000  // Ethernet transmit side is idle, i.e., a packet can be sent. (bit mask)
.var TXIDLE_MASK = %10000000  // Ethernet transmit side is idle, i.e., a packet can be sent. (bit mask)
.var ETH_RXBF_ADDR = $D6E1  // Number of free receive buffers (address)
.var RXBF_ADDR = $D6E1  // Number of free receive buffers (address)
.var ETH_RXBF_MASK = %00000110  // Number of free receive buffers (bit mask)
.var RXBF_MASK = %00000110  // Number of free receive buffers (bit mask)
.var ETH_STRM_ADDR = $D6E1  // Enable streaming of CPU instruction stream or VIC-IV display on ethernet (address)
.var STRM_ADDR = $D6E1  // Enable streaming of CPU instruction stream or VIC-IV display on ethernet (address)
.var ETH_STRM_MASK = %00001000  // Enable streaming of CPU instruction stream or VIC-IV display on ethernet (bit mask)
.var STRM_MASK = %00001000  // Enable streaming of CPU instruction stream or VIC-IV display on ethernet (bit mask)
.var ETH_TXQ_ADDR = $D6E1  // Ethernet TX IRQ status (address)
.var TXQ_ADDR = $D6E1  // Ethernet TX IRQ status (address)
.var ETH_TXQ_MASK = %00010000  // Ethernet TX IRQ status (bit mask)
.var TXQ_MASK = %00010000  // Ethernet TX IRQ status (bit mask)
.var ETH_RXQ_ADDR = $D6E1  // Ethernet RX IRQ status (address)
.var RXQ_ADDR = $D6E1  // Ethernet RX IRQ status (address)
.var ETH_RXQ_MASK = %00100000  // Ethernet RX IRQ status (bit mask)
.var RXQ_MASK = %00100000  // Ethernet RX IRQ status (bit mask)
.var ETH_TXQEN_ADDR = $D6E1  // Enable ethernet TX IRQ (address)
.var TXQEN_ADDR = $D6E1  // Enable ethernet TX IRQ (address)
.var ETH_TXQEN_MASK = %01000000  // Enable ethernet TX IRQ (bit mask)
.var TXQEN_MASK = %01000000  // Enable ethernet TX IRQ (bit mask)
.var ETH_RXQEN_ADDR = $D6E1  // Enable ethernet RX IRQ (address)
.var RXQEN_ADDR = $D6E1  // Enable ethernet RX IRQ (address)
.var ETH_RXQEN_MASK = %10000000  // Enable ethernet RX IRQ (bit mask)
.var RXQEN_MASK = %10000000  // Enable ethernet RX IRQ (bit mask)
.var ETH_TXSZLSB = $D6E2  // TX Packet size (low byte)
.var TXSZLSB = $D6E2  // TX Packet size (low byte)
.var ETH_TXSZMSB = $D6E3  // TX Packet size (high byte)
.var TXSZMSB = $D6E3  // TX Packet size (high byte)
.var ETH_COMMAND = $D6E4  // Ethernet command register (write only)
.var ETH_NOPROM_ADDR = $D6E5  // Ethernet disable promiscuous mode (address)
.var NOPROM_ADDR = $D6E5  // Ethernet disable promiscuous mode (address)
.var ETH_NOPROM_MASK = %00000001  // Ethernet disable promiscuous mode (bit mask)
.var NOPROM_MASK = %00000001  // Ethernet disable promiscuous mode (bit mask)
.var ETH_NOCRC_ADDR = $D6E5  // Disable CRC check for received packets (address)
.var NOCRC_ADDR = $D6E5  // Disable CRC check for received packets (address)
.var ETH_NOCRC_MASK = %00000010  // Disable CRC check for received packets (bit mask)
.var NOCRC_MASK = %00000010  // Disable CRC check for received packets (bit mask)
.var ETH_TXPH_ADDR = $D6E5  // Ethernet TX clock phase adjust (address)
.var TXPH_ADDR = $D6E5  // Ethernet TX clock phase adjust (address)
.var ETH_TXPH_MASK = %00001100  // Ethernet TX clock phase adjust (bit mask)
.var TXPH_MASK = %00001100  // Ethernet TX clock phase adjust (bit mask)
.var ETH_BCST_ADDR = $D6E5  // Accept broadcast frames (address)
.var BCST_ADDR = $D6E5  // Accept broadcast frames (address)
.var ETH_BCST_MASK = %00010000  // Accept broadcast frames (bit mask)
.var BCST_MASK = %00010000  // Accept broadcast frames (bit mask)
.var ETH_MCST_ADDR = $D6E5  // Accept multicast frames (address)
.var MCST_ADDR = $D6E5  // Accept multicast frames (address)
.var ETH_MCST_MASK = %00100000  // Accept multicast frames (bit mask)
.var MCST_MASK = %00100000  // Accept multicast frames (bit mask)
.var ETH_RXPH_ADDR = $D6E5  // Ethernet RX clock phase adjust (address)
.var RXPH_ADDR = $D6E5  // Ethernet RX clock phase adjust (address)
.var ETH_RXPH_MASK = %11000000  // Ethernet RX clock phase adjust (bit mask)
.var RXPH_MASK = %11000000  // Ethernet RX clock phase adjust (bit mask)
.var ETH_MIIMREG_ADDR = $D6E6  // Ethernet MIIM register number (address)
.var MIIMREG_ADDR = $D6E6  // Ethernet MIIM register number (address)
.var ETH_MIIMREG_MASK = %00011111  // Ethernet MIIM register number (bit mask)
.var MIIMREG_MASK = %00011111  // Ethernet MIIM register number (bit mask)
.var ETH_MIIMPHY_ADDR = $D6E6  // Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (address)
.var MIIMPHY_ADDR = $D6E6  // Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (address)
.var ETH_MIIMPHY_MASK = %11100000  // Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (bit mask)
.var MIIMPHY_MASK = %11100000  // Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (bit mask)
.var ETH_MIIMVLSB = $D6E7  // Ethernet MIIM register value (LSB)
.var MIIMVLSB = $D6E7  // Ethernet MIIM register value (LSB)
.var ETH_MIIMVMSB = $D6E8  // Ethernet MIIM register value (MSB)
.var MIIMVMSB = $D6E8  // Ethernet MIIM register value (MSB)
.var ETH_MACADDR1 = $D6E9  // Ethernet MAC address
.var MACADDR1 = $D6E9  // Ethernet MAC address
.var ETH_MACADDR2 = $D6EA  // @MACADDRX
.var MACADDR2 = $D6EA  // @MACADDRX
.var ETH_MACADDR3 = $D6EB  // @MACADDRX
.var MACADDR3 = $D6EB  // @MACADDRX
.var ETH_MACADDR4 = $D6EC  // @MACADDRX
.var MACADDR4 = $D6EC  // @MACADDRX
.var ETH_MACADDR5 = $D6ED  // @MACADDRX
.var MACADDR5 = $D6ED  // @MACADDRX
.var ETH_MACADDR6 = $D6EE  // @MACADDRX
.var MACADDR6 = $D6EE  // @MACADDRX
.var ETH_DBGRXWCOUNT = $D6EF  // DEBUG show number of writes to eth RX buffer
.var DBGRXWCOUNT = $D6EF  // DEBUG show number of writes to eth RX buffer
.var ETH_DBGTXSTAT = $D6EF  // DEBUG show current ethernet TX state
.var DBGTXSTAT = $D6EF  // DEBUG show current ethernet TX state
.var MISC_LCDBRIGHTNESS = $D6F0  // LCD panel brightness control
.var LCDBRIGHTNESS = $D6F0  // LCD panel brightness control
.var MISCIO_LCDBRIGHT = $D6F0  // LCD panel brightness control
.var LCDBRIGHT = $D6F0  // LCD panel brightness control
.var MISC_FPGABUTTONS = $D6F2  // Read FPGA five-way buttons
.var FPGABUTTONS = $D6F2  // Read FPGA five-way buttons
.var MISC_ACCELBITBASH = $D6F3  // Accelerometer bit-bash interface
.var ACCELBITBASH = $D6F3  // Accelerometer bit-bash interface
.var MISCIO_ACCELBASH = $D6F3  // Accelerometer bit-bashing port (debug only)
.var ACCELBASH = $D6F3  // Accelerometer bit-bashing port (debug only)
.var AUDIO_MIXREGSEL = $D6F4  // Audio Mixer register select
.var MIXREGSEL = $D6F4  // Audio Mixer register select
.var AUDIOMIX_REGSEL = $D6F4  // Audio Mixer register select
.var REGSEL = $D6F4  // Audio Mixer register select
.var AUDIO_MIXREGDATA = $D6F5  // Audio Mixer register read port
.var MIXREGDATA = $D6F5  // Audio Mixer register read port
.var AUDIOMIX_REGWDATA = $D6F5  // Audio Mixer register write port
.var REGWDATA = $D6F5  // Audio Mixer register write port
.var MISC_PS2KEYSCANLSB = $D6F6  // Keyboard scan code reader (lower byte)
.var PS2KEYSCANLSB = $D6F6  // Keyboard scan code reader (lower byte)
.var MISC_PS2KEYSCANMSB = $D6F7  // Keyboard scan code reader (upper nybl)
.var PS2KEYSCANMSB = $D6F7  // Keyboard scan code reader (upper nybl)
.var AUDIO_DIGILEFTLSB = $D6F8  // Digital audio, left channel, LSB
.var DIGILEFTLSB = $D6F8  // Digital audio, left channel, LSB
.var AUDIO_DIGILLSB = $D6F8  // 16-bit digital audio out (left LSB)
.var DIGILLSB = $D6F8  // 16-bit digital audio out (left LSB)
.var AUDIO_DIGILEFTMSB = $D6F9  // Digital audio, left channel, MSB
.var DIGILEFTMSB = $D6F9  // Digital audio, left channel, MSB
.var AUDIO_DIGILMSB = $D6F9  // 16-bit digital audio out (left MSB)
.var DIGILMSB = $D6F9  // 16-bit digital audio out (left MSB)
.var AUDIO_DIGIRIGHTLSB = $D6FA  // Digital audio, left channel, LSB
.var DIGIRIGHTLSB = $D6FA  // Digital audio, left channel, LSB
.var AUDIO_DIGIRLSB = $D6FA  // 16-bit digital audio out (right LSB)
.var DIGIRLSB = $D6FA  // 16-bit digital audio out (right LSB)
.var AUDIO_DIGIRIGHTMSB = $D6FB  // Digital audio, left channel, MSB
.var DIGIRIGHTMSB = $D6FB  // Digital audio, left channel, MSB
.var AUDIO_DIGIRMSB = $D6FB  // 16-bit digital audio out (right MSB)
.var DIGIRMSB = $D6FB  // 16-bit digital audio out (right MSB)
.var AUDIO_READBACKLSB = $D6FC  // audio read-back LSB (source selected by $D6F4)
.var READBACKLSB = $D6FC  // audio read-back LSB (source selected by $D6F4)
.var AUDIO_READBACKMSB = $D6FD  // audio read-back MSB (source selected by $D6F4)
.var READBACKMSB = $D6FD  // audio read-back MSB (source selected by $D6F4)
.var DMA_ADDRLSBTRIG = $D700  // DMAgic DMA list address LSB, and trigger DMA (when written)
.var ADDRLSBTRIG = $D700  // DMAgic DMA list address LSB, and trigger DMA (when written)
.var DMA_ADDRMSB = $D701  // DMA list address high byte (address bits 8 -- 15).
.var ADDRMSB = $D701  // DMA list address high byte (address bits 8 -- 15).
.var DMA_ADDRBANK = $D702  // DMA list address bank (address bits 16 -- 22). Writing clears \$D704.
.var ADDRBANK = $D702  // DMA list address bank (address bits 16 -- 22). Writing clears \$D704.
.var DMA_EN018B_ADDR = $D703  // DMA enable F018B mode (adds sub-command byte) (address)
.var EN018B_ADDR = $D703  // DMA enable F018B mode (adds sub-command byte) (address)
.var DMA_EN018B_MASK = %00000001  // DMA enable F018B mode (adds sub-command byte) (bit mask)
.var EN018B_MASK = %00000001  // DMA enable F018B mode (adds sub-command byte) (bit mask)
.var DMA_ADDRMB = $D704  // DMA list address mega-byte
.var ADDRMB = $D704  // DMA list address mega-byte
.var DMA_ETRIG = $D705  // Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list address specified as 28-bit flat address (uses DMA option list)
.var ETRIG = $D705  // Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list address specified as 28-bit flat address (uses DMA option list)
.var DMA_ETRIGMAPD = $D706  // Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list in current CPU memory map (uses DMA option list)
.var ETRIGMAPD = $D706  // Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list in current CPU memory map (uses DMA option list)
.var DMA_ADDRLSB = $D70E  // DMA list address low byte (address bits 0 -- 7) WITHOUT STARTING A DMA JOB (used by Hypervisor for unfreezing DMA-using tasks)
.var ADDRLSB = $D70E  // DMA list address low byte (address bits 0 -- 7) WITHOUT STARTING A DMA JOB (used by Hypervisor for unfreezing DMA-using tasks)
.var MATH_MULBUSY_ADDR = $D70F  // Set if hardware multiplier is busy (address)
.var MULBUSY_ADDR = $D70F  // Set if hardware multiplier is busy (address)
.var MATH_MULBUSY_MASK = %01000000  // Set if hardware multiplier is busy (bit mask)
.var MULBUSY_MASK = %01000000  // Set if hardware multiplier is busy (bit mask)
.var MATH_DIVBUSY_ADDR = $D70F  // Set if hardware divider is busy (address)
.var DIVBUSY_ADDR = $D70F  // Set if hardware divider is busy (address)
.var MATH_DIVBUSY_MASK = %10000000  // Set if hardware divider is busy (bit mask)
.var DIVBUSY_MASK = %10000000  // Set if hardware divider is busy (bit mask)
.var CPU_BADLEN_ADDR = $D710  // Enable badline emulation (address)
.var BADLEN_ADDR = $D710  // Enable badline emulation (address)
.var CPU_BADLEN_MASK = %00000001  // Enable badline emulation (bit mask)
.var BADLEN_MASK = %00000001  // Enable badline emulation (bit mask)
.var CPU_SLIEN_ADDR = $D710  // Enable 6502-style slow (7 cycle) interrupts (address)
.var SLIEN_ADDR = $D710  // Enable 6502-style slow (7 cycle) interrupts (address)
.var CPU_SLIEN_MASK = %00000010  // Enable 6502-style slow (7 cycle) interrupts (bit mask)
.var SLIEN_MASK = %00000010  // Enable 6502-style slow (7 cycle) interrupts (bit mask)
.var MISC_VDCSEN_ADDR = $D710  // Enable VDC inteface simulation (address)
.var VDCSEN_ADDR = $D710  // Enable VDC inteface simulation (address)
.var MISC_VDCSEN_MASK = %00000100  // Enable VDC inteface simulation (bit mask)
.var VDCSEN_MASK = %00000100  // Enable VDC inteface simulation (bit mask)
.var CPU_BRCOST_ADDR = $D710  // 1=charge extra cycle(s) for branches taken (address)
.var BRCOST_ADDR = $D710  // 1=charge extra cycle(s) for branches taken (address)
.var CPU_BRCOST_MASK = %00001000  // 1=charge extra cycle(s) for branches taken (bit mask)
.var BRCOST_MASK = %00001000  // 1=charge extra cycle(s) for branches taken (bit mask)
.var CPU_BADEXTRA_ADDR = $D710  // Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (address)
.var BADEXTRA_ADDR = $D710  // Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (address)
.var CPU_BADEXTRA_MASK = %00110000  // Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (bit mask)
.var BADEXTRA_MASK = %00110000  // Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (bit mask)
.var DMA_AUD_BLKTO_ADDR = $D711  // Audio DMA block timeout (read only) DEBUG (address)
.var AUD_BLKTO_ADDR = $D711  // Audio DMA block timeout (read only) DEBUG (address)
.var DMA_AUD_BLKTO_MASK = %00000111  // Audio DMA block timeout (read only) DEBUG (bit mask)
.var AUD_BLKTO_MASK = %00000111  // Audio DMA block timeout (read only) DEBUG (bit mask)
.var AUDIO_PWMPDM_ADDR = $D711  // PWM/PDM audio encoding select (address)
.var PWMPDM_ADDR = $D711  // PWM/PDM audio encoding select (address)
.var AUDIO_PWMPDM_MASK = %00001000  // PWM/PDM audio encoding select (bit mask)
.var PWMPDM_MASK = %00001000  // PWM/PDM audio encoding select (bit mask)
.var DMA_NOMIX_ADDR = $D711  // Audio DMA bypasses audio mixer (address)
.var NOMIX_ADDR = $D711  // Audio DMA bypasses audio mixer (address)
.var DMA_NOMIX_MASK = %00010000  // Audio DMA bypasses audio mixer (bit mask)
.var NOMIX_MASK = %00010000  // Audio DMA bypasses audio mixer (bit mask)
.var DMA_AUD_WRBLK_ADDR = $D711  // Audio DMA block writes (samples still get read) (address)
.var AUD_WRBLK_ADDR = $D711  // Audio DMA block writes (samples still get read) (address)
.var DMA_AUD_WRBLK_MASK = %00100000  // Audio DMA block writes (samples still get read) (bit mask)
.var AUD_WRBLK_MASK = %00100000  // Audio DMA block writes (samples still get read) (bit mask)
.var DMA_BLKD_ADDR = $D711  // Audio DMA blocked (read only) DEBUG (address)
.var BLKD_ADDR = $D711  // Audio DMA blocked (read only) DEBUG (address)
.var DMA_BLKD_MASK = %01000000  // Audio DMA blocked (read only) DEBUG (bit mask)
.var BLKD_MASK = %01000000  // Audio DMA blocked (read only) DEBUG (bit mask)
.var DMA_AUDEN_ADDR = $D711  // Enable Audio DMA (address)
.var AUDEN_ADDR = $D711  // Enable Audio DMA (address)
.var DMA_AUDEN_MASK = %10000000  // Enable Audio DMA (bit mask)
.var AUDEN_MASK = %10000000  // Enable Audio DMA (bit mask)
.var DMA_CH0RVOL = $D71C  // Audio DMA channel 0 right channel volume
.var CH0RVOL = $D71C  // Audio DMA channel 0 right channel volume
.var DMA_CH1RVOL = $D71D  // Audio DMA channel 1 right channel volume
.var CH1RVOL = $D71D  // Audio DMA channel 1 right channel volume
.var DMA_CH2LVOL = $D71E  // Audio DMA channel 2 left channel volume
.var CH2LVOL = $D71E  // Audio DMA channel 2 left channel volume
.var DMA_CH3LVOL = $D71F  // Audio DMA channel 3 left channel volume
.var CH3LVOL = $D71F  // Audio DMA channel 3 left channel volume
.var DMA_CH0_SBITS_ADDR = $D720  // Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (address)
.var CH0_SBITS_ADDR = $D720  // Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (address)
.var DMA_CH0_SBITS_MASK = %00000011  // Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (bit mask)
.var CH0_SBITS_MASK = %00000011  // Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (bit mask)
.var DMA_CH0_STP_ADDR = $D720  // Audio DMA channel X stop flag (address)
.var CH0_STP_ADDR = $D720  // Audio DMA channel X stop flag (address)
.var DMA_CH0_STP_MASK = %00001000  // Audio DMA channel X stop flag (bit mask)
.var CH0_STP_MASK = %00001000  // Audio DMA channel X stop flag (bit mask)
.var DMA_CH0_SINE_ADDR = $D720  // Audio DMA channel X play 32-sample sine wave instead of DMA data (address)
.var CH0_SINE_ADDR = $D720  // Audio DMA channel X play 32-sample sine wave instead of DMA data (address)
.var DMA_CH0_SINE_MASK = %00010000  // Audio DMA channel X play 32-sample sine wave instead of DMA data (bit mask)
.var CH0_SINE_MASK = %00010000  // Audio DMA channel X play 32-sample sine wave instead of DMA data (bit mask)
.var DMA_CH0_SGN_ADDR = $D720  // Enable Audio DMA channel X signed samples (address)
.var CH0_SGN_ADDR = $D720  // Enable Audio DMA channel X signed samples (address)
.var DMA_CH0_SGN_MASK = %00100000  // Enable Audio DMA channel X signed samples (bit mask)
.var CH0_SGN_MASK = %00100000  // Enable Audio DMA channel X signed samples (bit mask)
.var DMA_CH0_LOOP_ADDR = $D720  // Enable Audio DMA channel X looping (address)
.var CH0_LOOP_ADDR = $D720  // Enable Audio DMA channel X looping (address)
.var DMA_CH0_LOOP_MASK = %01000000  // Enable Audio DMA channel X looping (bit mask)
.var CH0_LOOP_MASK = %01000000  // Enable Audio DMA channel X looping (bit mask)
.var DMA_CH0_EN_ADDR = $D720  // Enable Audio DMA channel X (address)
.var CH0_EN_ADDR = $D720  // Enable Audio DMA channel X (address)
.var DMA_CH0_EN_MASK = %10000000  // Enable Audio DMA channel X (bit mask)
.var CH0_EN_MASK = %10000000  // Enable Audio DMA channel X (bit mask)
.var DMA_CH0BADDRL = $D721  // Audio DMA channel X base address LSB
.var CH0BADDRL = $D721  // Audio DMA channel X base address LSB
.var DMA_CH0BADDRC = $D722  // Audio DMA channel X base address middle byte
.var CH0BADDRC = $D722  // Audio DMA channel X base address middle byte
.var DMA_CH0BADDRM = $D723  // Audio DMA channel X base address MSB
.var CH0BADDRM = $D723  // Audio DMA channel X base address MSB
.var DMA_CH0FREQL = $D724  // Audio DMA channel X frequency LSB
.var CH0FREQL = $D724  // Audio DMA channel X frequency LSB
.var DMA_CH0FREQC = $D725  // Audio DMA channel X frequency middle byte
.var CH0FREQC = $D725  // Audio DMA channel X frequency middle byte
.var DMA_CH0FREQM = $D726  // Audio DMA channel X frequency MSB
.var CH0FREQM = $D726  // Audio DMA channel X frequency MSB
.var DMA_CH0TADDRL = $D727  // Audio DMA channel X top address LSB
.var CH0TADDRL = $D727  // Audio DMA channel X top address LSB
.var DMA_CH0TADDRM = $D728  // Audio DMA channel X top address MSB
.var CH0TADDRM = $D728  // Audio DMA channel X top address MSB
.var DMA_CH0VOLUME = $D729  // Audio DMA channel X playback volume
.var CH0VOLUME = $D729  // Audio DMA channel X playback volume
.var DMA_CH0CURADDRL = $D72A  // Audio DMA channel X current address LSB
.var CH0CURADDRL = $D72A  // Audio DMA channel X current address LSB
.var DMA_CH0CURADDRC = $D72B  // Audio DMA channel X current address middle byte
.var CH0CURADDRC = $D72B  // Audio DMA channel X current address middle byte
.var DMA_CH0CURADDRM = $D72C  // Audio DMA channel X current address MSB
.var CH0CURADDRM = $D72C  // Audio DMA channel X current address MSB
.var DMA_CH0TMRADDRL = $D72D  // Audio DMA channel X timing counter LSB
.var CH0TMRADDRL = $D72D  // Audio DMA channel X timing counter LSB
.var DMA_CH0TMRADDRC = $D72E  // Audio DMA channel X timing counter middle byte
.var CH0TMRADDRC = $D72E  // Audio DMA channel X timing counter middle byte
.var DMA_CH0TMRADDRM = $D72F  // Audio DMA channel X timing counter MSB
.var CH0TMRADDRM = $D72F  // Audio DMA channel X timing counter MSB
.var DMA_CH1_SBITS_ADDR = $D730  // @CHXSBITS (address)
.var CH1_SBITS_ADDR = $D730  // @CHXSBITS (address)
.var DMA_CH1_SBITS_MASK = %00000011  // @CHXSBITS (bit mask)
.var CH1_SBITS_MASK = %00000011  // @CHXSBITS (bit mask)
.var DMA_CH1_STP_ADDR = $D730  // @CHXSTP (address)
.var CH1_STP_ADDR = $D730  // @CHXSTP (address)
.var DMA_CH1_STP_MASK = %00001000  // @CHXSTP (bit mask)
.var CH1_STP_MASK = %00001000  // @CHXSTP (bit mask)
.var DMA_CH1_SINE_ADDR = $D730  // @CHXSINE (address)
.var CH1_SINE_ADDR = $D730  // @CHXSINE (address)
.var DMA_CH1_SINE_MASK = %00010000  // @CHXSINE (bit mask)
.var CH1_SINE_MASK = %00010000  // @CHXSINE (bit mask)
.var DMA_CH1_SGN_ADDR = $D730  // @CHXSGN (address)
.var CH1_SGN_ADDR = $D730  // @CHXSGN (address)
.var DMA_CH1_SGN_MASK = %00100000  // @CHXSGN (bit mask)
.var CH1_SGN_MASK = %00100000  // @CHXSGN (bit mask)
.var DMA_CH1_LOOP_ADDR = $D730  // @CHXLOOP (address)
.var CH1_LOOP_ADDR = $D730  // @CHXLOOP (address)
.var DMA_CH1_LOOP_MASK = %01000000  // @CHXLOOP (bit mask)
.var CH1_LOOP_MASK = %01000000  // @CHXLOOP (bit mask)
.var DMA_CH1_EN_ADDR = $D730  // @CHXEN (address)
.var CH1_EN_ADDR = $D730  // @CHXEN (address)
.var DMA_CH1_EN_MASK = %10000000  // @CHXEN (bit mask)
.var CH1_EN_MASK = %10000000  // @CHXEN (bit mask)
.var DMA_CH1BADDRL = $D731  // @CHXBADDRL
.var CH1BADDRL = $D731  // @CHXBADDRL
.var DMA_CH1BADDRC = $D732  // @CHXBADDRC
.var CH1BADDRC = $D732  // @CHXBADDRC
.var DMA_CH1BADDRM = $D733  // @CHXBADDRM
.var CH1BADDRM = $D733  // @CHXBADDRM
.var DMA_CH1FREQL = $D734  // @CHXFREQL
.var CH1FREQL = $D734  // @CHXFREQL
.var DMA_CH1FREQC = $D735  // @CHXFREQC
.var CH1FREQC = $D735  // @CHXFREQC
.var DMA_CH1FREQM = $D736  // @CHXFREQM
.var CH1FREQM = $D736  // @CHXFREQM
.var DMA_CH1TADDRL = $D737  // @CHXTADDRL
.var CH1TADDRL = $D737  // @CHXTADDRL
.var DMA_CH1TADDRM = $D738  // @CHXTADDRM
.var CH1TADDRM = $D738  // @CHXTADDRM
.var DMA_CH1VOLUME = $D739  // @CHXVOLUME
.var CH1VOLUME = $D739  // @CHXVOLUME
.var DMA_CH1CURADDRL = $D73A  // @CHXCURADDRL
.var CH1CURADDRL = $D73A  // @CHXCURADDRL
.var DMA_CH1CURADDRC = $D73B  // @CHXCURADDRC
.var CH1CURADDRC = $D73B  // @CHXCURADDRC
.var DMA_CH1CURADDRM = $D73C  // @CHXCURADDRM
.var CH1CURADDRM = $D73C  // @CHXCURADDRM
.var DMA_CH1TMRADDRL = $D73D  // @CHXTMRADDRL
.var CH1TMRADDRL = $D73D  // @CHXTMRADDRL
.var DMA_CH1TMRADDRC = $D73E  // @CHXTMRADDRC
.var CH1TMRADDRC = $D73E  // @CHXTMRADDRC
.var DMA_CH1TMRADDRM = $D73F  // @CHXTMRADDRM
.var CH1TMRADDRM = $D73F  // @CHXTMRADDRM
.var DMA_CH2_SBITS_ADDR = $D740  // @CHXSBITS (address)
.var CH2_SBITS_ADDR = $D740  // @CHXSBITS (address)
.var DMA_CH2_SBITS_MASK = %00000011  // @CHXSBITS (bit mask)
.var CH2_SBITS_MASK = %00000011  // @CHXSBITS (bit mask)
.var DMA_CH2_STP_ADDR = $D740  // @CHXSTP (address)
.var CH2_STP_ADDR = $D740  // @CHXSTP (address)
.var DMA_CH2_STP_MASK = %00001000  // @CHXSTP (bit mask)
.var CH2_STP_MASK = %00001000  // @CHXSTP (bit mask)
.var DMA_CH2_SINE_ADDR = $D740  // @CHXSINE (address)
.var CH2_SINE_ADDR = $D740  // @CHXSINE (address)
.var DMA_CH2_SINE_MASK = %00010000  // @CHXSINE (bit mask)
.var CH2_SINE_MASK = %00010000  // @CHXSINE (bit mask)
.var DMA_CH2_SGN_ADDR = $D740  // @CHXSGN (address)
.var CH2_SGN_ADDR = $D740  // @CHXSGN (address)
.var DMA_CH2_SGN_MASK = %00100000  // @CHXSGN (bit mask)
.var CH2_SGN_MASK = %00100000  // @CHXSGN (bit mask)
.var DMA_CH2_LOOP_ADDR = $D740  // @CHXLOOP (address)
.var CH2_LOOP_ADDR = $D740  // @CHXLOOP (address)
.var DMA_CH2_LOOP_MASK = %01000000  // @CHXLOOP (bit mask)
.var CH2_LOOP_MASK = %01000000  // @CHXLOOP (bit mask)
.var DMA_CH2_EN_ADDR = $D740  // @CHXEN (address)
.var CH2_EN_ADDR = $D740  // @CHXEN (address)
.var DMA_CH2_EN_MASK = %10000000  // @CHXEN (bit mask)
.var CH2_EN_MASK = %10000000  // @CHXEN (bit mask)
.var DMA_CH2BADDRL = $D741  // @CHXBADDRL
.var CH2BADDRL = $D741  // @CHXBADDRL
.var DMA_CH2BADDRC = $D742  // @CHXBADDRC
.var CH2BADDRC = $D742  // @CHXBADDRC
.var DMA_CH2BADDRM = $D743  // @CHXBADDRM
.var CH2BADDRM = $D743  // @CHXBADDRM
.var DMA_CH2FREQL = $D744  // @CHXFREQL
.var CH2FREQL = $D744  // @CHXFREQL
.var DMA_CH2FREQC = $D745  // @CHXFREQC
.var CH2FREQC = $D745  // @CHXFREQC
.var DMA_CH2FREQM = $D746  // @CHXFREQM
.var CH2FREQM = $D746  // @CHXFREQM
.var DMA_CH2TADDRL = $D747  // @CHXTADDRL
.var CH2TADDRL = $D747  // @CHXTADDRL
.var DMA_CH2TADDRM = $D748  // @CHXTADDRM
.var CH2TADDRM = $D748  // @CHXTADDRM
.var DMA_CH2VOLUME = $D749  // @CHXVOLUME
.var CH2VOLUME = $D749  // @CHXVOLUME
.var DMA_CH2CURADDRL = $D74A  // @CHXCURADDRL
.var CH2CURADDRL = $D74A  // @CHXCURADDRL
.var DMA_CH2CURADDRC = $D74B  // @CHXCURADDRC
.var CH2CURADDRC = $D74B  // @CHXCURADDRC
.var DMA_CH2CURADDRM = $D74C  // @CHXCURADDRM
.var CH2CURADDRM = $D74C  // @CHXCURADDRM
.var DMA_CH2TMRADDRL = $D74D  // @CHXTMRADDRL
.var CH2TMRADDRL = $D74D  // @CHXTMRADDRL
.var DMA_CH2TMRADDRC = $D74E  // @CHXTMRADDRC
.var CH2TMRADDRC = $D74E  // @CHXTMRADDRC
.var DMA_CH2TMRADDRM = $D74F  // @CHXTMRADDRM
.var CH2TMRADDRM = $D74F  // @CHXTMRADDRM
.var DMA_CH3_SBITS_ADDR = $D750  // @CHXSBITS (address)
.var CH3_SBITS_ADDR = $D750  // @CHXSBITS (address)
.var DMA_CH3_SBITS_MASK = %00000011  // @CHXSBITS (bit mask)
.var CH3_SBITS_MASK = %00000011  // @CHXSBITS (bit mask)
.var DMA_CH3_STP_ADDR = $D750  // @CHXSTP (address)
.var CH3_STP_ADDR = $D750  // @CHXSTP (address)
.var DMA_CH3_STP_MASK = %00001000  // @CHXSTP (bit mask)
.var CH3_STP_MASK = %00001000  // @CHXSTP (bit mask)
.var DMA_CH3_SINE_ADDR = $D750  // @CHXSINE (address)
.var CH3_SINE_ADDR = $D750  // @CHXSINE (address)
.var DMA_CH3_SINE_MASK = %00010000  // @CHXSINE (bit mask)
.var CH3_SINE_MASK = %00010000  // @CHXSINE (bit mask)
.var DMA_CH3_SGN_ADDR = $D750  // @CHXSGN (address)
.var CH3_SGN_ADDR = $D750  // @CHXSGN (address)
.var DMA_CH3_SGN_MASK = %00100000  // @CHXSGN (bit mask)
.var CH3_SGN_MASK = %00100000  // @CHXSGN (bit mask)
.var DMA_CH3_LOOP_ADDR = $D750  // @CHXLOOP (address)
.var CH3_LOOP_ADDR = $D750  // @CHXLOOP (address)
.var DMA_CH3_LOOP_MASK = %01000000  // @CHXLOOP (bit mask)
.var CH3_LOOP_MASK = %01000000  // @CHXLOOP (bit mask)
.var DMA_CH3_EN_ADDR = $D750  // @CHXEN (address)
.var CH3_EN_ADDR = $D750  // @CHXEN (address)
.var DMA_CH3_EN_MASK = %10000000  // @CHXEN (bit mask)
.var CH3_EN_MASK = %10000000  // @CHXEN (bit mask)
.var DMA_CH3BADDRL = $D751  // @CHXBADDRL
.var CH3BADDRL = $D751  // @CHXBADDRL
.var DMA_CH3BADDRC = $D752  // @CHXBADDRC
.var CH3BADDRC = $D752  // @CHXBADDRC
.var DMA_CH3BADDRM = $D753  // @CHXBADDRM
.var CH3BADDRM = $D753  // @CHXBADDRM
.var DMA_CH3FREQL = $D754  // @CHXFREQL
.var CH3FREQL = $D754  // @CHXFREQL
.var DMA_CH3FREQC = $D755  // @CHXFREQC
.var CH3FREQC = $D755  // @CHXFREQC
.var DMA_CH3FREQM = $D756  // @CHXFREQM
.var CH3FREQM = $D756  // @CHXFREQM
.var DMA_CH3TADDRL = $D757  // @CHXTADDRL
.var CH3TADDRL = $D757  // @CHXTADDRL
.var DMA_CH3TADDRM = $D758  // @CHXTADDRM
.var CH3TADDRM = $D758  // @CHXTADDRM
.var DMA_CH3VOLUME = $D759  // @CHXVOLUME
.var CH3VOLUME = $D759  // @CHXVOLUME
.var DMA_CH3CURADDRL = $D75A  // @CHXCURADDRL
.var CH3CURADDRL = $D75A  // @CHXCURADDRL
.var DMA_CH3CURADDRC = $D75B  // @CHXCURADDRC
.var CH3CURADDRC = $D75B  // @CHXCURADDRC
.var DMA_CH3CURADDRM = $D75C  // @CHXCURADDRM
.var CH3CURADDRM = $D75C  // @CHXCURADDRM
.var DMA_CH3TMRADDRL = $D75D  // @CHXTMRADDRL
.var CH3TMRADDRL = $D75D  // @CHXTMRADDRL
.var DMA_CH3TMRADDRC = $D75E  // @CHXTMRADDRC
.var CH3TMRADDRC = $D75E  // @CHXTMRADDRC
.var DMA_CH3TMRADDRM = $D75F  // @CHXTMRADDRM
.var CH3TMRADDRM = $D75F  // @CHXTMRADDRM
.var MATH_DIVOUT = $D768  // 64-bit output of MULTINA $\div$ MULTINB
.var GS_MATH_DIVOUT = $D769  // 64-bit output of MULTINA $\div$ MULTINB
.var GS_MATH_DIVOUT_2 = $D76A  // 64-bit output of MULTINA $\div$ MULTINB
.var GS_MATH_DIVOUT_3 = $D76B  // 64-bit output of MULTINA $\div$ MULTINB
.var GS_MATH_DIVOUT_4 = $D76C  // 64-bit output of MULTINA $\div$ MULTINB
.var GS_MATH_DIVOUT_5 = $D76D  // 64-bit output of MULTINA $\div$ MULTINB
.var GS_MATH_DIVOUT_6 = $D76E  // 64-bit output of MULTINA $\div$ MULTINB
.var GS_MATH_DIVOUT_7 = $D76F  // 64-bit output of MULTINA $\div$ MULTINB
.var MATH_MULTINA = $D770  // Multiplier input A / Divider numerator (32 bit)
.var GS_MATH_MULTINA = $D771  // Multiplier input A / Divider numerator (32 bit)
.var GS_MATH_MULTINA_2 = $D772  // Multiplier input A / Divider numerator (32 bit)
.var GS_MATH_MULTINA_3 = $D773  // Multiplier input A / Divider numerator (32 bit)
.var MATH_MULTINB = $D774  // Multiplier input B / Divider denominator (32 bit)
.var GS_MATH_MULTINB = $D775  // Multiplier input B / Divider denominator (32 bit)
.var GS_MATH_MULTINB_2 = $D776  // Multiplier input B / Divider denominator (32 bit)
.var GS_MATH_MULTINB_3 = $D777  // Multiplier input B / Divider denominator (32 bit)
.var MATH_MULTOUT = $D778  // 64-bit output of MULTINA $\times$ MULTINB
.var GS_MATH_MULTOUT = $D779  // 64-bit output of MULTINA $\times$ MULTINB
.var GS_MATH_MULTOUT_2 = $D77A  // 64-bit output of MULTINA $\times$ MULTINB
.var GS_MATH_MULTOUT_3 = $D77B  // 64-bit output of MULTINA $\times$ MULTINB
.var GS_MATH_MULTOUT_4 = $D77C  // 64-bit output of MULTINA $\times$ MULTINB
.var GS_MATH_MULTOUT_5 = $D77D  // 64-bit output of MULTINA $\times$ MULTINB
.var GS_MATH_MULTOUT_6 = $D77E  // 64-bit output of MULTINA $\times$ MULTINB
.var GS_MATH_MULTOUT_7 = $D77F  // 64-bit output of MULTINA $\times$ MULTINB
.var MATH_MATHIN0 = $D780  // Math unit 32-bit input X
.var GS_MATH_MATHIN0 = $D781  // @MATHINX
.var GS_MATH_MATHIN0_2 = $D782  // @MATHINX
.var GS_MATH_MATHIN0_3 = $D783  // @MATHINX
.var MATH_MATHIN1 = $D784  // @MATHINX
.var GS_MATH_MATHIN1 = $D785  // @MATHINX
.var GS_MATH_MATHIN1_2 = $D786  // @MATHINX
.var GS_MATH_MATHIN1_3 = $D787  // @MATHINX
.var MATH_MATHIN2 = $D788  // @MATHINX
.var GS_MATH_MATHIN2 = $D789  // @MATHINX
.var GS_MATH_MATHIN2_2 = $D78A  // @MATHINX
.var GS_MATH_MATHIN2_3 = $D78B  // @MATHINX
.var MATH_MATHIN3 = $D78C  // @MATHINX
.var GS_MATH_MATHIN3 = $D78D  // @MATHINX
.var GS_MATH_MATHIN3_2 = $D78E  // @MATHINX
.var GS_MATH_MATHIN3_3 = $D78F  // @MATHINX
.var MATH_MATHIN4 = $D790  // @MATHINX
.var GS_MATH_MATHIN4 = $D791  // @MATHINX
.var GS_MATH_MATHIN4_2 = $D792  // @MATHINX
.var GS_MATH_MATHIN4_3 = $D793  // @MATHINX
.var MATH_MATHIN5 = $D794  // @MATHINX
.var GS_MATH_MATHIN5 = $D795  // @MATHINX
.var GS_MATH_MATHIN5_2 = $D796  // @MATHINX
.var GS_MATH_MATHIN5_3 = $D797  // @MATHINX
.var MATH_MATHIN6 = $D798  // @MATHINX
.var GS_MATH_MATHIN6 = $D799  // @MATHINX
.var GS_MATH_MATHIN6_2 = $D79A  // @MATHINX
.var GS_MATH_MATHIN6_3 = $D79B  // @MATHINX
.var MATH_MATHIN7 = $D79C  // @MATHINX
.var GS_MATH_MATHIN7 = $D79D  // @MATHINX
.var GS_MATH_MATHIN7_2 = $D79E  // @MATHINX
.var GS_MATH_MATHIN7_3 = $D79F  // @MATHINX
.var MATH_MATHIN8 = $D7A0  // @MATHINX
.var GS_MATH_MATHIN8 = $D7A1  // @MATHINX
.var GS_MATH_MATHIN8_2 = $D7A2  // @MATHINX
.var GS_MATH_MATHIN8_3 = $D7A3  // @MATHINX
.var MATH_MATHIN9 = $D7A4  // @MATHINX
.var GS_MATH_MATHIN9 = $D7A5  // @MATHINX
.var GS_MATH_MATHIN9_2 = $D7A6  // @MATHINX
.var GS_MATH_MATHIN9_3 = $D7A7  // @MATHINX
.var MATH_MATHINA = $D7A8  // @MATHINX
.var GS_MATH_MATHINA = $D7A9  // @MATHINX
.var GS_MATH_MATHINA_2 = $D7AA  // @MATHINX
.var GS_MATH_MATHINA_3 = $D7AB  // @MATHINX
.var MATH_MATHINB = $D7AC  // @MATHINX
.var GS_MATH_MATHINB = $D7AD  // @MATHINX
.var GS_MATH_MATHINB_2 = $D7AE  // @MATHINX
.var GS_MATH_MATHINB_3 = $D7AF  // @MATHINX
.var MATH_MATHINC = $D7B0  // @MATHINX
.var GS_MATH_MATHINC = $D7B1  // @MATHINX
.var GS_MATH_MATHINC_2 = $D7B2  // @MATHINX
.var GS_MATH_MATHINC_3 = $D7B3  // @MATHINX
.var MATH_MATHIND = $D7B4  // @MATHINX
.var GS_MATH_MATHIND = $D7B5  // @MATHINX
.var GS_MATH_MATHIND_2 = $D7B6  // @MATHINX
.var GS_MATH_MATHIND_3 = $D7B7  // @MATHINX
.var MATH_MATHINE = $D7B8  // @MATHINX
.var GS_MATH_MATHINE = $D7B9  // @MATHINX
.var GS_MATH_MATHINE_2 = $D7BA  // @MATHINX
.var GS_MATH_MATHINE_3 = $D7BB  // @MATHINX
.var MATH_MATHINF = $D7BC  // @MATHINX
.var GS_MATH_MATHINF = $D7BD  // @MATHINX
.var GS_MATH_MATHINF_2 = $D7BE  // @MATHINX
.var GS_MATH_MATHINF_3 = $D7BF  // @MATHINX
.var MATH_UNIT0INA_ADDR = $D7C0  // Select which of the 16 32-bit math registers is input A for Math Function Unit X. (address)
.var UNIT0INA_ADDR = $D7C0  // Select which of the 16 32-bit math registers is input A for Math Function Unit X. (address)
.var MATH_UNIT0INA_MASK = %00001111  // Select which of the 16 32-bit math registers is input A for Math Function Unit X. (bit mask)
.var UNIT0INA_MASK = %00001111  // Select which of the 16 32-bit math registers is input A for Math Function Unit X. (bit mask)
.var MATH_UNIT0INB_ADDR = $D7C0  // Select which of the 16 32-bit math registers is input B for Math Function Unit X. (address)
.var UNIT0INB_ADDR = $D7C0  // Select which of the 16 32-bit math registers is input B for Math Function Unit X. (address)
.var MATH_UNIT0INB_MASK = %11110000  // Select which of the 16 32-bit math registers is input B for Math Function Unit X. (bit mask)
.var UNIT0INB_MASK = %11110000  // Select which of the 16 32-bit math registers is input B for Math Function Unit X. (bit mask)
.var MATH_UNIT1INA_ADDR = $D7C1  // @UNITXINA (address)
.var UNIT1INA_ADDR = $D7C1  // @UNITXINA (address)
.var MATH_UNIT1INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT1INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT1INB_ADDR = $D7C1  // @UNITXINB (address)
.var UNIT1INB_ADDR = $D7C1  // @UNITXINB (address)
.var MATH_UNIT1INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT1INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT2INA_ADDR = $D7C2  // @UNITXINA (address)
.var UNIT2INA_ADDR = $D7C2  // @UNITXINA (address)
.var MATH_UNIT2INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT2INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT2INB_ADDR = $D7C2  // @UNITXINB (address)
.var UNIT2INB_ADDR = $D7C2  // @UNITXINB (address)
.var MATH_UNIT2INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT2INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT3INA_ADDR = $D7C3  // @UNITXINA (address)
.var UNIT3INA_ADDR = $D7C3  // @UNITXINA (address)
.var MATH_UNIT3INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT3INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT3INB_ADDR = $D7C3  // @UNITXINB (address)
.var UNIT3INB_ADDR = $D7C3  // @UNITXINB (address)
.var MATH_UNIT3INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT3INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT4INA_ADDR = $D7C4  // @UNITXINA (address)
.var UNIT4INA_ADDR = $D7C4  // @UNITXINA (address)
.var MATH_UNIT4INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT4INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT4INB_ADDR = $D7C4  // @UNITXINB (address)
.var UNIT4INB_ADDR = $D7C4  // @UNITXINB (address)
.var MATH_UNIT4INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT4INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT5INA_ADDR = $D7C5  // @UNITXINA (address)
.var UNIT5INA_ADDR = $D7C5  // @UNITXINA (address)
.var MATH_UNIT5INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT5INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT5INB_ADDR = $D7C5  // @UNITXINB (address)
.var UNIT5INB_ADDR = $D7C5  // @UNITXINB (address)
.var MATH_UNIT5INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT5INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT6INA_ADDR = $D7C6  // @UNITXINA (address)
.var UNIT6INA_ADDR = $D7C6  // @UNITXINA (address)
.var MATH_UNIT6INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT6INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT6INB_ADDR = $D7C6  // @UNITXINB (address)
.var UNIT6INB_ADDR = $D7C6  // @UNITXINB (address)
.var MATH_UNIT6INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT6INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT7INA_ADDR = $D7C7  // @UNITXINA (address)
.var UNIT7INA_ADDR = $D7C7  // @UNITXINA (address)
.var MATH_UNIT7INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT7INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT7INB_ADDR = $D7C7  // @UNITXINB (address)
.var UNIT7INB_ADDR = $D7C7  // @UNITXINB (address)
.var MATH_UNIT7INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT7INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT8INA_ADDR = $D7C8  // @UNITXINA (address)
.var UNIT8INA_ADDR = $D7C8  // @UNITXINA (address)
.var MATH_UNIT8INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT8INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT8INB_ADDR = $D7C8  // @UNITXINB (address)
.var UNIT8INB_ADDR = $D7C8  // @UNITXINB (address)
.var MATH_UNIT8INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT8INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT9INA_ADDR = $D7C9  // @UNITXINA (address)
.var UNIT9INA_ADDR = $D7C9  // @UNITXINA (address)
.var MATH_UNIT9INA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNIT9INA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNIT9INB_ADDR = $D7C9  // @UNITXINB (address)
.var UNIT9INB_ADDR = $D7C9  // @UNITXINB (address)
.var MATH_UNIT9INB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNIT9INB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNITAINA_ADDR = $D7CA  // @UNITXINA (address)
.var UNITAINA_ADDR = $D7CA  // @UNITXINA (address)
.var MATH_UNITAINA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNITAINA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNITAINB_ADDR = $D7CA  // @UNITXINB (address)
.var UNITAINB_ADDR = $D7CA  // @UNITXINB (address)
.var MATH_UNITAINB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNITAINB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNITBINA_ADDR = $D7CB  // @UNITXINA (address)
.var UNITBINA_ADDR = $D7CB  // @UNITXINA (address)
.var MATH_UNITBINA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNITBINA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNITBINB_ADDR = $D7CB  // @UNITXINB (address)
.var UNITBINB_ADDR = $D7CB  // @UNITXINB (address)
.var MATH_UNITBINB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNITBINB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNITCINA_ADDR = $D7CC  // @UNITXINA (address)
.var UNITCINA_ADDR = $D7CC  // @UNITXINA (address)
.var MATH_UNITCINA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNITCINA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNITCINB_ADDR = $D7CC  // @UNITXINB (address)
.var UNITCINB_ADDR = $D7CC  // @UNITXINB (address)
.var MATH_UNITCINB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNITCINB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNITDINA_ADDR = $D7CD  // @UNITXINA (address)
.var UNITDINA_ADDR = $D7CD  // @UNITXINA (address)
.var MATH_UNITDINA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNITDINA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNITDINB_ADDR = $D7CD  // @UNITXINB (address)
.var UNITDINB_ADDR = $D7CD  // @UNITXINB (address)
.var MATH_UNITDINB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNITDINB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNITEINA_ADDR = $D7CE  // @UNITXINA (address)
.var UNITEINA_ADDR = $D7CE  // @UNITXINA (address)
.var MATH_UNITEINA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNITEINA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNITEINB_ADDR = $D7CE  // @UNITXINB (address)
.var UNITEINB_ADDR = $D7CE  // @UNITXINB (address)
.var MATH_UNITEINB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNITEINB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNITFINA_ADDR = $D7CF  // @UNITXINA (address)
.var UNITFINA_ADDR = $D7CF  // @UNITXINA (address)
.var MATH_UNITFINA_MASK = %00001111  // @UNITXINA (bit mask)
.var UNITFINA_MASK = %00001111  // @UNITXINA (bit mask)
.var MATH_UNITFINB_ADDR = $D7CF  // @UNITXINB (address)
.var UNITFINB_ADDR = $D7CF  // @UNITXINB (address)
.var MATH_UNITFINB_MASK = %11110000  // @UNITXINB (bit mask)
.var UNITFINB_MASK = %11110000  // @UNITXINB (bit mask)
.var MATH_UNIT0OUT_ADDR = $D7D0  // Select which of the 16 32-bit math registers receives the output of Math Function Unit X (address)
.var UNIT0OUT_ADDR = $D7D0  // Select which of the 16 32-bit math registers receives the output of Math Function Unit X (address)
.var MATH_UNIT0OUT_MASK = %00001111  // Select which of the 16 32-bit math registers receives the output of Math Function Unit X (bit mask)
.var UNIT0OUT_MASK = %00001111  // Select which of the 16 32-bit math registers receives the output of Math Function Unit X (bit mask)
.var MATH_U0_LOWOUT_ADDR = $D7D0  // If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
.var U0_LOWOUT_ADDR = $D7D0  // If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
.var MATH_U0_LOWOUT_MASK = %00010000  // If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
.var U0_LOWOUT_MASK = %00010000  // If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
.var MATH_U0_HIOUT_ADDR = $D7D0  // If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
.var U0_HIOUT_ADDR = $D7D0  // If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
.var MATH_U0_HIOUT_MASK = %00100000  // If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
.var U0_HIOUT_MASK = %00100000  // If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
.var MATH_U0_MLADD_ADDR = $D7D0  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (address)
.var U0_MLADD_ADDR = $D7D0  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (address)
.var MATH_U0_MLADD_MASK = %01000000  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (bit mask)
.var U0_MLADD_MASK = %01000000  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (bit mask)
.var MATH_U0_LATCH_ADDR = $D7D0  // If set, Math Function Unit X's output is latched. (address)
.var U0_LATCH_ADDR = $D7D0  // If set, Math Function Unit X's output is latched. (address)
.var MATH_U0_LATCH_MASK = %10000000  // If set, Math Function Unit X's output is latched. (bit mask)
.var U0_LATCH_MASK = %10000000  // If set, Math Function Unit X's output is latched. (bit mask)
.var MATH_UNIT1OUT_ADDR = $D7D1  // @UNITXOUT (address)
.var UNIT1OUT_ADDR = $D7D1  // @UNITXOUT (address)
.var MATH_UNIT1OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT1OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U1_LOWOUT_ADDR = $D7D1  // @UXLOWOUT (address)
.var U1_LOWOUT_ADDR = $D7D1  // @UXLOWOUT (address)
.var MATH_U1_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U1_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U1_HIOUT_ADDR = $D7D1  // @UXHIOUT (address)
.var U1_HIOUT_ADDR = $D7D1  // @UXHIOUT (address)
.var MATH_U1_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U1_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U1_MLADD_ADDR = $D7D1  // @UXMLADD (address)
.var U1_MLADD_ADDR = $D7D1  // @UXMLADD (address)
.var MATH_U1_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var U1_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var MATH_U1_LATCH_ADDR = $D7D1  // @UXLATCH (address)
.var U1_LATCH_ADDR = $D7D1  // @UXLATCH (address)
.var MATH_U1_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U1_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT2OUT_ADDR = $D7D2  // @UNITXOUT (address)
.var UNIT2OUT_ADDR = $D7D2  // @UNITXOUT (address)
.var MATH_UNIT2OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT2OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U2_LOWOUT_ADDR = $D7D2  // @UXLOWOUT (address)
.var U2_LOWOUT_ADDR = $D7D2  // @UXLOWOUT (address)
.var MATH_U2_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U2_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U2_HIOUT_ADDR = $D7D2  // @UXHIOUT (address)
.var U2_HIOUT_ADDR = $D7D2  // @UXHIOUT (address)
.var MATH_U2_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U2_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U2_MLADD_ADDR = $D7D2  // @UXMLADD (address)
.var U2_MLADD_ADDR = $D7D2  // @UXMLADD (address)
.var MATH_U2_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var U2_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var MATH_U2_LATCH_ADDR = $D7D2  // @UXLATCH (address)
.var U2_LATCH_ADDR = $D7D2  // @UXLATCH (address)
.var MATH_U2_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U2_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT3OUT_ADDR = $D7D3  // @UNITXOUT (address)
.var UNIT3OUT_ADDR = $D7D3  // @UNITXOUT (address)
.var MATH_UNIT3OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT3OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U3_LOWOUT_ADDR = $D7D3  // @UXLOWOUT (address)
.var U3_LOWOUT_ADDR = $D7D3  // @UXLOWOUT (address)
.var MATH_U3_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U3_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U3_HIOUT_ADDR = $D7D3  // @UXHIOUT (address)
.var U3_HIOUT_ADDR = $D7D3  // @UXHIOUT (address)
.var MATH_U3_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U3_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U3_MLADD_ADDR = $D7D3  // @UXMLADD (address)
.var U3_MLADD_ADDR = $D7D3  // @UXMLADD (address)
.var MATH_U3_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var U3_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var MATH_U3_LATCH_ADDR = $D7D3  // @UXLATCH (address)
.var U3_LATCH_ADDR = $D7D3  // @UXLATCH (address)
.var MATH_U3_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U3_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT4OUT_ADDR = $D7D4  // @UNITXOUT (address)
.var UNIT4OUT_ADDR = $D7D4  // @UNITXOUT (address)
.var MATH_UNIT4OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT4OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U4_LOWOUT_ADDR = $D7D4  // @UXLOWOUT (address)
.var U4_LOWOUT_ADDR = $D7D4  // @UXLOWOUT (address)
.var MATH_U4_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U4_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U4_HIOUT_ADDR = $D7D4  // @UXHIOUT (address)
.var U4_HIOUT_ADDR = $D7D4  // @UXHIOUT (address)
.var MATH_U4_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U4_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U4_MLADD_ADDR = $D7D4  // @UXMLADD (address)
.var U4_MLADD_ADDR = $D7D4  // @UXMLADD (address)
.var MATH_U4_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var U4_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var MATH_U4_LATCH_ADDR = $D7D4  // @UXLATCH (address)
.var U4_LATCH_ADDR = $D7D4  // @UXLATCH (address)
.var MATH_U4_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U4_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT5OUT_ADDR = $D7D5  // @UNITXOUT (address)
.var UNIT5OUT_ADDR = $D7D5  // @UNITXOUT (address)
.var MATH_UNIT5OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT5OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U5_LOWOUT_ADDR = $D7D5  // @UXLOWOUT (address)
.var U5_LOWOUT_ADDR = $D7D5  // @UXLOWOUT (address)
.var MATH_U5_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U5_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U5_HIOUT_ADDR = $D7D5  // @UXHIOUT (address)
.var U5_HIOUT_ADDR = $D7D5  // @UXHIOUT (address)
.var MATH_U5_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U5_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U5_MLADD_ADDR = $D7D5  // @UXMLADD (address)
.var U5_MLADD_ADDR = $D7D5  // @UXMLADD (address)
.var MATH_U5_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var U5_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var MATH_U5_LATCH_ADDR = $D7D5  // @UXLATCH (address)
.var U5_LATCH_ADDR = $D7D5  // @UXLATCH (address)
.var MATH_U5_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U5_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT6OUT_ADDR = $D7D6  // @UNITXOUT (address)
.var UNIT6OUT_ADDR = $D7D6  // @UNITXOUT (address)
.var MATH_UNIT6OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT6OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U6_LOWOUT_ADDR = $D7D6  // @UXLOWOUT (address)
.var U6_LOWOUT_ADDR = $D7D6  // @UXLOWOUT (address)
.var MATH_U6_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U6_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U6_HIOUT_ADDR = $D7D6  // @UXHIOUT (address)
.var U6_HIOUT_ADDR = $D7D6  // @UXHIOUT (address)
.var MATH_U6_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U6_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U6_MLADD_ADDR = $D7D6  // @UXMLADD (address)
.var U6_MLADD_ADDR = $D7D6  // @UXMLADD (address)
.var MATH_U6_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var U6_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var MATH_U6_LATCH_ADDR = $D7D6  // @UXLATCH (address)
.var U6_LATCH_ADDR = $D7D6  // @UXLATCH (address)
.var MATH_U6_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U6_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT7OUT_ADDR = $D7D7  // @UNITXOUT (address)
.var UNIT7OUT_ADDR = $D7D7  // @UNITXOUT (address)
.var MATH_UNIT7OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT7OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U7_LOWOUT_ADDR = $D7D7  // @UXLOWOUT (address)
.var U7_LOWOUT_ADDR = $D7D7  // @UXLOWOUT (address)
.var MATH_U7_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U7_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U7_HIOUT_ADDR = $D7D7  // @UXHIOUT (address)
.var U7_HIOUT_ADDR = $D7D7  // @UXHIOUT (address)
.var MATH_U7_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U7_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U7_MLADD_ADDR = $D7D7  // @UXMLADD (address)
.var U7_MLADD_ADDR = $D7D7  // @UXMLADD (address)
.var MATH_U7_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var U7_MLADD_MASK = %01000000  // @UXMLADD (bit mask)
.var MATH_U7_LATCH_ADDR = $D7D7  // @UXLATCH (address)
.var U7_LATCH_ADDR = $D7D7  // @UXLATCH (address)
.var MATH_U7_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U7_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT8OUT_ADDR = $D7D8  // @UNITXOUT (address)
.var UNIT8OUT_ADDR = $D7D8  // @UNITXOUT (address)
.var MATH_UNIT8OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT8OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U8_LOWOUT_ADDR = $D7D8  // @UXLOWOUT (address)
.var U8_LOWOUT_ADDR = $D7D8  // @UXLOWOUT (address)
.var MATH_U8_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U8_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U8_HIOUT_ADDR = $D7D8  // @UXHIOUT (address)
.var U8_HIOUT_ADDR = $D7D8  // @UXHIOUT (address)
.var MATH_U8_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U8_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U8_BSADD_ADDR = $D7D8  // If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (address)
.var U8_BSADD_ADDR = $D7D8  // If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (address)
.var MATH_U8_BSADD_MASK = %01000000  // If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (bit mask)
.var U8_BSADD_MASK = %01000000  // If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (bit mask)
.var MATH_U8_LATCH_ADDR = $D7D8  // @UXLATCH (address)
.var U8_LATCH_ADDR = $D7D8  // @UXLATCH (address)
.var MATH_U8_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U8_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNIT9OUT_ADDR = $D7D9  // @UNITXOUT (address)
.var UNIT9OUT_ADDR = $D7D9  // @UNITXOUT (address)
.var MATH_UNIT9OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNIT9OUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_U9_LOWOUT_ADDR = $D7D9  // @UXLOWOUT (address)
.var U9_LOWOUT_ADDR = $D7D9  // @UXLOWOUT (address)
.var MATH_U9_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var U9_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_U9_HIOUT_ADDR = $D7D9  // @UXHIOUT (address)
.var U9_HIOUT_ADDR = $D7D9  // @UXHIOUT (address)
.var MATH_U9_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var U9_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_U9_BSADD_ADDR = $D7D9  // @UXBSADD (address)
.var U9_BSADD_ADDR = $D7D9  // @UXBSADD (address)
.var MATH_U9_BSADD_MASK = %01000000  // @UXBSADD (bit mask)
.var U9_BSADD_MASK = %01000000  // @UXBSADD (bit mask)
.var MATH_U9_LATCH_ADDR = $D7D9  // @UXLATCH (address)
.var U9_LATCH_ADDR = $D7D9  // @UXLATCH (address)
.var MATH_U9_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var U9_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNITAOUT_ADDR = $D7DA  // @UNITXOUT (address)
.var UNITAOUT_ADDR = $D7DA  // @UNITXOUT (address)
.var MATH_UNITAOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNITAOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_UA_LOWOUT_ADDR = $D7DA  // @UXLOWOUT (address)
.var UA_LOWOUT_ADDR = $D7DA  // @UXLOWOUT (address)
.var MATH_UA_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var UA_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_UA_HIOUT_ADDR = $D7DA  // @UXHIOUT (address)
.var UA_HIOUT_ADDR = $D7DA  // @UXHIOUT (address)
.var MATH_UA_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var UA_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_UA_BSADD_ADDR = $D7DA  // @UXBSADD (address)
.var UA_BSADD_ADDR = $D7DA  // @UXBSADD (address)
.var MATH_UA_BSADD_MASK = %01000000  // @UXBSADD (bit mask)
.var UA_BSADD_MASK = %01000000  // @UXBSADD (bit mask)
.var MATH_UA_LATCH_ADDR = $D7DA  // @UXLATCH (address)
.var UA_LATCH_ADDR = $D7DA  // @UXLATCH (address)
.var MATH_UA_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var UA_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNITBOUT_ADDR = $D7DB  // @UNITXOUT (address)
.var UNITBOUT_ADDR = $D7DB  // @UNITXOUT (address)
.var MATH_UNITBOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNITBOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_UB_LOWOUT_ADDR = $D7DB  // @UXLOWOUT (address)
.var UB_LOWOUT_ADDR = $D7DB  // @UXLOWOUT (address)
.var MATH_UB_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var UB_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_UB_HIOUT_ADDR = $D7DB  // @UXHIOUT (address)
.var UB_HIOUT_ADDR = $D7DB  // @UXHIOUT (address)
.var MATH_UB_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var UB_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_UB_BSADD_ADDR = $D7DB  // @UXBSADD (address)
.var UB_BSADD_ADDR = $D7DB  // @UXBSADD (address)
.var MATH_UB_BSADD_MASK = %01000000  // @UXBSADD (bit mask)
.var UB_BSADD_MASK = %01000000  // @UXBSADD (bit mask)
.var MATH_UB_LATCH_ADDR = $D7DB  // @UXLATCH (address)
.var UB_LATCH_ADDR = $D7DB  // @UXLATCH (address)
.var MATH_UB_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var UB_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNITCOUT_ADDR = $D7DC  // @UNITXOUT (address)
.var UNITCOUT_ADDR = $D7DC  // @UNITXOUT (address)
.var MATH_UNITCOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNITCOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_UC_LOWOUT_ADDR = $D7DC  // @UXLOWOUT (address)
.var UC_LOWOUT_ADDR = $D7DC  // @UXLOWOUT (address)
.var MATH_UC_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var UC_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_UC_HIOUT_ADDR = $D7DC  // @UXHIOUT (address)
.var UC_HIOUT_ADDR = $D7DC  // @UXHIOUT (address)
.var MATH_UC_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var UC_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_UC_DVADD_ADDR = $D7DC  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (address)
.var UC_DVADD_ADDR = $D7DC  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (address)
.var MATH_UC_DVADD_MASK = %01000000  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (bit mask)
.var UC_DVADD_MASK = %01000000  // If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (bit mask)
.var MATH_UC_LATCH_ADDR = $D7DC  // @UXLATCH (address)
.var UC_LATCH_ADDR = $D7DC  // @UXLATCH (address)
.var MATH_UC_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var UC_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNITDOUT_ADDR = $D7DD  // @UNITXOUT (address)
.var UNITDOUT_ADDR = $D7DD  // @UNITXOUT (address)
.var MATH_UNITDOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNITDOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_UD_LOWOUT_ADDR = $D7DD  // @UXLOWOUT (address)
.var UD_LOWOUT_ADDR = $D7DD  // @UXLOWOUT (address)
.var MATH_UD_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var UD_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_UD_HIOUT_ADDR = $D7DD  // @UXHIOUT (address)
.var UD_HIOUT_ADDR = $D7DD  // @UXHIOUT (address)
.var MATH_UD_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var UD_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_UD_DVADD_ADDR = $D7DD  //  (address)
.var UD_DVADD_ADDR = $D7DD  //  (address)
.var MATH_UD_DVADD_MASK = %01000000  //  (bit mask)
.var UD_DVADD_MASK = %01000000  //  (bit mask)
.var MATH_UD_LATCH_ADDR = $D7DD  // @UXLATCH (address)
.var UD_LATCH_ADDR = $D7DD  // @UXLATCH (address)
.var MATH_UD_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var UD_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNITEOUT_ADDR = $D7DE  // @UNITXOUT (address)
.var UNITEOUT_ADDR = $D7DE  // @UNITXOUT (address)
.var MATH_UNITEOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNITEOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_UE_LOWOUT_ADDR = $D7DE  // @UXLOWOUT (address)
.var UE_LOWOUT_ADDR = $D7DE  // @UXLOWOUT (address)
.var MATH_UE_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var UE_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_UE_HIOUT_ADDR = $D7DE  // @UXHIOUT (address)
.var UE_HIOUT_ADDR = $D7DE  // @UXHIOUT (address)
.var MATH_UE_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var UE_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_UE_DVADD_ADDR = $D7DE  //  (address)
.var UE_DVADD_ADDR = $D7DE  //  (address)
.var MATH_UE_DVADD_MASK = %01000000  //  (bit mask)
.var UE_DVADD_MASK = %01000000  //  (bit mask)
.var MATH_UE_LATCH_ADDR = $D7DE  // @UXLATCH (address)
.var UE_LATCH_ADDR = $D7DE  // @UXLATCH (address)
.var MATH_UE_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var UE_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_UNITFOUT_ADDR = $D7DF  // @UNITXOUT (address)
.var UNITFOUT_ADDR = $D7DF  // @UNITXOUT (address)
.var MATH_UNITFOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var UNITFOUT_MASK = %00001111  // @UNITXOUT (bit mask)
.var MATH_UF_LOWOUT_ADDR = $D7DF  // @UXLOWOUT (address)
.var UF_LOWOUT_ADDR = $D7DF  // @UXLOWOUT (address)
.var MATH_UF_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var UF_LOWOUT_MASK = %00010000  // @UXLOWOUT (bit mask)
.var MATH_UF_HIOUT_ADDR = $D7DF  // @UXHIOUT (address)
.var UF_HIOUT_ADDR = $D7DF  // @UXHIOUT (address)
.var MATH_UF_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var UF_HIOUT_MASK = %00100000  // @UXHIOUT (bit mask)
.var MATH_UF_DVADD_ADDR = $D7DF  //  (address)
.var UF_DVADD_ADDR = $D7DF  //  (address)
.var MATH_UF_DVADD_MASK = %01000000  //  (bit mask)
.var UF_DVADD_MASK = %01000000  //  (bit mask)
.var MATH_UF_LATCH_ADDR = $D7DF  // @UXLATCH (address)
.var UF_LATCH_ADDR = $D7DF  // @UXLATCH (address)
.var MATH_UF_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var UF_LATCH_MASK = %10000000  // @UXLATCH (bit mask)
.var MATH_LATCHINT = $D7E0  // Latch interval for latched outputs (in CPU cycles)
.var LATCHINT = $D7E0  // Latch interval for latched outputs (in CPU cycles)
.var MATH_WREN_ADDR = $D7E1  // Enable setting of math registers (must normally be set) (address)
.var WREN_ADDR = $D7E1  // Enable setting of math registers (must normally be set) (address)
.var MATH_WREN_MASK = %00000001  // Enable setting of math registers (must normally be set) (bit mask)
.var WREN_MASK = %00000001  // Enable setting of math registers (must normally be set) (bit mask)
.var MATH_CALCEN_ADDR = $D7E1  // Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (address)
.var CALCEN_ADDR = $D7E1  // Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (address)
.var MATH_CALCEN_MASK = %00000010  // Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (bit mask)
.var CALCEN_MASK = %00000010  // Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (bit mask)
.var MATH_RESERVED = $D7E2  // Reserved
.var GS_MATH_RESERVED = $D7E3  // Reserved
.var MATH_ITERCNT = $D7E4  // Iteration Counter (32 bit)
.var GS_MATH_ITERCNT = $D7E5  // Iteration Counter (32 bit)
.var GS_MATH_ITERCNT_2 = $D7E6  // Iteration Counter (32 bit)
.var GS_MATH_ITERCNT_3 = $D7E7  // Iteration Counter (32 bit)
.var MATH_ITERCMP = $D7E8  // Math iteration counter comparator (32 bit)
.var GS_MATH_ITERCMP = $D7E9  // Math iteration counter comparator (32 bit)
.var GS_MATH_ITERCMP_2 = $D7EA  // Math iteration counter comparator (32 bit)
.var GS_MATH_ITERCMP_3 = $D7EB  // Math iteration counter comparator (32 bit)
.var CPU_IECBUSACT_ADDR = $D7F1  // IEC bus is active (address)
.var IECBUSACT_ADDR = $D7F1  // IEC bus is active (address)
.var CPU_IECBUSACT_MASK = %00000001  // IEC bus is active (bit mask)
.var IECBUSACT_MASK = %00000001  // IEC bus is active (bit mask)
.var CPU_PHIPERFRAME = $D7F2  // Count the number of PHI cycles per video frame (LSB)
.var GS_CPU_PHIPERFRAME = $D7F5  // Count the number of PHI cycles per video frame (MSB)
.var CPU_CYCPERFRAME = $D7F6  // Count the number of usable (proceed=1) CPU cycles per video frame (LSB)
.var GS_CPU_CYCPERFRAME = $D7F9  // Count the number of usable (proceed=1) CPU cycles per video frame (MSB)
.var CPU_FRAMECOUNT = $D7FA  // Count number of elapsed video frames
.var FRAMECOUNT = $D7FA  // Count number of elapsed video frames
.var CPU_CARTEN_ADDR = $D7FB  // 1= enable cartridges (address)
.var CARTEN_ADDR = $D7FB  // 1= enable cartridges (address)
.var CPU_CARTEN_MASK = %00000010  // 1= enable cartridges (bit mask)
.var CARTEN_MASK = %00000010  // 1= enable cartridges (bit mask)
.var CPU_POWEREN_ADDR = $D7FD  // Set to zero to power off computer on supported systems. WRITE ONLY. (address)
.var POWEREN_ADDR = $D7FD  // Set to zero to power off computer on supported systems. WRITE ONLY. (address)
.var CPU_POWEREN_MASK = %00000001  // Set to zero to power off computer on supported systems. WRITE ONLY. (bit mask)
.var POWEREN_MASK = %00000001  // Set to zero to power off computer on supported systems. WRITE ONLY. (bit mask)
.var CPU_NOGAME_ADDR = $D7FD  // Override for /GAME : Must be 0 to enable /GAME signal (address)
.var NOGAME_ADDR = $D7FD  // Override for /GAME : Must be 0 to enable /GAME signal (address)
.var CPU_NOGAME_MASK = %01000000  // Override for /GAME : Must be 0 to enable /GAME signal (bit mask)
.var NOGAME_MASK = %01000000  // Override for /GAME : Must be 0 to enable /GAME signal (bit mask)
.var CPU_NOEXROM_ADDR = $D7FD  // Override for /EXROM : Must be 0 to enable /EXROM signal (address)
.var NOEXROM_ADDR = $D7FD  // Override for /EXROM : Must be 0 to enable /EXROM signal (address)
.var CPU_NOEXROM_MASK = %10000000  // Override for /EXROM : Must be 0 to enable /EXROM signal (bit mask)
.var NOEXROM_MASK = %10000000  // Override for /EXROM : Must be 0 to enable /EXROM signal (bit mask)
.var CPU_PREFETCH_ADDR = $D7FE  // Enable expansion RAM pre-fetch logic (address)
.var PREFETCH_ADDR = $D7FE  // Enable expansion RAM pre-fetch logic (address)
.var CPU_PREFETCH_MASK = %00000001  // Enable expansion RAM pre-fetch logic (bit mask)
.var PREFETCH_MASK = %00000001  // Enable expansion RAM pre-fetch logic (bit mask)
.var CPU_OCEANA_ADDR = $D7FE  // Enable Ocean Type A cartridge emulation (address)
.var OCEANA_ADDR = $D7FE  // Enable Ocean Type A cartridge emulation (address)
.var CPU_OCEANA_MASK = %00000010  // Enable Ocean Type A cartridge emulation (bit mask)
.var OCEANA_MASK = %00000010  // Enable Ocean Type A cartridge emulation (bit mask)
.var ETHCOMMAND_DEBUGCPU = $DC  // Select CPU debug stream via ethernet when \$D6E1.3 is set
.var DEBUGCPU = $DC  // Select CPU debug stream via ethernet when \$D6E1.3 is set
.var CIA1_PORTA = $DC00  // Port A
.var CIA1_PORTB = $DC01  // Port B
.var CIA1_DDRA = $DC02  // Port A DDR
.var CIA1_DDRB = $DC03  // Port B DDR
.var CIA1_TIMERA = $DC04  // Timer A counter (16 bit)
.var C64_CIA1_TIMERA = $DC05  // Timer A counter (16 bit)
.var CIA1_TIMERB = $DC06  // Timer B counter (16 bit)
.var C64_CIA1_TIMERB = $DC07  // Timer B counter (16 bit)
.var CIA1_TODJIF_ADDR = $DC08  // TOD tenths of seconds (address)
.var CIA1_TODJIF_MASK = %00001111  // TOD tenths of seconds (bit mask)
.var CIA1_TODSEC_ADDR = $DC09  // TOD seconds (address)
.var CIA1_TODSEC_MASK = %00111111  // TOD seconds (bit mask)
.var CIA1_TODMIN_ADDR = $DC0A  // TOD minutes (address)
.var TODMIN_ADDR = $DC0A  // TOD minutes (address)
.var CIA1_TODMIN_MASK = %00111111  // TOD minutes (bit mask)
.var TODMIN_MASK = %00111111  // TOD minutes (bit mask)
.var CIA1_TODHOUR_ADDR = $DC0B  // TOD hours (address)
.var CIA1_TODHOUR_MASK = %00011111  // TOD hours (bit mask)
.var CIA1_TODAMPM_ADDR = $DC0B  // TOD PM flag (address)
.var CIA1_TODAMPM_MASK = %10000000  // TOD PM flag (bit mask)
.var CIA1_SDR = $DC0C  // shift register data register(writing starts sending)
.var CIA1_TA_ADDR = $DC0D  // Timer A underflow (address)
.var CIA1_TA_MASK = %00000001  // Timer A underflow (bit mask)
.var CIA1_TB_ADDR = $DC0D  // Timer B underflow (address)
.var CIA1_TB_MASK = %00000010  // Timer B underflow (bit mask)
.var CIA1_ALRM_ADDR = $DC0D  // TOD alarm (address)
.var CIA1_ALRM_MASK = %00000100  // TOD alarm (bit mask)
.var CIA1_SP_ADDR = $DC0D  // shift register full/empty (address)
.var CIA1_SP_MASK = %00001000  // shift register full/empty (bit mask)
.var CIA1_FLG_ADDR = $DC0D  // FLAG edge detected (address)
.var CIA1_FLG_MASK = %00010000  // FLAG edge detected (bit mask)
.var CIA1_IR_ADDR = $DC0D  // Interrupt flag (address)
.var IR_ADDR = $DC0D  // Interrupt flag (address)
.var CIA1_IR_MASK = %10000000  // Interrupt flag (bit mask)
.var IR_MASK = %10000000  // Interrupt flag (bit mask)
.var CIA1_STRTA_ADDR = $DC0E  // Timer A start (address)
.var CIA1_STRTA_MASK = %00000001  // Timer A start (bit mask)
.var CIA1_PBONA_ADDR = $DC0E  // Timer A PB6 out (address)
.var CIA1_PBONA_MASK = %00000010  // Timer A PB6 out (bit mask)
.var CIA1_OMODA_ADDR = $DC0E  // Timer A toggle or pulse (address)
.var CIA1_OMODA_MASK = %00000100  // Timer A toggle or pulse (bit mask)
.var CIA1_RMODA_ADDR = $DC0E  // Timer A one-shot mode (address)
.var CIA1_RMODA_MASK = %00001000  // Timer A one-shot mode (bit mask)
.var CIA1_IMODA_ADDR = $DC0E  // Timer A Timer A tick source (address)
.var CIA1_IMODA_MASK = %00100000  // Timer A Timer A tick source (bit mask)
.var CIA1_SPMOD_ADDR = $DC0E  // Serial port direction (address)
.var CIA1_SPMOD_MASK = %01000000  // Serial port direction (bit mask)
.var CIA1_TOD50_ADDR = $DC0E  // 50/60Hz select for TOD clock (address)
.var CIA1_TOD50_MASK = %10000000  // 50/60Hz select for TOD clock (bit mask)
.var CIA1_STRTB_ADDR = $DC0F  // Timer B start (address)
.var CIA1_STRTB_MASK = %00000001  // Timer B start (bit mask)
.var CIA1_PBONB_ADDR = $DC0F  // Timer B PB7 out (address)
.var CIA1_PBONB_MASK = %00000010  // Timer B PB7 out (bit mask)
.var CIA1_OMODB_ADDR = $DC0F  // Timer B toggle or pulse (address)
.var CIA1_OMODB_MASK = %00000100  // Timer B toggle or pulse (bit mask)
.var CIA1_RMODB_ADDR = $DC0F  // Timer B one-shot mode (address)
.var CIA1_RMODB_MASK = %00001000  // Timer B one-shot mode (bit mask)
.var CIA1_LOAD_ADDR = $DC0F  // Strobe input to force-load timers (address)
.var CIA1_LOAD_MASK = %00010000  // Strobe input to force-load timers (bit mask)
.var CIA1_IMODB_ADDR = $DC0F  // Timer B Timer A tick source (address)
.var CIA1_IMODB_MASK = %01100000  // Timer B Timer A tick source (bit mask)
.var CIA2_TODEDIT_ADDR = $DC0F  // TOD alarm edit (address)
.var CIA2_TODEDIT_MASK = %10000000  // TOD alarm edit (bit mask)
.var CIA1_TALATCH = $DC10  // Timer A latch value (16 bit)
.var GS_CIA1_TALATCH = $DC11  // Timer A latch value (16 bit)
.var GS_CIA1_TALATCH_2 = $DC12  // Timer B latch value (16 bit)
.var GS_CIA1_TALATCH_3 = $DC13  // Timer B latch value (16 bit)
.var GS_CIA1_TALATCH_4 = $DC14  // Timer A current value (16 bit)
.var GS_CIA1_TALATCH_5 = $DC15  // Timer A current value (16 bit)
.var GS_CIA1_TALATCH_6 = $DC16  // Timer B current value (16 bit)
.var GS_CIA1_TALATCH_7 = $DC17  // Timer B current value (16 bit)
.var GS_CIA1_TODJIF_ADDR = $DC18  // TOD 10ths of seconds value (address)
.var GS_CIA1_TODJIF_MASK = %00001111  // TOD 10ths of seconds value (bit mask)
.var CIA1_IMTB_ADDR = $DC18  // Interrupt mask for Timer B (address)
.var CIA1_IMTB_MASK = %00010000  // Interrupt mask for Timer B (bit mask)
.var CIA1_IMALRM_ADDR = $DC18  // Interrupt mask for TOD alarm (address)
.var CIA1_IMALRM_MASK = %00100000  // Interrupt mask for TOD alarm (bit mask)
.var CIA1_IMSP_ADDR = $DC18  // Interrupt mask for shift register (serial port) (address)
.var CIA1_IMSP_MASK = %01000000  // Interrupt mask for shift register (serial port) (bit mask)
.var CIA1_IMFLG_ADDR = $DC18  // Interrupt mask for FLAG line (address)
.var CIA1_IMFLG_MASK = %10000000  // Interrupt mask for FLAG line (bit mask)
.var CIA1_TODSEC = $DC19  // TOD Alarm seconds value
.var CIA1_TODMIN = $DC1A  // TOD Alarm minutes value
.var GS_CIA1_TODHOUR_ADDR = $DC1B  // TOD hours value (address)
.var GS_CIA1_TODHOUR_MASK = %01111111  // TOD hours value (bit mask)
.var GS_CIA1_TODAMPM_ADDR = $DC1B  // TOD AM/PM flag (address)
.var GS_CIA1_TODAMPM_MASK = %10000000  // TOD AM/PM flag (bit mask)
.var CIA1_ALRMJIF = $DC1C  // TOD Alarm 10ths of seconds value
.var CIA1_ALRMSEC = $DC1D  // TOD Alarm seconds value
.var CIA1_ALRMMIN = $DC1E  // TOD Alarm minutes value
.var CIA1_ALRMHOUR_ADDR = $DC1F  // TOD Alarm hours value (address)
.var CIA1_ALRMHOUR_MASK = %01111111  // TOD Alarm hours value (bit mask)
.var CIA1_ALRMAMPM_ADDR = $DC1F  // TOD Alarm AM/PM flag (address)
.var CIA1_ALRMAMPM_MASK = %10000000  // TOD Alarm AM/PM flag (bit mask)
.var CIA2_PORTA = $DD00  // Port A
.var CIA2_PORTB = $DD01  // Port B
.var CIA2_DDRA = $DD02  // Port A DDR
.var CIA2_DDRB = $DD03  // Port B DDR
.var CIA2_TIMERA = $DD04  // Timer A counter (16 bit)
.var C64_CIA2_TIMERA = $DD05  // Timer A counter (16 bit)
.var CIA2_TIMERB = $DD06  // Timer B counter (16 bit)
.var C64_CIA2_TIMERB = $DD07  // Timer B counter (16 bit)
.var CIA2_TODJIF_ADDR = $DD08  // TOD tenths of seconds (address)
.var CIA2_TODJIF_MASK = %00001111  // TOD tenths of seconds (bit mask)
.var CIA2_TODSEC_ADDR = $DD09  // TOD seconds (address)
.var CIA2_TODSEC_MASK = %00111111  // TOD seconds (bit mask)
.var CIA2_TODHOUR_ADDR = $DD0B  // TOD hours (address)
.var CIA2_TODHOUR_MASK = %00011111  // TOD hours (bit mask)
.var CIA2_TODAMPM_ADDR = $DD0B  // TOD PM flag (address)
.var CIA2_TODAMPM_MASK = %10000000  // TOD PM flag (bit mask)
.var CIA2_SDR = $DD0C  // shift register data register(writing starts sending)
.var CIA2_TA_ADDR = $DD0D  // Timer A underflow (address)
.var CIA2_TA_MASK = %00000001  // Timer A underflow (bit mask)
.var CIA2_TB_ADDR = $DD0D  // Timer B underflow (address)
.var CIA2_TB_MASK = %00000010  // Timer B underflow (bit mask)
.var CIA2_ALRM_ADDR = $DD0D  // TOD alarm (address)
.var CIA2_ALRM_MASK = %00000100  // TOD alarm (bit mask)
.var CIA2_SP_ADDR = $DD0D  // shift register full/empty (address)
.var CIA2_SP_MASK = %00001000  // shift register full/empty (bit mask)
.var CIA2_FLG_ADDR = $DD0D  // FLAG edge detected (address)
.var CIA2_FLG_MASK = %00010000  // FLAG edge detected (bit mask)
.var CIA2_STRTA_ADDR = $DD0E  // Timer A start (address)
.var CIA2_STRTA_MASK = %00000001  // Timer A start (bit mask)
.var CIA2_PBONA_ADDR = $DD0E  // Timer A PB6 out (address)
.var CIA2_PBONA_MASK = %00000010  // Timer A PB6 out (bit mask)
.var CIA2_OMODA_ADDR = $DD0E  // Timer A toggle or pulse (address)
.var CIA2_OMODA_MASK = %00000100  // Timer A toggle or pulse (bit mask)
.var CIA2_RMODA_ADDR = $DD0E  // Timer A one-shot mode (address)
.var CIA2_RMODA_MASK = %00001000  // Timer A one-shot mode (bit mask)
.var CIA2_IMODA_ADDR = $DD0E  // Timer A Timer A tick source (address)
.var CIA2_IMODA_MASK = %00100000  // Timer A Timer A tick source (bit mask)
.var CIA2_SPMOD_ADDR = $DD0E  // Serial port direction (address)
.var CIA2_SPMOD_MASK = %01000000  // Serial port direction (bit mask)
.var CIA2_TOD50_ADDR = $DD0E  // 50/60Hz select for TOD clock (address)
.var CIA2_TOD50_MASK = %10000000  // 50/60Hz select for TOD clock (bit mask)
.var CIA2_STRTB_ADDR = $DD0F  // Timer B start (address)
.var CIA2_STRTB_MASK = %00000001  // Timer B start (bit mask)
.var CIA2_PBONB_ADDR = $DD0F  // Timer B PB7 out (address)
.var CIA2_PBONB_MASK = %00000010  // Timer B PB7 out (bit mask)
.var CIA2_OMODB_ADDR = $DD0F  // Timer B toggle or pulse (address)
.var CIA2_OMODB_MASK = %00000100  // Timer B toggle or pulse (bit mask)
.var CIA2_RMODB_ADDR = $DD0F  // Timer B one-shot mode (address)
.var CIA2_RMODB_MASK = %00001000  // Timer B one-shot mode (bit mask)
.var CIA2_LOAD_ADDR = $DD0F  // Strobe input to force-load timers (address)
.var CIA2_LOAD_MASK = %00010000  // Strobe input to force-load timers (bit mask)
.var CIA2_IMODB_ADDR = $DD0F  // Timer B Timer A tick source (address)
.var CIA2_IMODB_MASK = %01100000  // Timer B Timer A tick source (bit mask)
.var C64_CIA2_TODEDIT_ADDR = $DD0F  // TOD alarm edit (address)
.var C64_CIA2_TODEDIT_MASK = %10000000  // TOD alarm edit (bit mask)
.var CIA2_TALATCH = $DD10  // Timer A latch value (16 bit)
.var GS_CIA2_TALATCH = $DD11  // Timer A latch value (16 bit)
.var GS_CIA2_TALATCH_2 = $DD12  // Timer B latch value (16 bit)
.var GS_CIA2_TALATCH_3 = $DD13  // Timer B latch value (16 bit)
.var GS_CIA2_TALATCH_4 = $DD14  // Timer A current value (16 bit)
.var GS_CIA2_TALATCH_5 = $DD15  // Timer A current value (16 bit)
.var GS_CIA2_TALATCH_6 = $DD16  // Timer B current value (16 bit)
.var GS_CIA2_TALATCH_7 = $DD17  // Timer B current value (16 bit)
.var GS_CIA2_TODJIF_ADDR = $DD18  // TOD 10ths of seconds value (address)
.var GS_CIA2_TODJIF_MASK = %00001111  // TOD 10ths of seconds value (bit mask)
.var CIA2_IMTB_ADDR = $DD18  // Interrupt mask for Timer B (address)
.var CIA2_IMTB_MASK = %00010000  // Interrupt mask for Timer B (bit mask)
.var CIA2_IMALRM_ADDR = $DD18  // Interrupt mask for TOD alarm (address)
.var CIA2_IMALRM_MASK = %00100000  // Interrupt mask for TOD alarm (bit mask)
.var CIA2_IMSP_ADDR = $DD18  // Interrupt mask for shift register (serial port) (address)
.var CIA2_IMSP_MASK = %01000000  // Interrupt mask for shift register (serial port) (bit mask)
.var CIA2_IMFLG_ADDR = $DD18  // Interrupt mask for FLAG line (address)
.var CIA2_IMFLG_MASK = %10000000  // Interrupt mask for FLAG line (bit mask)
.var CIA2_TODSEC = $DD19  // TOD Alarm seconds value
.var CIA2_TODMIN = $DD1A  // TOD Alarm minutes value
.var GS_CIA2_TODHOUR_ADDR = $DD1B  // TOD hours value (address)
.var GS_CIA2_TODHOUR_MASK = %01111111  // TOD hours value (bit mask)
.var GS_CIA2_TODAMPM_ADDR = $DD1B  // TOD AM/PM flag (address)
.var GS_CIA2_TODAMPM_MASK = %10000000  // TOD AM/PM flag (bit mask)
.var CIA2_ALRMJIF = $DD1C  // TOD Alarm 10ths of seconds value
.var CIA2_DD00DELAY_ADDR = $DD1C  // Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (address)
.var DD00DELAY_ADDR = $DD1C  // Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (address)
.var CIA2_DD00DELAY_MASK = %10000000  // Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (bit mask)
.var DD00DELAY_MASK = %10000000  // Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (bit mask)
.var CIA2_ALRMSEC = $DD1D  // TOD Alarm seconds value
.var CIA2_ALRMMIN = $DD1E  // TOD Alarm minutes value
.var CIA2_ALRMHOUR_ADDR = $DD1F  // TOD Alarm hours value (address)
.var CIA2_ALRMHOUR_MASK = %01111111  // TOD Alarm hours value (bit mask)
.var CIA2_ALRMAMPM_ADDR = $DD1F  // TOD Alarm AM/PM flag (address)
.var CIA2_ALRMAMPM_MASK = %10000000  // TOD Alarm AM/PM flag (bit mask)
.var ETHCOMMAND_RXONLYONE = $DE  // Receive exactly one ethernet frame only, and keep all signals states (for debugging ethernet sub-system)
.var RXONLYONE = $DE  // Receive exactly one ethernet frame only, and keep all signals states (for debugging ethernet sub-system)
.var ETHCOMMAND_FRAME1K = $F1  // Select ~1KiB frames for video/cpu debug stream frames (for receivers that do not support MTUs of greater than 2KiB)
.var FRAME1K = $F1  // Select ~1KiB frames for video/cpu debug stream frames (for receivers that do not support MTUs of greater than 2KiB)
.var ETHCOMMAND_FRAME2K = $F2  // Select ~2KiB frames for video/cpu debug stream frames, for optimal performance.
.var FRAME2K = $F2  // Select ~2KiB frames for video/cpu debug stream frames, for optimal performance.
.var SUMMARY_CHARWRITE = $FF7E000  // VIC-IV CHARROM write area
.var CHARWRITE = $FF7E000  // VIC-IV CHARROM write area
.var SUMMARY_COLOURRAM = $FF80000  // Colour RAM (32KB or 64KB)
.var COLOURRAM = $FF80000  // Colour RAM (32KB or 64KB)
.var RTC_RTCSEC = $FFD7110  // Real-time Clock seconds value (binary coded decimal)
.var RTCSEC = $FFD7110  // Real-time Clock seconds value (binary coded decimal)
.var RTC_RTC = $FFD7110  // Real-time Clock
.var RTC = $FFD7110  // Real-time Clock
.var RTC_RTCMIN = $FFD7111  // Real-time Clock minutes value (binary coded decimal)
.var RTCMIN = $FFD7111  // Real-time Clock minutes value (binary coded decimal)
.var RTC_RTCHOUR = $FFD7112  // Real-time Clock hours value (binary coded decimal)
.var RTCHOUR = $FFD7112  // Real-time Clock hours value (binary coded decimal)
.var RTC_RTCDAY = $FFD7113  // Real-time Clock day of month value (binary coded decimal)
.var RTCDAY = $FFD7113  // Real-time Clock day of month value (binary coded decimal)
.var RTC_RTCMONTH = $FFD7114  // Real-time Clock month value (binary coded decimal)
.var RTCMONTH = $FFD7114  // Real-time Clock month value (binary coded decimal)
.var RTC_RTCYEAR = $FFD7115  // Real-time Clock year value (binary coded decimal)
.var RTCYEAR = $FFD7115  // Real-time Clock year value (binary coded decimal)
.var RTC_NVRAM = $FFD7140  // 64-bytes of non-volatile RAM. Can be used for storing machine configuration.
.var NVRAM = $FFD7140  // 64-bytes of non-volatile RAM. Can be used for storing machine configuration.
.var SUMMARY_HYPERVISOR = $FFF8000  // 16KB Hyppo/Hypervisor ROM
.var HYPERVISOR = $FFF8000  // 16KB Hyppo/Hypervisor ROM
