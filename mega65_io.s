; Generated from: ../mega65-core/iomap.txt
; Date: 2022-06-11

ETHCOMMAND_STOPTX = $00  ; Immediately stop transmitting the current ethernet frame. Will cause a partially sent frame to be received, most likely resulting in the loss of that frame.
STOPTX = $00  ; Immediately stop transmitting the current ethernet frame. Will cause a partially sent frame to be received, most likely resulting in the loss of that frame.
CPU_PORTDDR = $0000000  ; 6510/45GS10 CPU port DDR
PORTDDR = $0000000  ; 6510/45GS10 CPU port DDR
CPU_PORT = $0000001  ; 6510/45GS10 CPU port data
PORT = $0000001  ; 6510/45GS10 CPU port data
ETHCOMMAND_STARTTX = $01  ; Transmit packet
STARTTX = $01  ; Transmit packet
ETHCOMMAND_RXNORMAL = $D0  ; Disable the effects of RXONLYONE
RXNORMAL = $D0  ; Disable the effects of RXONLYONE
VIC2_S0X = $D000  ; sprite N horizontal position
S0X = $D000  ; sprite N horizontal position
VIC2_S0Y = $D001  ; sprite N vertical position
S0Y = $D001  ; sprite N vertical position
VIC2_S1X = $D002  ; @SNX
S1X = $D002  ; @SNX
VIC2_S1Y = $D003  ; @SNY
S1Y = $D003  ; @SNY
VIC2_S2X = $D004  ; @SNX
S2X = $D004  ; @SNX
VIC2_S2Y = $D005  ; @SNY
S2Y = $D005  ; @SNY
VIC2_S3X = $D006  ; @SNX
S3X = $D006  ; @SNX
VIC2_S3Y = $D007  ; @SNY
S3Y = $D007  ; @SNY
VIC2_S4X = $D008  ; @SNX
S4X = $D008  ; @SNX
VIC2_S4Y = $D009  ; @SNY
S4Y = $D009  ; @SNY
VIC2_S5X = $D00A  ; @SNX
S5X = $D00A  ; @SNX
VIC2_S5Y = $D00B  ; @SNY
S5Y = $D00B  ; @SNY
VIC2_S6X = $D00C  ; @SNX
S6X = $D00C  ; @SNX
VIC2_S6Y = $D00D  ; @SNY
S6Y = $D00D  ; @SNY
VIC2_S7X = $D00E  ; @SNX
S7X = $D00E  ; @SNX
VIC2_S7Y = $D00F  ; @SNY
S7Y = $D00F  ; @SNY
VIC2_SXMSB = $D010  ; sprite horizontal position MSBs
SXMSB = $D010  ; sprite horizontal position MSBs
VIC2_YSCL_ADDR = $D011  ; 24/25 vertical smooth scroll (address)
YSCL_ADDR = $D011  ; 24/25 vertical smooth scroll (address)
VIC2_YSCL_MASK = 7  ; 24/25 vertical smooth scroll (bit mask)
YSCL_MASK = 7  ; 24/25 vertical smooth scroll (bit mask)
VIC2_RSEL_ADDR = $D011  ; 24/25 row select (address)
RSEL_ADDR = $D011  ; 24/25 row select (address)
VIC2_RSEL_MASK = 8  ; 24/25 row select (bit mask)
RSEL_MASK = 8  ; 24/25 row select (bit mask)
VIC2_BLNK_ADDR = $D011  ; disable display (address)
BLNK_ADDR = $D011  ; disable display (address)
VIC2_BLNK_MASK = 16  ; disable display (bit mask)
BLNK_MASK = 16  ; disable display (bit mask)
VIC2_BMM_ADDR = $D011  ; bitmap mode (address)
BMM_ADDR = $D011  ; bitmap mode (address)
VIC2_BMM_MASK = 32  ; bitmap mode (bit mask)
BMM_MASK = 32  ; bitmap mode (bit mask)
VIC2_ECM_ADDR = $D011  ; extended background mode (address)
ECM_ADDR = $D011  ; extended background mode (address)
VIC2_ECM_MASK = 64  ; extended background mode (bit mask)
ECM_MASK = 64  ; extended background mode (bit mask)
VIC2_RC_ADDR = $D011  ; raster compare bit 8 (address)
RC_ADDR = $D011  ; raster compare bit 8 (address)
VIC2_RC_MASK = 128  ; raster compare bit 8 (bit mask)
RC_MASK = 128  ; raster compare bit 8 (bit mask)
VIC2_RC = $D012  ; raster compare bits 0 to 7
RC = $D012  ; raster compare bits 0 to 7
VIC2_LPX = $D013  ; Coarse horizontal beam position (was lightpen X)
LPX = $D013  ; Coarse horizontal beam position (was lightpen X)
VIC2_LPY = $D014  ; Coarse vertical beam position (was lightpen Y)
LPY = $D014  ; Coarse vertical beam position (was lightpen Y)
VIC2_SE = $D015  ; sprite enable bits
SE = $D015  ; sprite enable bits
VIC2_XSCL_ADDR = $D016  ; horizontal smooth scroll (address)
XSCL_ADDR = $D016  ; horizontal smooth scroll (address)
VIC2_XSCL_MASK = 7  ; horizontal smooth scroll (bit mask)
XSCL_MASK = 7  ; horizontal smooth scroll (bit mask)
VIC2_CSEL_ADDR = $D016  ; 38/40 column select (address)
CSEL_ADDR = $D016  ; 38/40 column select (address)
VIC2_CSEL_MASK = 8  ; 38/40 column select (bit mask)
CSEL_MASK = 8  ; 38/40 column select (bit mask)
VIC2_MCM_ADDR = $D016  ; Multi-colour mode (address)
MCM_ADDR = $D016  ; Multi-colour mode (address)
VIC2_MCM_MASK = 16  ; Multi-colour mode (bit mask)
MCM_MASK = 16  ; Multi-colour mode (bit mask)
VIC2_RST_ADDR = $D016  ; Disables video output on MAX Machine(tm) VIC-II 6566. Ignored on normal C64s and the MEGA65 (address)
VIC2_RST_MASK = 32  ; Disables video output on MAX Machine(tm) VIC-II 6566. Ignored on normal C64s and the MEGA65 (bit mask)
VIC2_SEXY = $D017  ; sprite vertical expansion enable bits
SEXY = $D017  ; sprite vertical expansion enable bits
VIC2_CB_ADDR = $D018  ; character set address location ($\times$ 1KiB) (address)
CB_ADDR = $D018  ; character set address location ($\times$ 1KiB) (address)
VIC2_CB_MASK = 14  ; character set address location ($\times$ 1KiB) (bit mask)
CB_MASK = 14  ; character set address location ($\times$ 1KiB) (bit mask)
VIC2_VS_ADDR = $D018  ; screen address ($\times$ 1KiB) (address)
VS_ADDR = $D018  ; screen address ($\times$ 1KiB) (address)
VIC2_VS_MASK = 240  ; screen address ($\times$ 1KiB) (bit mask)
VS_MASK = 240  ; screen address ($\times$ 1KiB) (bit mask)
VIC2_RIRQ_ADDR = $D019  ; raster compare indicate or acknowledge (address)
RIRQ_ADDR = $D019  ; raster compare indicate or acknowledge (address)
VIC2_RIRQ_MASK = 1  ; raster compare indicate or acknowledge (bit mask)
RIRQ_MASK = 1  ; raster compare indicate or acknowledge (bit mask)
VIC2_ISBC_ADDR = $D019  ; sprite:bitmap collision indicate or acknowledge (address)
ISBC_ADDR = $D019  ; sprite:bitmap collision indicate or acknowledge (address)
VIC2_ISBC_MASK = 2  ; sprite:bitmap collision indicate or acknowledge (bit mask)
ISBC_MASK = 2  ; sprite:bitmap collision indicate or acknowledge (bit mask)
VIC2_ISSC_ADDR = $D019  ; sprite:sprite collision indicate or acknowledge (address)
ISSC_ADDR = $D019  ; sprite:sprite collision indicate or acknowledge (address)
VIC2_ISSC_MASK = 4  ; sprite:sprite collision indicate or acknowledge (bit mask)
ISSC_MASK = 4  ; sprite:sprite collision indicate or acknowledge (bit mask)
VIC2_ILP_ADDR = $D019  ; light pen indicate or acknowledge (address)
ILP_ADDR = $D019  ; light pen indicate or acknowledge (address)
VIC2_ILP_MASK = 8  ; light pen indicate or acknowledge (bit mask)
ILP_MASK = 8  ; light pen indicate or acknowledge (bit mask)
VIC2_MRIRQ_ADDR = $D01A  ; mask raster IRQ (address)
MRIRQ_ADDR = $D01A  ; mask raster IRQ (address)
VIC2_MRIRQ_MASK = 1  ; mask raster IRQ (bit mask)
MRIRQ_MASK = 1  ; mask raster IRQ (bit mask)
VIC2_MISBC_ADDR = $D01A  ; mask sprite:bitmap collision IRQ (address)
MISBC_ADDR = $D01A  ; mask sprite:bitmap collision IRQ (address)
VIC2_MISBC_MASK = 2  ; mask sprite:bitmap collision IRQ (bit mask)
MISBC_MASK = 2  ; mask sprite:bitmap collision IRQ (bit mask)
VIC2_MISSC_ADDR = $D01A  ; mask sprite:sprite collision IRQ (address)
MISSC_ADDR = $D01A  ; mask sprite:sprite collision IRQ (address)
VIC2_MISSC_MASK = 4  ; mask sprite:sprite collision IRQ (bit mask)
MISSC_MASK = 4  ; mask sprite:sprite collision IRQ (bit mask)
VIC2_BSP = $D01B  ; sprite background priority bits
BSP = $D01B  ; sprite background priority bits
VIC2_SCM = $D01C  ; sprite multicolour enable bits
SCM = $D01C  ; sprite multicolour enable bits
VIC2_SEXX = $D01D  ; sprite horizontal expansion enable bits
SEXX = $D01D  ; sprite horizontal expansion enable bits
VIC2_SSC = $D01E  ; sprite/sprite collision indicate bits
SSC = $D01E  ; sprite/sprite collision indicate bits
VIC2_SBC = $D01F  ; sprite/foreground collision indicate bits
_SBC = $D01F  ; sprite/foreground collision indicate bits
VIC2_BORDERCOL_ADDR = $D020  ; display border colour (16 colour) (address)
VIC2_BORDERCOL_MASK = 15  ; display border colour (16 colour) (bit mask)
VIC3_BORDERCOL_ADDR = $D020  ; display border colour (256 colour) (address)
VIC3_BORDERCOL_MASK = 255  ; display border colour (256 colour) (bit mask)
VIC4_BORDERCOL_ADDR = $D020  ; display border colour (256 colour) (address)
VIC4_BORDERCOL_MASK = 255  ; display border colour (256 colour) (bit mask)
VIC2_SCREENCOL_ADDR = $D021  ; screen colour (16 colour) (address)
VIC2_SCREENCOL_MASK = 15  ; screen colour (16 colour) (bit mask)
VIC3_SCREENCOL_ADDR = $D021  ; screen colour (256 colour) (address)
VIC3_SCREENCOL_MASK = 255  ; screen colour (256 colour) (bit mask)
VIC4_SCREENCOL_ADDR = $D021  ; screen colour (256 colour) (address)
VIC4_SCREENCOL_MASK = 255  ; screen colour (256 colour) (bit mask)
VIC2_MC1_ADDR = $D022  ; multi-colour 1 (16 colour) (address)
VIC2_MC1_MASK = 15  ; multi-colour 1 (16 colour) (bit mask)
VIC3_MC1_ADDR = $D022  ; multi-colour 1 (256 colour) (address)
VIC3_MC1_MASK = 255  ; multi-colour 1 (256 colour) (bit mask)
VIC4_MC1_ADDR = $D022  ; multi-colour 1 (256 colour) (address)
VIC4_MC1_MASK = 255  ; multi-colour 1 (256 colour) (bit mask)
VIC2_MC2_ADDR = $D023  ; multi-colour 2 (16 colour) (address)
VIC2_MC2_MASK = 15  ; multi-colour 2 (16 colour) (bit mask)
VIC3_MC2_ADDR = $D023  ; multi-colour 2 (256 colour) (address)
VIC3_MC2_MASK = 255  ; multi-colour 2 (256 colour) (bit mask)
VIC4_MC2_ADDR = $D023  ; multi-colour 2 (256 colour) (address)
VIC4_MC2_MASK = 255  ; multi-colour 2 (256 colour) (bit mask)
VIC2_MC3_ADDR = $D024  ; multi-colour 3 (16 colour) (address)
VIC2_MC3_MASK = 15  ; multi-colour 3 (16 colour) (bit mask)
VIC3_MC3_ADDR = $D024  ; multi-colour 3 (256 colour) (address)
VIC3_MC3_MASK = 255  ; multi-colour 3 (256 colour) (bit mask)
VIC4_MC3_ADDR = $D024  ; multi-colour 3 (256 colour) (address)
VIC4_MC3_MASK = 255  ; multi-colour 3 (256 colour) (bit mask)
VIC2_SPRMC0 = $D025  ; Sprite multi-colour 0
VIC3_SPRMC0 = $D025  ; Sprite multi-colour 0 (8-bit for selection of any palette colour)
VIC4_SPRMC0 = $D025  ; Sprite multi-colour 0 (8-bit for selection of any palette colour)
VIC2_SPRMC1 = $D026  ; Sprite multi-colour 1
VIC3_SPRMC1 = $D026  ; Sprite multi-colour 1 (8-bit for selection of any palette colour)
VIC4_SPRMC1 = $D026  ; Sprite multi-colour 1 (8-bit for selection of any palette colour)
VIC2_SPR0COL = $D027  ; sprite N colour / 16-colour sprite transparency colour (lower nybl)
SPR0COL = $D027  ; sprite N colour / 16-colour sprite transparency colour (lower nybl)
VIC2_SPR1COL = $D028  ; @SPRNCOL
SPR1COL = $D028  ; @SPRNCOL
VIC2_SPR2COL = $D029  ; @SPRNCOL
SPR2COL = $D029  ; @SPRNCOL
VIC2_SPR3COL = $D02A  ; @SPRNCOL
SPR3COL = $D02A  ; @SPRNCOL
VIC2_SPR4COL = $D02B  ; @SPRNCOL
SPR4COL = $D02B  ; @SPRNCOL
VIC2_SPR5COL = $D02C  ; @SPRNCOL
SPR5COL = $D02C  ; @SPRNCOL
VIC2_SPR6COL = $D02D  ; @SPRNCOL
SPR6COL = $D02D  ; @SPRNCOL
VIC2_SPR7COL = $D02E  ; @SPRNCOL
SPR7COL = $D02E  ; @SPRNCOL
VIC3_KEY = $D02F  ; Write $A5 then $96 to enable C65/VIC-III IO registers
VIC4_KEY = $D02F  ; Write $45 then $54 to map 45E100 ethernet controller buffers to $D000-$DFFF
GS_VIC4_KEY = $D02F  ; Write $47 then $53 to enable C65GS/VIC-IV IO registers
SUMMARY_VIC_III = $D030  ; Control Register A
VIC2_C128_FAST_ADDR = $D030  ; 2MHz select (for C128 2MHz emulation) (address)
C128_FAST_ADDR = $D030  ; 2MHz select (for C128 2MHz emulation) (address)
VIC2_C128_FAST_MASK = 1  ; 2MHz select (for C128 2MHz emulation) (bit mask)
C128_FAST_MASK = 1  ; 2MHz select (for C128 2MHz emulation) (bit mask)
VIC3_CRAM2K_ADDR = $D030  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (address)
CRAM2K_ADDR = $D030  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (address)
VIC3_CRAM2K_MASK = 1  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (bit mask)
CRAM2K_MASK = 1  ; Map 2nd KB of colour RAM @ $DC00-$DFFF (bit mask)
VIC3_EXTSYNC_ADDR = $D030  ; Enable external video sync (genlock input) (address)
EXTSYNC_ADDR = $D030  ; Enable external video sync (genlock input) (address)
VIC3_EXTSYNC_MASK = 2  ; Enable external video sync (genlock input) (bit mask)
EXTSYNC_MASK = 2  ; Enable external video sync (genlock input) (bit mask)
VIC3_PAL_ADDR = $D030  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (address)
PAL_ADDR = $D030  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (address)
VIC3_PAL_MASK = 4  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (bit mask)
PAL_MASK = 4  ; Use PALETTE ROM (0) or RAM (1) entries for colours 0 - 15 (bit mask)
VIC3_ROM8_ADDR = $D030  ; Map C65 ROM @ $8000 (address)
ROM8_ADDR = $D030  ; Map C65 ROM @ $8000 (address)
VIC3_ROM8_MASK = 8  ; Map C65 ROM @ $8000 (bit mask)
ROM8_MASK = 8  ; Map C65 ROM @ $8000 (bit mask)
VIC3_ROMA_ADDR = $D030  ; Map C65 ROM @ $A000 (address)
ROMA_ADDR = $D030  ; Map C65 ROM @ $A000 (address)
VIC3_ROMA_MASK = 16  ; Map C65 ROM @ $A000 (bit mask)
ROMA_MASK = 16  ; Map C65 ROM @ $A000 (bit mask)
VIC3_ROMC_ADDR = $D030  ; Map C65 ROM @ $C000 (address)
ROMC_ADDR = $D030  ; Map C65 ROM @ $C000 (address)
VIC3_ROMC_MASK = 32  ; Map C65 ROM @ $C000 (bit mask)
ROMC_MASK = 32  ; Map C65 ROM @ $C000 (bit mask)
VIC3_CROM9_ADDR = $D030  ; Select between C64 and C65 charset. (address)
CROM9_ADDR = $D030  ; Select between C64 and C65 charset. (address)
VIC3_CROM9_MASK = 64  ; Select between C64 and C65 charset. (bit mask)
CROM9_MASK = 64  ; Select between C64 and C65 charset. (bit mask)
VIC3_ROME_ADDR = $D030  ; Map C65 ROM @ $E000 (address)
ROME_ADDR = $D030  ; Map C65 ROM @ $E000 (address)
VIC3_ROME_MASK = 128  ; Map C65 ROM @ $E000 (bit mask)
ROME_MASK = 128  ; Map C65 ROM @ $E000 (bit mask)
C65_SUMMARY_VIC_III = $D031  ; Control Register B
VIC3_INT_ADDR = $D031  ; Enable VIC-III interlaced mode (address)
INT_ADDR = $D031  ; Enable VIC-III interlaced mode (address)
VIC3_INT_MASK = 1  ; Enable VIC-III interlaced mode (bit mask)
INT_MASK = 1  ; Enable VIC-III interlaced mode (bit mask)
VIC3_MONO_ADDR = $D031  ; Enable VIC-III MONO video output (not implemented) (address)
MONO_ADDR = $D031  ; Enable VIC-III MONO video output (not implemented) (address)
VIC3_MONO_MASK = 2  ; Enable VIC-III MONO video output (not implemented) (bit mask)
MONO_MASK = 2  ; Enable VIC-III MONO video output (not implemented) (bit mask)
VIC3_H1280_ADDR = $D031  ; Enable 1280 horizontal pixels (not implemented) (address)
H1280_ADDR = $D031  ; Enable 1280 horizontal pixels (not implemented) (address)
VIC3_H1280_MASK = 4  ; Enable 1280 horizontal pixels (not implemented) (bit mask)
H1280_MASK = 4  ; Enable 1280 horizontal pixels (not implemented) (bit mask)
VIC3_V400_ADDR = $D031  ; Enable 400 vertical pixels (address)
V400_ADDR = $D031  ; Enable 400 vertical pixels (address)
VIC3_V400_MASK = 8  ; Enable 400 vertical pixels (bit mask)
V400_MASK = 8  ; Enable 400 vertical pixels (bit mask)
VIC3_BPM_ADDR = $D031  ; Bit-Plane Mode (address)
BPM_ADDR = $D031  ; Bit-Plane Mode (address)
VIC3_BPM_MASK = 16  ; Bit-Plane Mode (bit mask)
BPM_MASK = 16  ; Bit-Plane Mode (bit mask)
VIC3_ATTR_ADDR = $D031  ; Enable extended attributes and 8 bit colour entries (address)
ATTR_ADDR = $D031  ; Enable extended attributes and 8 bit colour entries (address)
VIC3_ATTR_MASK = 32  ; Enable extended attributes and 8 bit colour entries (bit mask)
ATTR_MASK = 32  ; Enable extended attributes and 8 bit colour entries (bit mask)
VIC3_FAST_ADDR = $D031  ; Enable C65 FAST mode (~3.5MHz) (address)
FAST_ADDR = $D031  ; Enable C65 FAST mode (~3.5MHz) (address)
VIC3_FAST_MASK = 64  ; Enable C65 FAST mode (~3.5MHz) (bit mask)
FAST_MASK = 64  ; Enable C65 FAST mode (~3.5MHz) (bit mask)
VIC3_H640_ADDR = $D031  ; Enable C64 640 horizontal pixels / 80 column mode (address)
H640_ADDR = $D031  ; Enable C64 640 horizontal pixels / 80 column mode (address)
VIC3_H640_MASK = 128  ; Enable C64 640 horizontal pixels / 80 column mode (bit mask)
H640_MASK = 128  ; Enable C64 640 horizontal pixels / 80 column mode (bit mask)
VIC3_B0ADEVN_ADDR = $D033  ; Bitplane X address, even lines (address)
B0ADEVN_ADDR = $D033  ; Bitplane X address, even lines (address)
VIC3_B0ADEVN_MASK = 14  ; Bitplane X address, even lines (bit mask)
B0ADEVN_MASK = 14  ; Bitplane X address, even lines (bit mask)
VIC3_B0ADODD_ADDR = $D033  ; Bitplane X address, odd lines (address)
B0ADODD_ADDR = $D033  ; Bitplane X address, odd lines (address)
VIC3_B0ADODD_MASK = 224  ; Bitplane X address, odd lines (bit mask)
B0ADODD_MASK = 224  ; Bitplane X address, odd lines (bit mask)
VIC3_B1ADEVN_ADDR = $D034  ; @BXADEVN (address)
B1ADEVN_ADDR = $D034  ; @BXADEVN (address)
VIC3_B1ADEVN_MASK = 14  ; @BXADEVN (bit mask)
B1ADEVN_MASK = 14  ; @BXADEVN (bit mask)
VIC3_B1ADODD_ADDR = $D034  ; @BXADODD (address)
B1ADODD_ADDR = $D034  ; @BXADODD (address)
VIC3_B1ADODD_MASK = 224  ; @BXADODD (bit mask)
B1ADODD_MASK = 224  ; @BXADODD (bit mask)
VIC3_B2ADEVN_ADDR = $D035  ; @BXADEVN (address)
B2ADEVN_ADDR = $D035  ; @BXADEVN (address)
VIC3_B2ADEVN_MASK = 14  ; @BXADEVN (bit mask)
B2ADEVN_MASK = 14  ; @BXADEVN (bit mask)
VIC3_B2ADODD_ADDR = $D035  ; @BXADODD (address)
B2ADODD_ADDR = $D035  ; @BXADODD (address)
VIC3_B2ADODD_MASK = 224  ; @BXADODD (bit mask)
B2ADODD_MASK = 224  ; @BXADODD (bit mask)
VIC3_B3ADEVN_ADDR = $D036  ; @BXADEVN (address)
B3ADEVN_ADDR = $D036  ; @BXADEVN (address)
VIC3_B3ADEVN_MASK = 14  ; @BXADEVN (bit mask)
B3ADEVN_MASK = 14  ; @BXADEVN (bit mask)
VIC3_B3ADODD_ADDR = $D036  ; @BXADODD (address)
B3ADODD_ADDR = $D036  ; @BXADODD (address)
VIC3_B3ADODD_MASK = 224  ; @BXADODD (bit mask)
B3ADODD_MASK = 224  ; @BXADODD (bit mask)
VIC3_B4ADEVN_ADDR = $D037  ; @BXADEVN (address)
B4ADEVN_ADDR = $D037  ; @BXADEVN (address)
VIC3_B4ADEVN_MASK = 14  ; @BXADEVN (bit mask)
B4ADEVN_MASK = 14  ; @BXADEVN (bit mask)
VIC3_B4ADODD_ADDR = $D037  ; @BXADODD (address)
B4ADODD_ADDR = $D037  ; @BXADODD (address)
VIC3_B4ADODD_MASK = 224  ; @BXADODD (bit mask)
B4ADODD_MASK = 224  ; @BXADODD (bit mask)
VIC3_B5ADEVN_ADDR = $D038  ; @BXADEVN (address)
B5ADEVN_ADDR = $D038  ; @BXADEVN (address)
VIC3_B5ADEVN_MASK = 14  ; @BXADEVN (bit mask)
B5ADEVN_MASK = 14  ; @BXADEVN (bit mask)
VIC3_B5ADODD_ADDR = $D038  ; @BXADODD (address)
B5ADODD_ADDR = $D038  ; @BXADODD (address)
VIC3_B5ADODD_MASK = 224  ; @BXADODD (bit mask)
B5ADODD_MASK = 224  ; @BXADODD (bit mask)
VIC3_B6ADEVN_ADDR = $D039  ; @BXADEVN (address)
B6ADEVN_ADDR = $D039  ; @BXADEVN (address)
VIC3_B6ADEVN_MASK = 14  ; @BXADEVN (bit mask)
B6ADEVN_MASK = 14  ; @BXADEVN (bit mask)
VIC3_B6ADODD_ADDR = $D039  ; @BXADODD (address)
B6ADODD_ADDR = $D039  ; @BXADODD (address)
VIC3_B6ADODD_MASK = 224  ; @BXADODD (bit mask)
B6ADODD_MASK = 224  ; @BXADODD (bit mask)
VIC3_B7ADEVN_ADDR = $D03A  ; @BXADEVN (address)
B7ADEVN_ADDR = $D03A  ; @BXADEVN (address)
VIC3_B7ADEVN_MASK = 14  ; @BXADEVN (bit mask)
B7ADEVN_MASK = 14  ; @BXADEVN (bit mask)
VIC3_B7ADODD_ADDR = $D03A  ; @BXADODD (address)
B7ADODD_ADDR = $D03A  ; @BXADODD (address)
VIC3_B7ADODD_MASK = 224  ; @BXADODD (bit mask)
B7ADODD_MASK = 224  ; @BXADODD (bit mask)
VIC3_BPCOMP = $D03B  ; Complement bitplane flags
BPCOMP = $D03B  ; Complement bitplane flags
VIC3_BPX = $D03C  ; Bitplane X
BPX = $D03C  ; Bitplane X
VIC3_BPY = $D03D  ; Bitplane Y
BPY = $D03D  ; Bitplane Y
VIC3_HPOS = $D03E  ; Bitplane X Offset
HPOS = $D03E  ; Bitplane X Offset
VIC3_VPOS = $D03F  ; Bitplane Y Offset
VPOS = $D03F  ; Bitplane Y Offset
VIC3_B0PIX = $D040  ; Display Address Translater (DAT) Bitplane N port
B0PIX = $D040  ; Display Address Translater (DAT) Bitplane N port
VIC3_B1PIX = $D041  ; @BNPIX
B1PIX = $D041  ; @BNPIX
VIC3_B2PIX = $D042  ; @BNPIX
B2PIX = $D042  ; @BNPIX
VIC3_B3PIX = $D043  ; @BNPIX
B3PIX = $D043  ; @BNPIX
VIC3_B4PIX = $D044  ; @BNPIX
B4PIX = $D044  ; @BNPIX
VIC3_B5PIX = $D045  ; @BNPIX
B5PIX = $D045  ; @BNPIX
VIC3_B6PIX = $D046  ; @BNPIX
B6PIX = $D046  ; @BNPIX
VIC3_B7PIX = $D047  ; @BNPIX
B7PIX = $D047  ; @BNPIX
VIC4_TBDRPOS = $D048  ; top border position
TBDRPOS = $D048  ; top border position
VIC4_TBDRPOS_ADDR = $D049  ; top border position MSB (address)
TBDRPOS_ADDR = $D049  ; top border position MSB (address)
VIC4_TBDRPOS_MASK = 15  ; top border position MSB (bit mask)
TBDRPOS_MASK = 15  ; top border position MSB (bit mask)
VIC4_SPRBPMEN_ADDR = $D049  ; Sprite bitplane-modify-mode enables (address)
VIC4_SPRBPMEN_MASK = 240  ; Sprite bitplane-modify-mode enables (bit mask)
VIC4_BBDRPOS = $D04A  ; bottom border position
BBDRPOS = $D04A  ; bottom border position
VIC4_BBDRPOS_ADDR = $D04B  ; bottom border position (address)
BBDRPOS_ADDR = $D04B  ; bottom border position (address)
VIC4_BBDRPOS_MASK = 15  ; bottom border position (bit mask)
BBDRPOS_MASK = 15  ; bottom border position (bit mask)
GS_VIC4_SPRBPMEN_ADDR = $D04B  ; Sprite bitplane-modify-mode enables (address)
GS_VIC4_SPRBPMEN_MASK = 240  ; Sprite bitplane-modify-mode enables (bit mask)
VIC4_TEXTXPOS = $D04C  ; character generator horizontal position
TEXTXPOS = $D04C  ; character generator horizontal position
VIC4_TEXTXPOS_ADDR = $D04D  ; character generator horizontal position (address)
TEXTXPOS_ADDR = $D04D  ; character generator horizontal position (address)
VIC4_TEXTXPOS_MASK = 15  ; character generator horizontal position (bit mask)
TEXTXPOS_MASK = 15  ; character generator horizontal position (bit mask)
VIC4_SPRTILEN_ADDR = $D04D  ; Sprite horizontal tile enables. (address)
VIC4_SPRTILEN_MASK = 240  ; Sprite horizontal tile enables. (bit mask)
VIC4_TEXTYPOS = $D04E  ; Character generator vertical position
TEXTYPOS = $D04E  ; Character generator vertical position
VIC4_TEXTYPOS_ADDR = $D04F  ; Character generator vertical position (address)
TEXTYPOS_ADDR = $D04F  ; Character generator vertical position (address)
VIC4_TEXTYPOS_MASK = 15  ; Character generator vertical position (bit mask)
TEXTYPOS_MASK = 15  ; Character generator vertical position (bit mask)
GS_VIC4_SPRTILEN_ADDR = $D04F  ; Sprite 7-4 horizontal tile enables (address)
GS_VIC4_SPRTILEN_MASK = 240  ; Sprite 7-4 horizontal tile enables (bit mask)
VIC4_XPOSLSB = $D050  ; Read horizontal raster scan position LSB
XPOSLSB = $D050  ; Read horizontal raster scan position LSB
VIC4_XPOSMSB_ADDR = $D051  ; Read horizontal raster scan position MSB (address)
XPOSMSB_ADDR = $D051  ; Read horizontal raster scan position MSB (address)
VIC4_XPOSMSB_MASK = 63  ; Read horizontal raster scan position MSB (bit mask)
XPOSMSB_MASK = 63  ; Read horizontal raster scan position MSB (bit mask)
VIC4_DBLRR_ADDR = $D051  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (address)
DBLRR_ADDR = $D051  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (address)
VIC4_DBLRR_MASK = 64  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (bit mask)
DBLRR_MASK = 64  ; When set, the Raster Rewrite Buffer is only updated every 2nd raster line, limiting resolution to V200, but allowing more cycles for Raster-Rewrite actions. (bit mask)
VIC4_NORRDEL_ADDR = $D051  ; When clear, raster rewrite double buffering is used (address)
NORRDEL_ADDR = $D051  ; When clear, raster rewrite double buffering is used (address)
VIC4_NORRDEL_MASK = 128  ; When clear, raster rewrite double buffering is used (bit mask)
NORRDEL_MASK = 128  ; When clear, raster rewrite double buffering is used (bit mask)
VIC4_FNRASTERLSB = $D052  ; Read physical raster position
FNRASTERLSB = $D052  ; Read physical raster position
VIC4_FN_RASTER_MSB_ADDR = $D053  ; Read physical raster position (address)
FN_RASTER_MSB_ADDR = $D053  ; Read physical raster position (address)
VIC4_FN_RASTER_MSB_MASK = 7  ; Read physical raster position (bit mask)
FN_RASTER_MSB_MASK = 7  ; Read physical raster position (bit mask)
VIC4_SHDEMU_ADDR = $D053  ; Enable simulated shadow-mask (PALEMU must also be enabled) (address)
SHDEMU_ADDR = $D053  ; Enable simulated shadow-mask (PALEMU must also be enabled) (address)
VIC4_SHDEMU_MASK = 64  ; Enable simulated shadow-mask (PALEMU must also be enabled) (bit mask)
SHDEMU_MASK = 64  ; Enable simulated shadow-mask (PALEMU must also be enabled) (bit mask)
VIC4_FNRST_ADDR = $D053  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (address)
FNRST_ADDR = $D053  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (address)
VIC4_FNRST_MASK = 128  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (bit mask)
FNRST_MASK = 128  ; Raster compare source (0=VIC-IV fine raster, 1=VIC-II raster) (bit mask)
SUMMARY_VIC_IV = $D054  ; Control register C
VIC_IV = $D054  ; Control register C
VIC4_CHR16_ADDR = $D054  ; enable 16-bit character numbers (two screen bytes per character) (address)
CHR16_ADDR = $D054  ; enable 16-bit character numbers (two screen bytes per character) (address)
VIC4_CHR16_MASK = 1  ; enable 16-bit character numbers (two screen bytes per character) (bit mask)
CHR16_MASK = 1  ; enable 16-bit character numbers (two screen bytes per character) (bit mask)
VIC4_FCLRLO_ADDR = $D054  ; enable full-colour mode for character numbers <=$FF (address)
FCLRLO_ADDR = $D054  ; enable full-colour mode for character numbers <=$FF (address)
VIC4_FCLRLO_MASK = 2  ; enable full-colour mode for character numbers <=$FF (bit mask)
FCLRLO_MASK = 2  ; enable full-colour mode for character numbers <=$FF (bit mask)
VIC4_FCLRHI_ADDR = $D054  ; enable full-colour mode for character numbers >$FF (address)
FCLRHI_ADDR = $D054  ; enable full-colour mode for character numbers >$FF (address)
VIC4_FCLRHI_MASK = 4  ; enable full-colour mode for character numbers >$FF (bit mask)
FCLRHI_MASK = 4  ; enable full-colour mode for character numbers >$FF (bit mask)
VIC4_SMTH_ADDR = $D054  ; video output horizontal smoothing enable (address)
SMTH_ADDR = $D054  ; video output horizontal smoothing enable (address)
VIC4_SMTH_MASK = 8  ; video output horizontal smoothing enable (bit mask)
SMTH_MASK = 8  ; video output horizontal smoothing enable (bit mask)
VIC4_SPR640_ADDR = $D054  ; Sprite H640 enable; (address)
SPR640_ADDR = $D054  ; Sprite H640 enable; (address)
VIC4_SPR640_MASK = 16  ; Sprite H640 enable; (bit mask)
SPR640_MASK = 16  ; Sprite H640 enable; (bit mask)
VIC4_PALEMU_ADDR = $D054  ; Enable PAL CRT-like scan-line emulation (address)
PALEMU_ADDR = $D054  ; Enable PAL CRT-like scan-line emulation (address)
VIC4_PALEMU_MASK = 32  ; Enable PAL CRT-like scan-line emulation (bit mask)
PALEMU_MASK = 32  ; Enable PAL CRT-like scan-line emulation (bit mask)
VIC4_VFAST_ADDR = $D054  ; C65GS FAST mode (48MHz) (address)
VFAST_ADDR = $D054  ; C65GS FAST mode (48MHz) (address)
VIC4_VFAST_MASK = 64  ; C65GS FAST mode (48MHz) (bit mask)
VFAST_MASK = 64  ; C65GS FAST mode (48MHz) (bit mask)
VIC4_ALPHEN_ADDR = $D054  ; Alpha compositor enable (address)
ALPHEN_ADDR = $D054  ; Alpha compositor enable (address)
VIC4_ALPHEN_MASK = 128  ; Alpha compositor enable (bit mask)
ALPHEN_MASK = 128  ; Alpha compositor enable (bit mask)
VIC4_SPRHGTEN = $D055  ; sprite extended height enable (one bit per sprite)
SPRHGTEN = $D055  ; sprite extended height enable (one bit per sprite)
VIC4_SPRHGHT = $D056  ; Sprite extended height size (sprite pixels high)
SPRHGHT = $D056  ; Sprite extended height size (sprite pixels high)
VIC4_SPRX64EN = $D057  ; Sprite extended width enables (8 bytes per sprite row = 64 pixels wide for normal sprites or 16 pixels wide for 16-colour sprite mode)
SPRX64EN = $D057  ; Sprite extended width enables (8 bytes per sprite row = 64 pixels wide for normal sprites or 16 pixels wide for 16-colour sprite mode)
VIC4_LINESTEPLSB = $D058  ; number of bytes to advance between each text row (LSB)
LINESTEPLSB = $D058  ; number of bytes to advance between each text row (LSB)
VIC4_LINESTEPMSB = $D059  ; number of bytes to advance between each text row (MSB)
LINESTEPMSB = $D059  ; number of bytes to advance between each text row (MSB)
VIC4_CHRXSCL = $D05A  ; Horizontal hardware scale of text mode (pixel 120ths per pixel)
CHRXSCL = $D05A  ; Horizontal hardware scale of text mode (pixel 120ths per pixel)
VIC4_CHRYSCL = $D05B  ; Vertical scaling of text mode (number of physical rasters per char text row)
CHRYSCL = $D05B  ; Vertical scaling of text mode (number of physical rasters per char text row)
VIC4_SDBDRWD_LSB = $D05C  ; Width of single side border (LSB)
SDBDRWD_LSB = $D05C  ; Width of single side border (LSB)
VIC4_SDBDRWD_MSB_ADDR = $D05D  ; side border width (MSB) (address)
SDBDRWD_MSB_ADDR = $D05D  ; side border width (MSB) (address)
VIC4_SDBDRWD_MSB_MASK = 63  ; side border width (MSB) (bit mask)
SDBDRWD_MSB_MASK = 63  ; side border width (MSB) (bit mask)
VIC4_RST_DELEN_ADDR = $D05D  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (address)
RST_DELEN_ADDR = $D05D  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (address)
VIC4_RST_DELEN_MASK = 64  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (bit mask)
RST_DELEN_MASK = 64  ; Enable raster delay (delays raster counter and interrupts by one line to match output pipeline latency) (bit mask)
VIC4_HOTREG_ADDR = $D05D  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (address)
HOTREG_ADDR = $D05D  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (address)
VIC4_HOTREG_MASK = 128  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (bit mask)
HOTREG_MASK = 128  ; Enable VIC-II hot registers. When enabled, touching many VIC-II registers causes the VIC-IV to recalculate display parameters, such as border positions and sizes (bit mask)
VIC4_CHRCOUNT = $D05E  ; Number of characters to display per row (LSB)
CHRCOUNT = $D05E  ; Number of characters to display per row (LSB)
VIC4_SPRXSMSBS = $D05F  ; Sprite H640 X Super-MSBs
SPRXSMSBS = $D05F  ; Sprite H640 X Super-MSBs
VIC4_SCRNPTRLSB = $D060  ; screen RAM precise base address (bits 0 - 7)
SCRNPTRLSB = $D060  ; screen RAM precise base address (bits 0 - 7)
VIC4_SCRNPTRMSB = $D061  ; screen RAM precise base address (bits 15 - 8)
SCRNPTRMSB = $D061  ; screen RAM precise base address (bits 15 - 8)
VIC4_SCRNPTRBNK = $D062  ; screen RAM precise base address (bits 23 - 16)
SCRNPTRBNK = $D062  ; screen RAM precise base address (bits 23 - 16)
VIC4_SCRNPTRMB_ADDR = $D063  ; screen RAM precise base address (bits 31 - 24) (address)
SCRNPTRMB_ADDR = $D063  ; screen RAM precise base address (bits 31 - 24) (address)
VIC4_SCRNPTRMB_MASK = 15  ; screen RAM precise base address (bits 31 - 24) (bit mask)
SCRNPTRMB_MASK = 15  ; screen RAM precise base address (bits 31 - 24) (bit mask)
VIC4_CHRCOUNT_ADDR = $D063  ; Number of characters to display per (address)
CHRCOUNT_ADDR = $D063  ; Number of characters to display per (address)
VIC4_CHRCOUNT_MASK = 48  ; Number of characters to display per (bit mask)
CHRCOUNT_MASK = 48  ; Number of characters to display per (bit mask)
VIC4_EXGLYPH_ADDR = $D063  ; source full-colour character data from expansion RAM (address)
EXGLYPH_ADDR = $D063  ; source full-colour character data from expansion RAM (address)
VIC4_EXGLYPH_MASK = 128  ; source full-colour character data from expansion RAM (bit mask)
EXGLYPH_MASK = 128  ; source full-colour character data from expansion RAM (bit mask)
VIC4_COLPTRLSB = $D064  ; colour RAM base address (bits 0 - 7)
COLPTRLSB = $D064  ; colour RAM base address (bits 0 - 7)
VIC4_COLPTRMSB = $D065  ; colour RAM base address (bits 15 - 8)
COLPTRMSB = $D065  ; colour RAM base address (bits 15 - 8)
DEBUG_SBPDEBUG = $D067  ; Sprite/bitplane first X DEBUG WILL BE REMOVED
SBPDEBUG = $D067  ; Sprite/bitplane first X DEBUG WILL BE REMOVED
VIC4_CHARPTRLSB = $D068  ; Character set precise base address (bits 0 - 7)
CHARPTRLSB = $D068  ; Character set precise base address (bits 0 - 7)
VIC4_CHARPTRMSB = $D069  ; Character set precise base address (bits 15 - 8)
CHARPTRMSB = $D069  ; Character set precise base address (bits 15 - 8)
VIC4_CHARPTRBNK = $D06A  ; Character set precise base address (bits 23 - 16)
CHARPTRBNK = $D06A  ; Character set precise base address (bits 23 - 16)
VIC4_SPR16EN = $D06B  ; sprite 16-colour mode enables
SPR16EN = $D06B  ; sprite 16-colour mode enables
VIC4_SPRPTRADRLSB = $D06C  ; sprite pointer address (bits 7 - 0)
SPRPTRADRLSB = $D06C  ; sprite pointer address (bits 7 - 0)
VIC4_SPRPTRADRMSB = $D06D  ; sprite pointer address (bits 15 - 8)
SPRPTRADRMSB = $D06D  ; sprite pointer address (bits 15 - 8)
VIC4_SPRPTRBNK_ADDR = $D06E  ; sprite pointer address (bits 23 - 16) (address)
SPRPTRBNK_ADDR = $D06E  ; sprite pointer address (bits 23 - 16) (address)
VIC4_SPRPTRBNK_MASK = 127  ; sprite pointer address (bits 23 - 16) (bit mask)
SPRPTRBNK_MASK = 127  ; sprite pointer address (bits 23 - 16) (bit mask)
VIC4_SPR_PTR16_ADDR = $D06E  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (address)
SPR_PTR16_ADDR = $D06E  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (address)
VIC4_SPR_PTR16_MASK = 128  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (bit mask)
SPR_PTR16_MASK = 128  ; 16-bit sprite pointer mode (allows sprites to be located on any 64 byte boundary in chip RAM) (bit mask)
VIC4_RASLINE0_ADDR = $D06F  ; first VIC-II raster line (address)
RASLINE0_ADDR = $D06F  ; first VIC-II raster line (address)
VIC4_RASLINE0_MASK = 63  ; first VIC-II raster line (bit mask)
RASLINE0_MASK = 63  ; first VIC-II raster line (bit mask)
VIC4_VGAHDTV_ADDR = $D06F  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (address)
VGAHDTV_ADDR = $D06F  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (address)
VIC4_VGAHDTV_MASK = 64  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (bit mask)
VGAHDTV_MASK = 64  ; Select more VGA-compatible mode if set, instead of HDMI/HDTV VIC-II cycle-exact frame timing. May help to produce a functional display on older VGA monitors. (bit mask)
VIC4_PALNTSC_ADDR = $D06F  ; NTSC emulation mode (max raster = 262) (address)
PALNTSC_ADDR = $D06F  ; NTSC emulation mode (max raster = 262) (address)
VIC4_PALNTSC_MASK = 128  ; NTSC emulation mode (max raster = 262) (bit mask)
PALNTSC_MASK = 128  ; NTSC emulation mode (max raster = 262) (bit mask)
VIC4_ABTPALSEL_ADDR = $D070  ; VIC-IV bitmap/text palette bank (alternate palette) (address)
ABTPALSEL_ADDR = $D070  ; VIC-IV bitmap/text palette bank (alternate palette) (address)
VIC4_ABTPALSEL_MASK = 3  ; VIC-IV bitmap/text palette bank (alternate palette) (bit mask)
ABTPALSEL_MASK = 3  ; VIC-IV bitmap/text palette bank (alternate palette) (bit mask)
VIC4_SPRPALSEL_ADDR = $D070  ; sprite palette bank (address)
SPRPALSEL_ADDR = $D070  ; sprite palette bank (address)
VIC4_SPRPALSEL_MASK = 12  ; sprite palette bank (bit mask)
SPRPALSEL_MASK = 12  ; sprite palette bank (bit mask)
VIC4_BTPALSEL_ADDR = $D070  ; bitmap/text palette bank (address)
BTPALSEL_ADDR = $D070  ; bitmap/text palette bank (address)
VIC4_BTPALSEL_MASK = 48  ; bitmap/text palette bank (bit mask)
BTPALSEL_MASK = 48  ; bitmap/text palette bank (bit mask)
VIC4_MAPEDPAL_ADDR = $D070  ; palette bank mapped at $D100-$D3FF (address)
MAPEDPAL_ADDR = $D070  ; palette bank mapped at $D100-$D3FF (address)
VIC4_MAPEDPAL_MASK = 192  ; palette bank mapped at $D100-$D3FF (bit mask)
MAPEDPAL_MASK = 192  ; palette bank mapped at $D100-$D3FF (bit mask)
VIC4_BP16ENS = $D071  ; VIC-IV 16-colour bitplane enable flags
BP16ENS = $D071  ; VIC-IV 16-colour bitplane enable flags
VIC4_SPRYADJ = $D072  ; Sprite Y position adjustment
SPRYADJ = $D072  ; Sprite Y position adjustment
VIC4_ALPHADELAY_ADDR = $D073  ; Alpha delay for compositor (address)
ALPHADELAY_ADDR = $D073  ; Alpha delay for compositor (address)
VIC4_ALPHADELAY_MASK = 15  ; Alpha delay for compositor (bit mask)
ALPHADELAY_MASK = 15  ; Alpha delay for compositor (bit mask)
VIC4_RASTERHEIGHT_ADDR = $D073  ; physical rasters per VIC-II raster (1 to 16) (address)
RASTERHEIGHT_ADDR = $D073  ; physical rasters per VIC-II raster (1 to 16) (address)
VIC4_RASTERHEIGHT_MASK = 240  ; physical rasters per VIC-II raster (1 to 16) (bit mask)
RASTERHEIGHT_MASK = 240  ; physical rasters per VIC-II raster (1 to 16) (bit mask)
VIC4_SPRENALPHA = $D074  ; Sprite alpha-blend enable
SPRENALPHA = $D074  ; Sprite alpha-blend enable
VIC4_SPRALPHAVAL = $D075  ; Sprite alpha-blend value
SPRALPHAVAL = $D075  ; Sprite alpha-blend value
VIC4_SPRENV400 = $D076  ; Sprite V400 enables
SPRENV400 = $D076  ; Sprite V400 enables
VIC4_SRPYMSBS = $D077  ; Sprite V400 Y position MSBs
SRPYMSBS = $D077  ; Sprite V400 Y position MSBs
VIC4_SPRYSMSBS = $D078  ; Sprite V400 Y position super MSBs
SPRYSMSBS = $D078  ; Sprite V400 Y position super MSBs
VIC4_RSTCOMP = $D079  ; Raster compare value
RSTCOMP = $D079  ; Raster compare value
VIC4_RSTCMP_ADDR = $D07A  ; Raster compare value MSB (address)
RSTCMP_ADDR = $D07A  ; Raster compare value MSB (address)
VIC4_RSTCMP_MASK = 7  ; Raster compare value MSB (bit mask)
RSTCMP_MASK = 7  ; Raster compare value MSB (bit mask)
VIC4_SPTR_CONT_ADDR = $D07A  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (address)
SPTR_CONT_ADDR = $D07A  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (address)
VIC4_SPTR_CONT_MASK = 8  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (bit mask)
SPTR_CONT_MASK = 8  ; Continuously monitor sprite pointer, to allow changing sprite data source while a sprite is being drawn (bit mask)
VIC4_RESV_ADDR = $D07A  ; Reserved. (address)
VIC4_RESV_MASK = 48  ; Reserved. (bit mask)
VIC4_EXTIRQS_ADDR = $D07A  ; Enable additional IRQ sources, e.g., raster X position. (address)
EXTIRQS_ADDR = $D07A  ; Enable additional IRQ sources, e.g., raster X position. (address)
VIC4_EXTIRQS_MASK = 64  ; Enable additional IRQ sources, e.g., raster X position. (bit mask)
EXTIRQS_MASK = 64  ; Enable additional IRQ sources, e.g., raster X position. (bit mask)
VIC4_FNRST_CMP_ADDR = $D07A  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (address)
FNRST_CMP_ADDR = $D07A  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (address)
VIC4_FNRST_CMP_MASK = 128  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (bit mask)
FNRST_CMP_MASK = 128  ; Raster compare is in physical rasters if set, or VIC-II raster if clear (bit mask)
VIC4_Number = $D07B  ; of text rows to display
Number = $D07B  ; of text rows to display
VIC4_BIT_PBANK_ADDR = $D07C  ; Set which 128KB bank bitplanes (address)
BIT_PBANK_ADDR = $D07C  ; Set which 128KB bank bitplanes (address)
VIC4_BIT_PBANK_MASK = 7  ; Set which 128KB bank bitplanes (bit mask)
BIT_PBANK_MASK = 7  ; Set which 128KB bank bitplanes (bit mask)
GS_VIC4_RESV_ADDR = $D07C  ; @RESV (address)
GS_VIC4_RESV_MASK = 8  ; @RESV (bit mask)
VIC4_HSYNCP_ADDR = $D07C  ; hsync polarity (address)
HSYNCP_ADDR = $D07C  ; hsync polarity (address)
VIC4_HSYNCP_MASK = 16  ; hsync polarity (bit mask)
HSYNCP_MASK = 16  ; hsync polarity (bit mask)
VIC4_VSYNCP_ADDR = $D07C  ; vsync polarity (address)
VSYNCP_ADDR = $D07C  ; vsync polarity (address)
VIC4_VSYNCP_MASK = 32  ; vsync polarity (bit mask)
VSYNCP_MASK = 32  ; vsync polarity (bit mask)
VIC4_DEBUGC_ADDR = $D07C  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (address)
DEBUGC_ADDR = $D07C  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (address)
VIC4_DEBUGC_MASK = 192  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (bit mask)
DEBUGC_MASK = 192  ; VIC-IV debug pixel select red(01), green(10) or blue(11) channel visible in $D07D (bit mask)
DEBUG_DEBUGOUT = $D07D  ; VIC-IV debug value read-back (read only)
DEBUGOUT = $D07D  ; VIC-IV debug value read-back (read only)
DEBUG_DEBUGX = $D07D  ; VIC-IV debug X position (LSB) (write only)
DEBUGX = $D07D  ; VIC-IV debug X position (LSB) (write only)
DEBUG_DEBUGY = $D07E  ; VIC-IV debug Y position (LSB)
DEBUGY = $D07E  ; VIC-IV debug Y position (LSB)
DEBUG_DEBUGX_ADDR = $D07F  ; VIC-IV debug X position (MSB) (address)
DEBUGX_ADDR = $D07F  ; VIC-IV debug X position (MSB) (address)
DEBUG_DEBUGX_MASK = 15  ; VIC-IV debug X position (MSB) (bit mask)
DEBUGX_MASK = 15  ; VIC-IV debug X position (MSB) (bit mask)
DEBUG_DEBUGY_ADDR = $D07F  ; VIC-IV debug Y position (MSB) (address)
DEBUGY_ADDR = $D07F  ; VIC-IV debug Y position (MSB) (address)
DEBUG_DEBUGY_MASK = 240  ; VIC-IV debug Y position (MSB) (bit mask)
DEBUGY_MASK = 240  ; VIC-IV debug Y position (MSB) (bit mask)
DEBUG_DEBUGOOF_ADDR = $D07F  ; VIC-IV debug out-of-frame signal enable (address)
DEBUGOOF_ADDR = $D07F  ; VIC-IV debug out-of-frame signal enable (address)
DEBUG_DEBUGOOF_MASK = 128  ; VIC-IV debug out-of-frame signal enable (bit mask)
DEBUGOOF_MASK = 128  ; VIC-IV debug out-of-frame signal enable (bit mask)
FDC_DS_ADDR = $D080  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (address)
DS_ADDR = $D080  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (address)
FDC_DS_MASK = 7  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (bit mask)
DS_MASK = 7  ; Drive select (0 to 7). Internal drive is 0. Second floppy drive on internal cable is 1. Other values reserved for C1565 external drive interface. (bit mask)
FDC_SIDE_ADDR = $D080  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (address)
SIDE_ADDR = $D080  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (address)
FDC_SIDE_MASK = 8  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (bit mask)
SIDE_MASK = 8  ; Directly controls the SIDE signal to the floppy drive, i.e., selecting which side of the media is active. (bit mask)
FDC_SWAP_ADDR = $D080  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (address)
SWAP_ADDR = $D080  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (address)
FDC_SWAP_MASK = 16  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (bit mask)
SWAP_MASK = 16  ; Swap upper and lower halves of data buffer (i.e. invert bit 8 of the sector buffer) (bit mask)
FDC_MOTOR_ADDR = $D080  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (address)
MOTOR_ADDR = $D080  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (address)
FDC_MOTOR_MASK = 32  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (bit mask)
MOTOR_MASK = 32  ; Activates drive motor and LED (unless LED signal is also set, causing the drive LED to blink) (bit mask)
FDC_LED_ADDR = $D080  ; Drive LED blinks when set (address)
FDC_LED_MASK = 64  ; Drive LED blinks when set (bit mask)
FDC_IRQ_ADDR = $D080  ; When set, enables interrupts to occur. Clearing clears any pending interrupt and disables interrupts until set again. (address)
FDC_IRQ_MASK = 128  ; When set, enables interrupts to occur. Clearing clears any pending interrupt and disables interrupts until set again. (bit mask)
FDC_COMMAND = $D081  ; F011 FDC command register
FDC_NOBUF_ADDR = $D081  ; Reset the sector buffer read/write pointers (address)
NOBUF_ADDR = $D081  ; Reset the sector buffer read/write pointers (address)
FDC_NOBUF_MASK = 1  ; Reset the sector buffer read/write pointers (bit mask)
NOBUF_MASK = 1  ; Reset the sector buffer read/write pointers (bit mask)
FDC_ALT_ADDR = $D081  ; Selects alternate DPLL read recovery method (not implemented) (address)
ALT_ADDR = $D081  ; Selects alternate DPLL read recovery method (not implemented) (address)
FDC_ALT_MASK = 2  ; Selects alternate DPLL read recovery method (not implemented) (bit mask)
ALT_MASK = 2  ; Selects alternate DPLL read recovery method (not implemented) (bit mask)
FDC_ALGO_ADDR = $D081  ; Selects reading and writing algorithm (currently ignored). (address)
ALGO_ADDR = $D081  ; Selects reading and writing algorithm (currently ignored). (address)
FDC_ALGO_MASK = 4  ; Selects reading and writing algorithm (currently ignored). (bit mask)
ALGO_MASK = 4  ; Selects reading and writing algorithm (currently ignored). (bit mask)
FDC_DIR_ADDR = $D081  ; Sets the stepping direction (inward vs (address)
DIR_ADDR = $D081  ; Sets the stepping direction (inward vs (address)
FDC_DIR_MASK = 8  ; Sets the stepping direction (inward vs (bit mask)
DIR_MASK = 8  ; Sets the stepping direction (inward vs (bit mask)
FDC_STEP_ADDR = $D081  ; Writing 1 causes the head to step in the indicated direction (address)
STEP_ADDR = $D081  ; Writing 1 causes the head to step in the indicated direction (address)
FDC_STEP_MASK = 16  ; Writing 1 causes the head to step in the indicated direction (bit mask)
STEP_MASK = 16  ; Writing 1 causes the head to step in the indicated direction (bit mask)
FDC_FREE_ADDR = $D081  ; Command is a free-format (low level) operation (address)
FREE_ADDR = $D081  ; Command is a free-format (low level) operation (address)
FDC_FREE_MASK = 32  ; Command is a free-format (low level) operation (bit mask)
FREE_MASK = 32  ; Command is a free-format (low level) operation (bit mask)
FDC_RDCMD_ADDR = $D081  ; Command is a read operation if set (address)
RDCMD_ADDR = $D081  ; Command is a read operation if set (address)
FDC_RDCMD_MASK = 64  ; Command is a read operation if set (bit mask)
RDCMD_MASK = 64  ; Command is a read operation if set (bit mask)
FDC_WRCMD_ADDR = $D081  ; Command is a write operation if set (address)
WRCMD_ADDR = $D081  ; Command is a write operation if set (address)
FDC_WRCMD_MASK = 128  ; Command is a write operation if set (bit mask)
WRCMD_MASK = 128  ; Command is a write operation if set (bit mask)
FDC_TK0_ADDR = $D082  ; F011 Head is over track 0 flag (read only) (address)
TK0_ADDR = $D082  ; F011 Head is over track 0 flag (read only) (address)
FDC_TK0_MASK = 1  ; F011 Head is over track 0 flag (read only) (bit mask)
TK0_MASK = 1  ; F011 Head is over track 0 flag (read only) (bit mask)
FDC_PROT_ADDR = $D082  ; F011 Disk write protect flag (read only) (address)
PROT_ADDR = $D082  ; F011 Disk write protect flag (read only) (address)
FDC_PROT_MASK = 2  ; F011 Disk write protect flag (read only) (bit mask)
PROT_MASK = 2  ; F011 Disk write protect flag (read only) (bit mask)
FDC_LOST_ADDR = $D082  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (address)
LOST_ADDR = $D082  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (address)
FDC_LOST_MASK = 4  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (bit mask)
LOST_MASK = 4  ; F011 LOST flag (data was lost during transfer, i.e., CPU did not read data fast enough) (read only) (bit mask)
FDC_CRC_ADDR = $D082  ; F011 FDC CRC check failure flag (read only) (address)
CRC_ADDR = $D082  ; F011 FDC CRC check failure flag (read only) (address)
FDC_CRC_MASK = 8  ; F011 FDC CRC check failure flag (read only) (bit mask)
CRC_MASK = 8  ; F011 FDC CRC check failure flag (read only) (bit mask)
FDC_RNF_ADDR = $D082  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (address)
RNF_ADDR = $D082  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (address)
FDC_RNF_MASK = 16  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (bit mask)
RNF_MASK = 16  ; F011 FDC Request Not Found (RNF), i.e., a sector read or write operation did not find the requested sector (read only) (bit mask)
FDC_EQ_ADDR = $D082  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (address)
EQ_ADDR = $D082  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (address)
FDC_EQ_MASK = 32  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (bit mask)
EQ_MASK = 32  ; F011 FDC CPU and disk pointers to sector buffer are equal, indicating that the sector buffer is either full or empty. (read only) (bit mask)
FDC_DRQ_ADDR = $D082  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (address)
DRQ_ADDR = $D082  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (address)
FDC_DRQ_MASK = 64  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (bit mask)
DRQ_MASK = 64  ; F011 FDC DRQ flag (one or more bytes of data are ready) (read only) (bit mask)
FDC_BUSY_ADDR = $D082  ; F011 FDC busy flag (command is being executed) (read only) (address)
BUSY_ADDR = $D082  ; F011 FDC busy flag (command is being executed) (read only) (address)
FDC_BUSY_MASK = 128  ; F011 FDC busy flag (command is being executed) (read only) (bit mask)
BUSY_MASK = 128  ; F011 FDC busy flag (command is being executed) (read only) (bit mask)
FDC_DSKCHG_ADDR = $D083  ; F011 disk change sense (read only) (address)
DSKCHG_ADDR = $D083  ; F011 disk change sense (read only) (address)
FDC_DSKCHG_MASK = 1  ; F011 disk change sense (read only) (bit mask)
DSKCHG_MASK = 1  ; F011 disk change sense (read only) (bit mask)
C65_FDC_IRQ_ADDR = $D083  ; The floppy controller has generated an interrupt (read only). Note that interrupts are not currently implemented on the 45GS27. (address)
C65_FDC_IRQ_MASK = 2  ; The floppy controller has generated an interrupt (read only). Note that interrupts are not currently implemented on the 45GS27. (bit mask)
FDC_INDEX_ADDR = $D083  ; F011 Index hole sense (read only) (address)
INDEX_ADDR = $D083  ; F011 Index hole sense (read only) (address)
FDC_INDEX_MASK = 4  ; F011 Index hole sense (read only) (bit mask)
INDEX_MASK = 4  ; F011 Index hole sense (read only) (bit mask)
FDC_DISKIN_ADDR = $D083  ; F011 Disk sense (read only) (address)
DISKIN_ADDR = $D083  ; F011 Disk sense (read only) (address)
FDC_DISKIN_MASK = 8  ; F011 Disk sense (read only) (bit mask)
DISKIN_MASK = 8  ; F011 Disk sense (read only) (bit mask)
FDC_WGATE_ADDR = $D083  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (address)
WGATE_ADDR = $D083  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (address)
FDC_WGATE_MASK = 16  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (bit mask)
WGATE_MASK = 16  ; F011 write gate flag. Indicates that the drive is currently writing to media. Bad things may happen if a write transaction is aborted (read only) (bit mask)
FDC_RUN_ADDR = $D083  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (address)
RUN_ADDR = $D083  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (address)
FDC_RUN_MASK = 32  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (bit mask)
RUN_MASK = 32  ; F011 Successive match. A synonym of RDREQ on the 45IO47 (read only) (bit mask)
FDC_WTREQ_ADDR = $D083  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (address)
WTREQ_ADDR = $D083  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (address)
FDC_WTREQ_MASK = 64  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (bit mask)
WTREQ_MASK = 64  ; F011 Write Request flag, i.e., the requested sector was found during a write operation (read only) (bit mask)
FDC_RDREQ_ADDR = $D083  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (address)
RDREQ_ADDR = $D083  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (address)
FDC_RDREQ_MASK = 128  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (bit mask)
RDREQ_MASK = 128  ; F011 Read Request flag, i.e., the requested sector was found during a read operation (read only) (bit mask)
FDC_TRACK = $D084  ; F011 FDC track selection register
TRACK = $D084  ; F011 FDC track selection register
FDC_SECTOR = $D085  ; F011 FDC sector selection register
SECTOR = $D085  ; F011 FDC sector selection register
FDC_SIDE = $D086  ; F011 FDC side selection register
SIDE = $D086  ; F011 FDC side selection register
FDC_DATA = $D087  ; F011 FDC data register (read/write) for accessing the floppy controller's 512 byte sector buffer
FDC_CLOCK = $D088  ; Set or read the clock pattern to be used when writing address and data marks. Should normally be left $FF
CLOCK = $D088  ; Set or read the clock pattern to be used when writing address and data marks. Should normally be left $FF
FDC_STEP = $D089  ; Set or read the track stepping rate in 62.5 microsecond steps (normally 128, i.e., 8 milliseconds).
STEP = $D089  ; Set or read the track stepping rate in 62.5 microsecond steps (normally 128, i.e., 8 milliseconds).
FDC_PCODE = $D08A  ; (Read only) returns the protection code of the most recently read sector. Was intended for rudimentary copy protection. Not implemented.
PCODE = $D08A  ; (Read only) returns the protection code of the most recently read sector. Was intended for rudimentary copy protection. Not implemented.
SUMMARY_REC = $D0A0  ; Reserved for C65 RAM Expansion Controller.
REC = $D0A0  ; Reserved for C65 RAM Expansion Controller.
VIC3_PALRED = $D100  ; red palette values (reversed nybl order)
PALRED = $D100  ; red palette values (reversed nybl order)
VIC3_PALGREEN = $D200  ; green palette values (reversed nybl order)
PALGREEN = $D200  ; green palette values (reversed nybl order)
VIC3_PALBLUE = $D300  ; blue palette values (reversed nybl order)
PALBLUE = $D300  ; blue palette values (reversed nybl order)
ETHCOMMAND_DEBUGVIC = $D4  ; Select VIC-IV debug stream via ethernet when \$D6E1.3 is set
DEBUGVIC = $D4  ; Select VIC-IV debug stream via ethernet when \$D6E1.3 is set
UART_DATA = $D600  ; UART data register (read or write)
UART_RXRDY_ADDR = $D601  ; UART RX byte ready flag (clear by reading \$D600) (address)
RXRDY_ADDR = $D601  ; UART RX byte ready flag (clear by reading \$D600) (address)
UART_RXRDY_MASK = 1  ; UART RX byte ready flag (clear by reading \$D600) (bit mask)
RXRDY_MASK = 1  ; UART RX byte ready flag (clear by reading \$D600) (bit mask)
UART_RXOVRRUN_ADDR = $D601  ; UART RX overrun flag (clear by reading \$D600) (address)
RXOVRRUN_ADDR = $D601  ; UART RX overrun flag (clear by reading \$D600) (address)
UART_RXOVRRUN_MASK = 2  ; UART RX overrun flag (clear by reading \$D600) (bit mask)
RXOVRRUN_MASK = 2  ; UART RX overrun flag (clear by reading \$D600) (bit mask)
UART_PTYERR_ADDR = $D601  ; UART RX parity error flag (clear by reading \$D600) (address)
PTYERR_ADDR = $D601  ; UART RX parity error flag (clear by reading \$D600) (address)
UART_PTYERR_MASK = 4  ; UART RX parity error flag (clear by reading \$D600) (bit mask)
PTYERR_MASK = 4  ; UART RX parity error flag (clear by reading \$D600) (bit mask)
UART_FRMERR_ADDR = $D601  ; UART RX framing error flag (clear by reading \$D600) (address)
FRMERR_ADDR = $D601  ; UART RX framing error flag (clear by reading \$D600) (address)
UART_FRMERR_MASK = 8  ; UART RX framing error flag (clear by reading \$D600) (bit mask)
FRMERR_MASK = 8  ; UART RX framing error flag (clear by reading \$D600) (bit mask)
UART_PTYEVEN_ADDR = $D602  ; UART Parity: 1=even, 0=odd (address)
PTYEVEN_ADDR = $D602  ; UART Parity: 1=even, 0=odd (address)
UART_PTYEVEN_MASK = 1  ; UART Parity: 1=even, 0=odd (bit mask)
PTYEVEN_MASK = 1  ; UART Parity: 1=even, 0=odd (bit mask)
UART_PTYEN_ADDR = $D602  ; UART Parity enable: 1=enabled (address)
PTYEN_ADDR = $D602  ; UART Parity enable: 1=enabled (address)
UART_PTYEN_MASK = 2  ; UART Parity enable: 1=enabled (bit mask)
PTYEN_MASK = 2  ; UART Parity enable: 1=enabled (bit mask)
UART_CHARSZ_ADDR = $D602  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (address)
CHARSZ_ADDR = $D602  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (address)
UART_CHARSZ_MASK = 12  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (bit mask)
CHARSZ_MASK = 12  ; UART character size: 00=8, 01=7, 10=6, 11=5 bits per byte (bit mask)
UART_SYNCMOD_ADDR = $D602  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (address)
SYNCMOD_ADDR = $D602  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (address)
UART_SYNCMOD_MASK = 48  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (bit mask)
SYNCMOD_MASK = 48  ; UART synchronisation mode flags (00=RX \& TX both async, 01=RX sync, TX async, 1x=TX sync, RX async (unused on the MEGA65) (bit mask)
UART_RXEN_ADDR = $D602  ; UART enable receive (address)
RXEN_ADDR = $D602  ; UART enable receive (address)
UART_RXEN_MASK = 64  ; UART enable receive (bit mask)
RXEN_MASK = 64  ; UART enable receive (bit mask)
UART_TXEN_ADDR = $D602  ; UART enable transmit (address)
TXEN_ADDR = $D602  ; UART enable transmit (address)
UART_TXEN_MASK = 128  ; UART enable transmit (bit mask)
TXEN_MASK = 128  ; UART enable transmit (bit mask)
UART_DIVISOR = $D603  ; UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
C65_UART_DIVISOR = $D604  ; UART baud rate divisor (16 bit). Baud rate = 7.09375MHz / DIVISOR, unless MEGA65 fast UART mode is enabled, in which case baud rate = 80MHz / DIVISOR
UART_IMRXNMI_ADDR = $D605  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (address)
IMRXNMI_ADDR = $D605  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (address)
UART_IMRXNMI_MASK = 16  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (bit mask)
IMRXNMI_MASK = 16  ; UART interrupt mask: NMI on RX (not yet implemented on the MEGA65) (bit mask)
UART_IMTXNMI_ADDR = $D605  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (address)
IMTXNMI_ADDR = $D605  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (address)
UART_IMTXNMI_MASK = 32  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (bit mask)
IMTXNMI_MASK = 32  ; UART interrupt mask: NMI on TX (not yet implemented on the MEGA65) (bit mask)
UART_IMRXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (address)
IMRXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (address)
UART_IMRXIRQ_MASK = 64  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
IMRXIRQ_MASK = 64  ; UART interrupt mask: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
UART_IMTXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (address)
IMTXIRQ_ADDR = $D605  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (address)
UART_IMTXIRQ_MASK = 128  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
IMTXIRQ_MASK = 128  ; UART interrupt mask: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
UART_IFRXNMI_ADDR = $D606  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (address)
IFRXNMI_ADDR = $D606  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (address)
UART_IFRXNMI_MASK = 16  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (bit mask)
IFRXNMI_MASK = 16  ; UART interrupt flag: NMI on RX (not yet implemented on the MEGA65) (bit mask)
UART_IFTXNMI_ADDR = $D606  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (address)
IFTXNMI_ADDR = $D606  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (address)
UART_IFTXNMI_MASK = 32  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (bit mask)
IFTXNMI_MASK = 32  ; UART interrupt flag: NMI on TX (not yet implemented on the MEGA65) (bit mask)
UART_IFRXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (address)
IFRXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (address)
UART_IFRXIRQ_MASK = 64  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
IFRXIRQ_MASK = 64  ; UART interrupt flag: IRQ on RX (not yet implemented on the MEGA65) (bit mask)
UART_IFTXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (address)
IFTXIRQ_ADDR = $D606  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (address)
UART_IFTXIRQ_MASK = 128  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
IFTXIRQ_MASK = 128  ; UART interrupt flag: IRQ on TX (not yet implemented on the MEGA65) (bit mask)
UART_CAPLOCK_ADDR = $D607  ; C65 capslock key sense (address)
CAPLOCK_ADDR = $D607  ; C65 capslock key sense (address)
UART_CAPLOCK_MASK = 1  ; C65 capslock key sense (bit mask)
CAPLOCK_MASK = 1  ; C65 capslock key sense (bit mask)
UART_KEYCOL8_ADDR = $D607  ; C65 keyboard column 8 select (address)
KEYCOL8_ADDR = $D607  ; C65 keyboard column 8 select (address)
UART_KEYCOL8_MASK = 2  ; C65 keyboard column 8 select (bit mask)
KEYCOL8_MASK = 2  ; C65 keyboard column 8 select (bit mask)
UART_PORTEDDR_ADDR = $D608  ; C65 keyboard extra lines Data Direction Register (DDR) (address)
PORTEDDR_ADDR = $D608  ; C65 keyboard extra lines Data Direction Register (DDR) (address)
UART_PORTEDDR_MASK = 3  ; C65 keyboard extra lines Data Direction Register (DDR) (bit mask)
PORTEDDR_MASK = 3  ; C65 keyboard extra lines Data Direction Register (DDR) (bit mask)
UARTMISC_UFAST_ADDR = $D609  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (address)
UFAST_ADDR = $D609  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (address)
UARTMISC_UFAST_MASK = 1  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (bit mask)
UFAST_MASK = 1  ; C65 UART BAUD clock source: 1 = 7.09375MHz, 0 = 80MHz (VIC-IV pixel clock) (bit mask)
UARTMISC_PORTF_ADDR = $D60B  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (address)
PORTF_ADDR = $D60B  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (address)
UARTMISC_PORTF_MASK = 63  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (bit mask)
PORTF_MASK = 63  ; PMOD port A on FPGA board (data) (Nexys4 boards only) (bit mask)
UARTMISC_OSKZON_ADDR = $D60B  ; Display hardware zoom of region under first touch point always (address)
OSKZON_ADDR = $D60B  ; Display hardware zoom of region under first touch point always (address)
UARTMISC_OSKZON_MASK = 64  ; Display hardware zoom of region under first touch point always (bit mask)
OSKZON_MASK = 64  ; Display hardware zoom of region under first touch point always (bit mask)
UARTMISC_OSKZEN_ADDR = $D60B  ; Display hardware zoom of region under first touch point for on-screen keyboard (address)
OSKZEN_ADDR = $D60B  ; Display hardware zoom of region under first touch point for on-screen keyboard (address)
UARTMISC_OSKZEN_MASK = 128  ; Display hardware zoom of region under first touch point for on-screen keyboard (bit mask)
OSKZEN_MASK = 128  ; Display hardware zoom of region under first touch point for on-screen keyboard (bit mask)
UARTMISC_PORTFDDR_ADDR = $D60C  ; PMOD port A on FPGA board (DDR) (address)
UARTMISC_PORTFDDR_MASK = 63  ; PMOD port A on FPGA board (DDR) (bit mask)
GS_UARTMISC_PORTFDDR_ADDR = $D60C  ; On Screen Keyboard (OSK) Zoom Control Data Direction Register (DDR). Must be set to output to control these features. (address)
GS_UARTMISC_PORTFDDR_MASK = 192  ; On Screen Keyboard (OSK) Zoom Control Data Direction Register (DDR). Must be set to output to control these features. (bit mask)
UARTMISC_CONN41_ADDR = $D60D  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (address)
CONN41_ADDR = $D60D  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (address)
UARTMISC_CONN41_MASK = 1  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (bit mask)
CONN41_MASK = 1  ; Internal 1541 drive connect (1=connect internal 1541 drive to IEC bus) (bit mask)
UARTMISC_RST41_ADDR = $D60D  ; Internal 1541 drive reset (1=reset, 0=operate) (address)
RST41_ADDR = $D60D  ; Internal 1541 drive reset (1=reset, 0=operate) (address)
UARTMISC_RST41_MASK = 2  ; Internal 1541 drive reset (1=reset, 0=operate) (bit mask)
RST41_MASK = 2  ; Internal 1541 drive reset (1=reset, 0=operate) (bit mask)
UARTMISC_SDDATA_ADDR = $D60D  ; SD card MOSI/MISO (address)
SDDATA_ADDR = $D60D  ; SD card MOSI/MISO (address)
UARTMISC_SDDATA_MASK = 4  ; SD card MOSI/MISO (bit mask)
SDDATA_MASK = 4  ; SD card MOSI/MISO (bit mask)
UARTMISC_SDCLK_ADDR = $D60D  ; SD card SCLK (address)
SDCLK_ADDR = $D60D  ; SD card SCLK (address)
UARTMISC_SDCLK_MASK = 8  ; SD card SCLK (bit mask)
SDCLK_MASK = 8  ; SD card SCLK (bit mask)
UARTMISC_SDCS_ADDR = $D60D  ; SD card CS_BO (address)
SDCS_ADDR = $D60D  ; SD card CS_BO (address)
UARTMISC_SDCS_MASK = 16  ; SD card CS_BO (bit mask)
SDCS_MASK = 16  ; SD card CS_BO (bit mask)
UARTMISC_SDBSH_ADDR = $D60D  ; Enable SD card bitbash mode (address)
SDBSH_ADDR = $D60D  ; Enable SD card bitbash mode (address)
UARTMISC_SDBSH_MASK = 32  ; Enable SD card bitbash mode (bit mask)
SDBSH_MASK = 32  ; Enable SD card bitbash mode (bit mask)
UARTMISC_HDSDA_ADDR = $D60D  ; HDMI I2C control interface SDA data line (address)
HDSDA_ADDR = $D60D  ; HDMI I2C control interface SDA data line (address)
UARTMISC_HDSDA_MASK = 64  ; HDMI I2C control interface SDA data line (bit mask)
HDSDA_MASK = 64  ; HDMI I2C control interface SDA data line (bit mask)
UARTMISC_HDSCL_ADDR = $D60D  ; HDMI I2C control interface SCL clock (address)
HDSCL_ADDR = $D60D  ; HDMI I2C control interface SCL clock (address)
UARTMISC_HDSCL_MASK = 128  ; HDMI I2C control interface SCL clock (bit mask)
HDSCL_MASK = 128  ; HDMI I2C control interface SCL clock (bit mask)
UARTMISC_BASHDDR = $D60E  ; Data Direction Register (DDR) for \$D60D bit bashing port.
BASHDDR = $D60E  ; Data Direction Register (DDR) for \$D60D bit bashing port.
UARTMISC_KEYLEFT_ADDR = $D60F  ; Directly read C65 Cursor left key (address)
KEYLEFT_ADDR = $D60F  ; Directly read C65 Cursor left key (address)
UARTMISC_KEYLEFT_MASK = 1  ; Directly read C65 Cursor left key (bit mask)
KEYLEFT_MASK = 1  ; Directly read C65 Cursor left key (bit mask)
UARTMISC_KEYUP_ADDR = $D60F  ; Directly read C65 Cursor up key (address)
KEYUP_ADDR = $D60F  ; Directly read C65 Cursor up key (address)
UARTMISC_KEYUP_MASK = 2  ; Directly read C65 Cursor up key (bit mask)
KEYUP_MASK = 2  ; Directly read C65 Cursor up key (bit mask)
UARTMISC_REALHW_ADDR = $D60F  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (address)
REALHW_ADDR = $D60F  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (address)
UARTMISC_REALHW_MASK = 32  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (bit mask)
REALHW_MASK = 32  ; Set to 1 if the MEGA65 is running on real hardware, set to 0 if emulated (Xemu) or simulated (ghdl) (bit mask)
UARTMISC_OSKDIM_ADDR = $D60F  ; Light or heavy dimming of background material behind on-screen keyboard (address)
OSKDIM_ADDR = $D60F  ; Light or heavy dimming of background material behind on-screen keyboard (address)
UARTMISC_OSKDIM_MASK = 64  ; Light or heavy dimming of background material behind on-screen keyboard (bit mask)
OSKDIM_MASK = 64  ; Light or heavy dimming of background material behind on-screen keyboard (bit mask)
UARTMISC_ACCESSKEY_ADDR = $D60F  ; Enable accessible keyboard input via joystick port 2 fire button (address)
ACCESSKEY_ADDR = $D60F  ; Enable accessible keyboard input via joystick port 2 fire button (address)
UARTMISC_ACCESSKEY_MASK = 128  ; Enable accessible keyboard input via joystick port 2 fire button (bit mask)
ACCESSKEY_MASK = 128  ; Enable accessible keyboard input via joystick port 2 fire button (bit mask)
UARTMISC_ASCIIKEY = $D610  ; Last key press as ASCII (hardware accelerated keyboard scanner). Write to clear event ready for next.
ASCIIKEY = $D610  ; Last key press as ASCII (hardware accelerated keyboard scanner). Write to clear event ready for next.
UARTMISC_MRSHFT_ADDR = $D611  ; Right shift key state (hardware accelerated keyboard scanner). (address)
MRSHFT_ADDR = $D611  ; Right shift key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MRSHFT_MASK = 1  ; Right shift key state (hardware accelerated keyboard scanner). (bit mask)
MRSHFT_MASK = 1  ; Right shift key state (hardware accelerated keyboard scanner). (bit mask)
UARTMISC_MLSHFT_ADDR = $D611  ; Left shift key state (hardware accelerated keyboard scanner). (address)
MLSHFT_ADDR = $D611  ; Left shift key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MLSHFT_MASK = 2  ; Left shift key state (hardware accelerated keyboard scanner). (bit mask)
MLSHFT_MASK = 2  ; Left shift key state (hardware accelerated keyboard scanner). (bit mask)
UARTMISC_MCTRL_ADDR = $D611  ; CTRL key state (hardware accelerated keyboard scanner). (address)
MCTRL_ADDR = $D611  ; CTRL key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MCTRL_MASK = 4  ; CTRL key state (hardware accelerated keyboard scanner). (bit mask)
MCTRL_MASK = 4  ; CTRL key state (hardware accelerated keyboard scanner). (bit mask)
UARTMISC_MMEGA_ADDR = $D611  ; MEGA/C= key state (hardware accelerated keyboard scanner). (address)
MMEGA_ADDR = $D611  ; MEGA/C= key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MMEGA_MASK = 8  ; MEGA/C= key state (hardware accelerated keyboard scanner). (bit mask)
MMEGA_MASK = 8  ; MEGA/C= key state (hardware accelerated keyboard scanner). (bit mask)
UARTMISC_MALT_ADDR = $D611  ; ALT key state (hardware accelerated keyboard scanner). (address)
MALT_ADDR = $D611  ; ALT key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MALT_MASK = 16  ; ALT key state (hardware accelerated keyboard scanner). (bit mask)
MALT_MASK = 16  ; ALT key state (hardware accelerated keyboard scanner). (bit mask)
UARTMISC_MSCRL_ADDR = $D611  ; NOSCRL key state (hardware accelerated keyboard scanner). (address)
MSCRL_ADDR = $D611  ; NOSCRL key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MSCRL_MASK = 32  ; NOSCRL key state (hardware accelerated keyboard scanner). (bit mask)
MSCRL_MASK = 32  ; NOSCRL key state (hardware accelerated keyboard scanner). (bit mask)
UARTMISC_MCAPS_ADDR = $D611  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (address)
MCAPS_ADDR = $D611  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (address)
UARTMISC_MCAPS_MASK = 64  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (bit mask)
MCAPS_MASK = 64  ; CAPS LOCK key state (hardware accelerated keyboard scanner). (bit mask)
UARTMISC_WGTKEY_ADDR = $D612  ; Enable widget board keyboard/joystick input (address)
WGTKEY_ADDR = $D612  ; Enable widget board keyboard/joystick input (address)
UARTMISC_WGTKEY_MASK = 1  ; Enable widget board keyboard/joystick input (bit mask)
WGTKEY_MASK = 1  ; Enable widget board keyboard/joystick input (bit mask)
UARTMISC_PS2KEY_ADDR = $D612  ; Enable ps2 keyboard/joystick input (address)
PS2KEY_ADDR = $D612  ; Enable ps2 keyboard/joystick input (address)
UARTMISC_PS2KEY_MASK = 2  ; Enable ps2 keyboard/joystick input (bit mask)
PS2KEY_MASK = 2  ; Enable ps2 keyboard/joystick input (bit mask)
UARTMISC_PHYKEY_ADDR = $D612  ; Enable physical keyboard input (address)
PHYKEY_ADDR = $D612  ; Enable physical keyboard input (address)
UARTMISC_PHYKEY_MASK = 4  ; Enable physical keyboard input (bit mask)
PHYKEY_MASK = 4  ; Enable physical keyboard input (bit mask)
UARTMISC_VRTKEY_ADDR = $D612  ; Enable virtual/snythetic keyboard input (address)
VRTKEY_ADDR = $D612  ; Enable virtual/snythetic keyboard input (address)
UARTMISC_VRTKEY_MASK = 8  ; Enable virtual/snythetic keyboard input (bit mask)
VRTKEY_MASK = 8  ; Enable virtual/snythetic keyboard input (bit mask)
UARTMISC_OSKDEBUG_ADDR = $D612  ; Debug OSK overlay (WRITE ONLY) (address)
OSKDEBUG_ADDR = $D612  ; Debug OSK overlay (WRITE ONLY) (address)
UARTMISC_OSKDEBUG_MASK = 16  ; Debug OSK overlay (WRITE ONLY) (bit mask)
OSKDEBUG_MASK = 16  ; Debug OSK overlay (WRITE ONLY) (bit mask)
UARTMISC_PS2JOY_ADDR = $D612  ; Enable PS/2 / USB keyboard simulated joystick input (address)
PS2JOY_ADDR = $D612  ; Enable PS/2 / USB keyboard simulated joystick input (address)
UARTMISC_PS2JOY_MASK = 16  ; Enable PS/2 / USB keyboard simulated joystick input (bit mask)
PS2JOY_MASK = 16  ; Enable PS/2 / USB keyboard simulated joystick input (bit mask)
UARTMISC_JOYSWAP_ADDR = $D612  ; Exchange joystick ports 1 \& 2 (address)
JOYSWAP_ADDR = $D612  ; Exchange joystick ports 1 \& 2 (address)
UARTMISC_JOYSWAP_MASK = 32  ; Exchange joystick ports 1 \& 2 (bit mask)
JOYSWAP_MASK = 32  ; Exchange joystick ports 1 \& 2 (bit mask)
UARTMISC_LJOYA_ADDR = $D612  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (address)
LJOYA_ADDR = $D612  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (address)
UARTMISC_LJOYA_MASK = 64  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (bit mask)
LJOYA_MASK = 64  ; Rotate inputs of joystick A by 180 degrees (for left handed use) (bit mask)
UARTMISC_LJOYB_ADDR = $D612  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (address)
LJOYB_ADDR = $D612  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (address)
UARTMISC_LJOYB_MASK = 128  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (bit mask)
LJOYB_MASK = 128  ; Rotate inputs of joystick B by 180 degrees (for left handed use) (bit mask)
DEBUG_CRTACSCNT = $D613  ; Count of cartridge port memory accesses (read only)
CRTACSCNT = $D613  ; Count of cartridge port memory accesses (read only)
DEBUG_KEYMATRIXPEEK = $D614  ; 8-bit segment of combined keyboard matrix (READ)
KEYMATRIXPEEK = $D614  ; 8-bit segment of combined keyboard matrix (READ)
UARTMISC_VIRTKEY1_ADDR = $D615  ; Set to \$7F for no key down, else specify virtual key press. (address)
VIRTKEY1_ADDR = $D615  ; Set to \$7F for no key down, else specify virtual key press. (address)
UARTMISC_VIRTKEY1_MASK = 127  ; Set to \$7F for no key down, else specify virtual key press. (bit mask)
VIRTKEY1_MASK = 127  ; Set to \$7F for no key down, else specify virtual key press. (bit mask)
UARTMISC_OSKEN_ADDR = $D615  ; Enable display of on-screen keyboard composited overlay (address)
OSKEN_ADDR = $D615  ; Enable display of on-screen keyboard composited overlay (address)
UARTMISC_OSKEN_MASK = 128  ; Enable display of on-screen keyboard composited overlay (bit mask)
OSKEN_MASK = 128  ; Enable display of on-screen keyboard composited overlay (bit mask)
UARTMISC_VIRTKEY2_ADDR = $D616  ; Set to \$7F for no key down, else specify 2nd virtual key press. (address)
VIRTKEY2_ADDR = $D616  ; Set to \$7F for no key down, else specify 2nd virtual key press. (address)
UARTMISC_VIRTKEY2_MASK = 127  ; Set to \$7F for no key down, else specify 2nd virtual key press. (bit mask)
VIRTKEY2_MASK = 127  ; Set to \$7F for no key down, else specify 2nd virtual key press. (bit mask)
UARTMISC_OSKALT_ADDR = $D616  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (address)
OSKALT_ADDR = $D616  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (address)
UARTMISC_OSKALT_MASK = 128  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (bit mask)
OSKALT_MASK = 128  ; Display alternate on-screen keyboard layout (typically dial pad for MEGA65 telephone) (bit mask)
UARTMISC_VIRTKEY3_ADDR = $D617  ; Set to \$7F for no key down, else specify 3nd virtual key press. (address)
VIRTKEY3_ADDR = $D617  ; Set to \$7F for no key down, else specify 3nd virtual key press. (address)
UARTMISC_VIRTKEY3_MASK = 127  ; Set to \$7F for no key down, else specify 3nd virtual key press. (bit mask)
VIRTKEY3_MASK = 127  ; Set to \$7F for no key down, else specify 3nd virtual key press. (bit mask)
UARTMISC_OSKTOP_ADDR = $D617  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (address)
OSKTOP_ADDR = $D617  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (address)
UARTMISC_OSKTOP_MASK = 128  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (bit mask)
OSKTOP_MASK = 128  ; 1=Display on-screen keyboard at top, 0=Disply on-screen keyboard at bottom of screen. (bit mask)
UARTMISC_KSCNRATE = $D618  ; Physical keyboard scan rate (\$00=50MHz, \$FF=~200KHz)
KSCNRATE = $D618  ; Physical keyboard scan rate (\$00=50MHz, \$FF=~200KHz)
UARTMISC_UNUSED = $D619  ; port o output value
UNUSED = $D619  ; port o output value
UARTMISC_SYSCTL = $D61A  ; System control flags (target specific)
SYSCTL = $D61A  ; System control flags (target specific)
SYSCTL_AUDMUTE_ADDR = $D61A  ; Mute digital video audio (MEGA65 R2 only) (address)
AUDMUTE_ADDR = $D61A  ; Mute digital video audio (MEGA65 R2 only) (address)
SYSCTL_AUDMUTE_MASK = 1  ; Mute digital video audio (MEGA65 R2 only) (bit mask)
AUDMUTE_MASK = 1  ; Mute digital video audio (MEGA65 R2 only) (bit mask)
SYSCTL_DVI_ADDR = $D61A  ; Control digital video as DVI (disables audio) (address)
DVI_ADDR = $D61A  ; Control digital video as DVI (disables audio) (address)
SYSCTL_DVI_MASK = 2  ; Control digital video as DVI (disables audio) (bit mask)
DVI_MASK = 2  ; Control digital video as DVI (disables audio) (bit mask)
SYSCTL_AUDDBG_ADDR = $D61A  ; Visualise audio samples (DEBUG) (address)
AUDDBG_ADDR = $D61A  ; Visualise audio samples (DEBUG) (address)
SYSCTL_AUDDBG_MASK = 4  ; Visualise audio samples (DEBUG) (bit mask)
AUDDBG_MASK = 4  ; Visualise audio samples (DEBUG) (bit mask)
SYSCTL_AUD48K_ADDR = $D61A  ; Select 48KHz or 44.1KHz digital video audio sample rate (address)
AUD48K_ADDR = $D61A  ; Select 48KHz or 44.1KHz digital video audio sample rate (address)
SYSCTL_AUD48K_MASK = 8  ; Select 48KHz or 44.1KHz digital video audio sample rate (bit mask)
AUD48K_MASK = 8  ; Select 48KHz or 44.1KHz digital video audio sample rate (bit mask)
SYSCTL_LED_ADDR = $D61A  ; Control LED next to U1 on mother board (address)
SYSCTL_LED_MASK = 16  ; Control LED next to U1 on mother board (bit mask)
SYSCTL_AUDINV_ADDR = $D61A  ; Invert digital video audio sample values (address)
AUDINV_ADDR = $D61A  ; Invert digital video audio sample values (address)
SYSCTL_AUDINV_MASK = 128  ; Invert digital video audio sample values (bit mask)
AUDINV_MASK = 128  ; Invert digital video audio sample values (bit mask)
DEBUG_AMIMOUSDETECT = $D61B  ; READ 1351/amiga mouse auto detection DEBUG
AMIMOUSDETECT = $D61B  ; READ 1351/amiga mouse auto detection DEBUG
DEBUG__1541PCLSB = $D61C  ; internal 1541 PC LSB
_1541PCLSB = $D61C  ; internal 1541 PC LSB
UARTMISC_Keyboard_ADDR = $D61D  ; LED register select (R,G,B channels x 4 = 0 to 11) (address)
UARTMISC_Keyboard_MASK = 127  ; LED register select (R,G,B channels x 4 = 0 to 11) (bit mask)
GS_UARTMISC_Keyboard_ADDR = $D61D  ; LED control enable (address)
GS_UARTMISC_Keyboard_MASK = 128  ; LED control enable (bit mask)
UARTMISC_Keyboard = $D61E  ; register value (write only)
Keyboard = $D61E  ; register value (write only)
DEBUG_BUCKYCOPY = $D61F  ; DUPLICATE Modifier key state (hardware accelerated keyboard scanner).
BUCKYCOPY = $D61F  ; DUPLICATE Modifier key state (hardware accelerated keyboard scanner).
UARTMISC_POTAX = $D620  ; Read Port A paddle X, without having to fiddle with SID/CIA settings.
POTAX = $D620  ; Read Port A paddle X, without having to fiddle with SID/CIA settings.
UARTMISC_POTAY = $D621  ; Read Port A paddle Y, without having to fiddle with SID/CIA settings.
POTAY = $D621  ; Read Port A paddle Y, without having to fiddle with SID/CIA settings.
UARTMISC_POTBX = $D622  ; Read Port B paddle X, without having to fiddle with SID/CIA settings.
POTBX = $D622  ; Read Port B paddle X, without having to fiddle with SID/CIA settings.
UARTMISC_POTBY = $D623  ; Read Port B paddle Y, without having to fiddle with SID/CIA settings.
POTBY = $D623  ; Read Port B paddle Y, without having to fiddle with SID/CIA settings.
DEBUG_POTDEBUG = $D624  ; READ ONLY flags for paddles. See c65uart.vhdl for more information.
POTDEBUG = $D624  ; READ ONLY flags for paddles. See c65uart.vhdl for more information.
UARTMISC_J21L = $D625  ; J21 pins 1 -- 6, 9 -- 10 input/output values
J21L = $D625  ; J21 pins 1 -- 6, 9 -- 10 input/output values
UARTMISC_J21H = $D626  ; J21 pins 11 -- 14 input/output values
J21H = $D626  ; J21 pins 11 -- 14 input/output values
UARTMISC_J21LDDR = $D627  ; J21 pins 1 -- 6, 9 -- 10 data direction register
J21LDDR = $D627  ; J21 pins 1 -- 6, 9 -- 10 data direction register
UARTMISC_J21HDDR = $D628  ; J21 pins 11 -- 14 data direction register
J21HDDR = $D628  ; J21 pins 11 -- 14 data direction register
UARTMISC_M65MODEL = $D629  ; MEGA65 model ID. Can be used to determine the model of MEGA65 a programme is running on, e.g., to enable touch controls on MEGAphone.
M65MODEL = $D629  ; MEGA65 model ID. Can be used to determine the model of MEGA65 a programme is running on, e.g., to enable touch controls on MEGAphone.
KBD_FWDATEL = $D62A  ; LSB of keyboard firmware date stamp (days since 1 Jan 2020)
KBD_FWDATEH = $D62B  ; MSB of keyboard firmware date stamp (days since 1 Jan 2020)
KBD_FWGIT0 = $D62C  ; LSB of keyboard firmware git commit
GS_KBD_FWGIT0 = $D62D  ; 2nd byte of keyboard firmware git commit
GS_KBD_FWGIT0_2 = $D62E  ; 3rd byte of keyboard firmware git commit
GS_KBD_FWGIT0_3 = $D62F  ; MSB of keyboard firmware git commit
FPGA_FWDATEL = $D630  ; LSB of MEGA65 FPGA design date stamp (days since 1 Jan 2020)
FPGA_FWDATEH = $D631  ; MSB of MEGA65 FPGA design date stamp (days since 1 Jan 2020)
FPGA_FWGIT0 = $D632  ; LSB of MEGA65 FPGA design git commit
GS_FPGA_FWGIT0 = $D633  ; 2nd byte of MEGA65 FPGA design git commit
GS_FPGA_FWGIT0_2 = $D634  ; 3rd byte of MEGA65 FPGA design git commit
GS_FPGA_FWGIT0_3 = $D635  ; MSB of MEGA65 FPGA design git commit
AUXFPGA_FWDATEL = $D636  ; LSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
AUXFPGA_MFWDATEH = $D637  ; MSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
MFWDATEH = $D637  ; MSB of Auxilliary (MAX10) FPGA design date stamp (days since 1 Jan 2020)
AUXFPGA_FWGIT0 = $D638  ; LSB of Auxilliary (MAX10) FPGA design git commit
GS_AUXFPGA_FWGIT0 = $D639  ; 2nd byte of Auxilliary (MAX10) FPGA design git commit
GS_AUXFPGA_FWGIT0_2 = $D63A  ; 3rd byte of Auxilliary (MAX10) FPGA design git commit
GS_AUXFPGA_FWGIT0_3 = $D63B  ; MSB of Auxilliary (MAX10) FPGA design git commit
SID_SIDMODE_ADDR = $D63C  ; Select SID mode: 0=6581, 1=8580 (address)
SIDMODE_ADDR = $D63C  ; Select SID mode: 0=6581, 1=8580 (address)
SID_SIDMODE_MASK = 15  ; Select SID mode: 0=6581, 1=8580 (bit mask)
SIDMODE_MASK = 15  ; Select SID mode: 0=6581, 1=8580 (bit mask)
AUDIOMIX_DCTRKEN_ADDR = $D63C  ; Enable DC offset subtraction in audio mixer (address)
DCTRKEN_ADDR = $D63C  ; Enable DC offset subtraction in audio mixer (address)
AUDIOMIX_DCTRKEN_MASK = 16  ; Enable DC offset subtraction in audio mixer (bit mask)
DCTRKEN_MASK = 16  ; Enable DC offset subtraction in audio mixer (bit mask)
DEBUG_RESETSRC_ADDR = $D63C  ; Source of last CPU reset (address)
RESETSRC_ADDR = $D63C  ; Source of last CPU reset (address)
DEBUG_RESETSRC_MASK = 224  ; Source of last CPU reset (bit mask)
RESETSRC_MASK = 224  ; Source of last CPU reset (bit mask)
AUDIOMIX_DCTIME = $D63D  ; Audio mixer DC-estimation time step. Lower values = faster updating of DC estimation, at the cost of making low-frequencies quieter.
DCTIME = $D63D  ; Audio mixer DC-estimation time step. Lower values = faster updating of DC estimation, at the cost of making low-frequencies quieter.
CPU_HTRAP00 = $D640  ; Writing triggers hypervisor trap \$XX
HTRAP00 = $D640  ; Writing triggers hypervisor trap \$XX
HCPU_REGA = $D640  ; Hypervisor A register storage
REGA = $D640  ; Hypervisor A register storage
CPU_HTRAP01 = $D641  ; @HTRAPXX
HTRAP01 = $D641  ; @HTRAPXX
HCPU_REGX = $D641  ; Hypervisor X register storage
REGX = $D641  ; Hypervisor X register storage
CPU_HTRAP02 = $D642  ; @HTRAPXX
HTRAP02 = $D642  ; @HTRAPXX
CPU_HTRAP03 = $D643  ; @HTRAPXX
HTRAP03 = $D643  ; @HTRAPXX
HCPU_REGZ = $D643  ; Hypervisor Z register storage
REGZ = $D643  ; Hypervisor Z register storage
CPU_HTRAP04 = $D644  ; @HTRAPXX
HTRAP04 = $D644  ; @HTRAPXX
HCPU_REGB = $D644  ; Hypervisor B register storage
REGB = $D644  ; Hypervisor B register storage
CPU_HTRAP05 = $D645  ; @HTRAPXX
HTRAP05 = $D645  ; @HTRAPXX
HCPU_SPL = $D645  ; Hypervisor SPL register storage
SPL = $D645  ; Hypervisor SPL register storage
CPU_HTRAP06 = $D646  ; @HTRAPXX
HTRAP06 = $D646  ; @HTRAPXX
HCPU_SPH = $D646  ; Hypervisor SPH register storage
SPH = $D646  ; Hypervisor SPH register storage
CPU_HTRAP07 = $D647  ; @HTRAPXX
HTRAP07 = $D647  ; @HTRAPXX
HCPU_PFLAGS = $D647  ; Hypervisor P register storage
PFLAGS = $D647  ; Hypervisor P register storage
CPU_HTRAP08 = $D648  ; @HTRAPXX
HTRAP08 = $D648  ; @HTRAPXX
HCPU_PCL = $D648  ; Hypervisor PC-low register storage
PCL = $D648  ; Hypervisor PC-low register storage
CPU_HTRAP09 = $D649  ; @HTRAPXX
HTRAP09 = $D649  ; @HTRAPXX
HCPU_PCH = $D649  ; Hypervisor PC-high register storage
PCH = $D649  ; Hypervisor PC-high register storage
CPU_HTRAP0A = $D64A  ; @HTRAPXX
HTRAP0A = $D64A  ; @HTRAPXX
HCPU_MAPLO = $D64A  ; Hypervisor MAPLO register storage (high bits)
CPU_HTRAP0B = $D64B  ; @HTRAPXX
HTRAP0B = $D64B  ; @HTRAPXX
GS_HCPU_MAPLO = $D64B  ; Hypervisor MAPLO register storage (low bits)
CPU_HTRAP0C = $D64C  ; @HTRAPXX
HTRAP0C = $D64C  ; @HTRAPXX
HCPU_MAPHI = $D64C  ; Hypervisor MAPHI register storage (high bits)
CPU_HTRAP0D = $D64D  ; @HTRAPXX
HTRAP0D = $D64D  ; @HTRAPXX
GS_HCPU_MAPHI = $D64D  ; Hypervisor MAPHI register storage (low bits)
CPU_HTRAP0E = $D64E  ; @HTRAPXX
HTRAP0E = $D64E  ; @HTRAPXX
HCPU_MAPLOMB = $D64E  ; Hypervisor MAPLO mega-byte number register storage
MAPLOMB = $D64E  ; Hypervisor MAPLO mega-byte number register storage
CPU_HTRAP0F = $D64F  ; @HTRAPXX
HTRAP0F = $D64F  ; @HTRAPXX
HCPU_MAPHIMB = $D64F  ; Hypervisor MAPHI mega-byte number register storage
MAPHIMB = $D64F  ; Hypervisor MAPHI mega-byte number register storage
CPU_HTRAP10 = $D650  ; @HTRAPXX
HTRAP10 = $D650  ; @HTRAPXX
HCPU_PORT00 = $D650  ; Hypervisor CPU port \$00 value
PORT00 = $D650  ; Hypervisor CPU port \$00 value
CPU_HTRAP11 = $D651  ; @HTRAPXX
HTRAP11 = $D651  ; @HTRAPXX
HCPU_PORT01 = $D651  ; Hypervisor CPU port \$01 value
PORT01 = $D651  ; Hypervisor CPU port \$01 value
CPU_HTRAP12 = $D652  ; @HTRAPXX
HTRAP12 = $D652  ; @HTRAPXX
HCPU_VICMODE_ADDR = $D652  ; VIC-II/VIC-III/VIC-IV mode select (address)
VICMODE_ADDR = $D652  ; VIC-II/VIC-III/VIC-IV mode select (address)
HCPU_VICMODE_MASK = 3  ; VIC-II/VIC-III/VIC-IV mode select (bit mask)
VICMODE_MASK = 3  ; VIC-II/VIC-III/VIC-IV mode select (bit mask)
HCPU_EXSID_ADDR = $D652  ; 0=Use internal SIDs, 1=Use external(1) SIDs (address)
EXSID_ADDR = $D652  ; 0=Use internal SIDs, 1=Use external(1) SIDs (address)
HCPU_EXSID_MASK = 4  ; 0=Use internal SIDs, 1=Use external(1) SIDs (bit mask)
EXSID_MASK = 4  ; 0=Use internal SIDs, 1=Use external(1) SIDs (bit mask)
CPU_HTRAP13 = $D653  ; @HTRAPXX
HTRAP13 = $D653  ; @HTRAPXX
HCPU_DMASRCMB = $D653  ; Hypervisor DMAgic source MB
DMASRCMB = $D653  ; Hypervisor DMAgic source MB
CPU_HTRAP14 = $D654  ; @HTRAPXX
HTRAP14 = $D654  ; @HTRAPXX
HCPU_DMADSTMB = $D654  ; Hypervisor DMAgic destination MB
DMADSTMB = $D654  ; Hypervisor DMAgic destination MB
CPU_HTRAP15 = $D655  ; @HTRAPXX
HTRAP15 = $D655  ; @HTRAPXX
HCPU_DMALADDR = $D655  ; Hypervisor DMAGic list address bits 0-7
CPU_HTRAP16 = $D656  ; @HTRAPXX
HTRAP16 = $D656  ; @HTRAPXX
GS_HCPU_DMALADDR = $D656  ; Hypervisor DMAGic list address bits 15-8
CPU_HTRAP17 = $D657  ; @HTRAPXX
HTRAP17 = $D657  ; @HTRAPXX
GS_HCPU_DMALADDR_2 = $D657  ; Hypervisor DMAGic list address bits 23-16
CPU_HTRAP18 = $D658  ; @HTRAPXX
HTRAP18 = $D658  ; @HTRAPXX
GS_HCPU_DMALADDR_3 = $D658  ; Hypervisor DMAGic list address bits 27-24
CPU_HTRAP19 = $D659  ; @HTRAPXX
HTRAP19 = $D659  ; @HTRAPXX
HCPU_VFLOP_ADDR = $D659  ; 1=Virtualise SD/Floppy0 access (usually for access via serial debugger interface) (address)
HCPU_VFLOP_MASK = 1  ; 1=Virtualise SD/Floppy0 access (usually for access via serial debugger interface) (bit mask)
GS_HCPU_VFLOP_ADDR = $D659  ; 1=Virtualise SD/Floppy1 access (usually for access via serial debugger interface) (address)
GS_HCPU_VFLOP_MASK = 2  ; 1=Virtualise SD/Floppy1 access (usually for access via serial debugger interface) (bit mask)
CPU_HTRAP1A = $D65A  ; @HTRAPXX
HTRAP1A = $D65A  ; @HTRAPXX
CPU_HTRAP1B = $D65B  ; @HTRAPXX
HTRAP1B = $D65B  ; @HTRAPXX
CPU_HTRAP1C = $D65C  ; @HTRAPXX
HTRAP1C = $D65C  ; @HTRAPXX
CPU_HTRAP1D = $D65D  ; @HTRAPXX
HTRAP1D = $D65D  ; @HTRAPXX
CPU_HTRAP1E = $D65E  ; @HTRAPXX
HTRAP1E = $D65E  ; @HTRAPXX
CPU_HTRAP1F = $D65F  ; @HTRAPXX
HTRAP1F = $D65F  ; @HTRAPXX
CPU_HTRAP20 = $D660  ; @HTRAPXX
HTRAP20 = $D660  ; @HTRAPXX
CPU_HTRAP21 = $D661  ; @HTRAPXX
HTRAP21 = $D661  ; @HTRAPXX
CPU_HTRAP22 = $D662  ; @HTRAPXX
HTRAP22 = $D662  ; @HTRAPXX
CPU_HTRAP23 = $D663  ; @HTRAPXX
HTRAP23 = $D663  ; @HTRAPXX
CPU_HTRAP24 = $D664  ; @HTRAPXX
HTRAP24 = $D664  ; @HTRAPXX
CPU_HTRAP25 = $D665  ; @HTRAPXX
HTRAP25 = $D665  ; @HTRAPXX
CPU_HTRAP26 = $D666  ; @HTRAPXX
HTRAP26 = $D666  ; @HTRAPXX
CPU_HTRAP27 = $D667  ; @HTRAPXX
HTRAP27 = $D667  ; @HTRAPXX
CPU_HTRAP28 = $D668  ; @HTRAPXX
HTRAP28 = $D668  ; @HTRAPXX
CPU_HTRAP29 = $D669  ; @HTRAPXX
HTRAP29 = $D669  ; @HTRAPXX
CPU_HTRAP2A = $D66A  ; @HTRAPXX
HTRAP2A = $D66A  ; @HTRAPXX
CPU_HTRAP2B = $D66B  ; @HTRAPXX
HTRAP2B = $D66B  ; @HTRAPXX
CPU_HTRAP2C = $D66C  ; @HTRAPXX
HTRAP2C = $D66C  ; @HTRAPXX
CPU_HTRAP2D = $D66D  ; @HTRAPXX
HTRAP2D = $D66D  ; @HTRAPXX
CPU_HTRAP2E = $D66E  ; @HTRAPXX
HTRAP2E = $D66E  ; @HTRAPXX
CPU_HTRAP2F = $D66F  ; @HTRAPXX
HTRAP2F = $D66F  ; @HTRAPXX
CPU_HTRAP30 = $D670  ; @HTRAPXX
HTRAP30 = $D670  ; @HTRAPXX
HCPU_GEORAMBASE = $D670  ; Hypervisor GeoRAM base address (x MB)
GEORAMBASE = $D670  ; Hypervisor GeoRAM base address (x MB)
CPU_HTRAP31 = $D671  ; @HTRAPXX
HTRAP31 = $D671  ; @HTRAPXX
HCPU_GEORAMMASK = $D671  ; Hypervisor GeoRAM address mask (applied to GeoRAM block register)
GEORAMMASK = $D671  ; Hypervisor GeoRAM address mask (applied to GeoRAM block register)
CPU_HTRAP32 = $D672  ; @HTRAPXX
HTRAP32 = $D672  ; @HTRAPXX
HCPU_MATRIXEN_ADDR = $D672  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (address)
MATRIXEN_ADDR = $D672  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (address)
HCPU_MATRIXEN_MASK = 64  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (bit mask)
MATRIXEN_MASK = 64  ; Enable composited Matrix Mode, and disable UART access to serial monitor. (bit mask)
CPU_HTRAP33 = $D673  ; @HTRAPXX
HTRAP33 = $D673  ; @HTRAPXX
CPU_HTRAP34 = $D674  ; @HTRAPXX
HTRAP34 = $D674  ; @HTRAPXX
CPU_HTRAP35 = $D675  ; @HTRAPXX
HTRAP35 = $D675  ; @HTRAPXX
CPU_HTRAP36 = $D676  ; @HTRAPXX
HTRAP36 = $D676  ; @HTRAPXX
CPU_HTRAP37 = $D677  ; @HTRAPXX
HTRAP37 = $D677  ; @HTRAPXX
CPU_HTRAP38 = $D678  ; @HTRAPXX
HTRAP38 = $D678  ; @HTRAPXX
CPU_HTRAP39 = $D679  ; @HTRAPXX
HTRAP39 = $D679  ; @HTRAPXX
CPU_HTRAP3A = $D67A  ; @HTRAPXX
HTRAP3A = $D67A  ; @HTRAPXX
CPU_HTRAP3B = $D67B  ; @HTRAPXX
HTRAP3B = $D67B  ; @HTRAPXX
CPU_HTRAP3C = $D67C  ; @HTRAPXX
HTRAP3C = $D67C  ; @HTRAPXX
HCPU_UARTDATA_ADDR = $D67C  ; (write) Hypervisor write serial output to UART monitor (address)
UARTDATA_ADDR = $D67C  ; (write) Hypervisor write serial output to UART monitor (address)
HCPU_UARTDATA_MASK = 255  ; (write) Hypervisor write serial output to UART monitor (bit mask)
UARTDATA_MASK = 255  ; (write) Hypervisor write serial output to UART monitor (bit mask)
CPU_HTRAP3D = $D67D  ; @HTRAPXX
HTRAP3D = $D67D  ; @HTRAPXX
HCPU_WATCHDOG = $D67D  ; Hypervisor watchdog register: writing any value clears the watch dog
WATCHDOG = $D67D  ; Hypervisor watchdog register: writing any value clears the watch dog
HCPU_RSVD_ADDR = $D67D  ; RESERVED (address)
RSVD_ADDR = $D67D  ; RESERVED (address)
HCPU_RSVD_MASK = 1  ; RESERVED (bit mask)
RSVD_MASK = 1  ; RESERVED (bit mask)
HCPU_JMP32EN_ADDR = $D67D  ; Hypervisor enable 32-bit JMP/JSR etc (address)
JMP32EN_ADDR = $D67D  ; Hypervisor enable 32-bit JMP/JSR etc (address)
HCPU_JMP32EN_MASK = 2  ; Hypervisor enable 32-bit JMP/JSR etc (bit mask)
JMP32EN_MASK = 2  ; Hypervisor enable 32-bit JMP/JSR etc (bit mask)
HCPU_ROMPROT_ADDR = $D67D  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (address)
ROMPROT_ADDR = $D67D  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (address)
HCPU_ROMPROT_MASK = 4  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (bit mask)
ROMPROT_MASK = 4  ; Hypervisor write protect C65 ROM \$20000-\$3FFFF (bit mask)
HCPU_ASCFAST_ADDR = $D67D  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (address)
ASCFAST_ADDR = $D67D  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (address)
HCPU_ASCFAST_MASK = 8  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (bit mask)
ASCFAST_MASK = 8  ; Hypervisor enable ASC/DIN CAPS LOCK key to enable/disable CPU slow-down in C64/C128/C65 modes (bit mask)
HCPU_CPUFAST_ADDR = $D67D  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (address)
CPUFAST_ADDR = $D67D  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (address)
HCPU_CPUFAST_MASK = 16  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (bit mask)
CPUFAST_MASK = 16  ; Hypervisor force CPU to 48MHz for userland (userland can override via POKE0) (bit mask)
HCPU_F4502_ADDR = $D67D  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (address)
F4502_ADDR = $D67D  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (address)
HCPU_F4502_MASK = 32  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (bit mask)
F4502_MASK = 32  ; Hypervisor force CPU to 4502 personality, even in C64 IO mode. (bit mask)
HCPU_PIRQ_ADDR = $D67D  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (address)
PIRQ_ADDR = $D67D  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (address)
HCPU_PIRQ_MASK = 64  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (bit mask)
PIRQ_MASK = 64  ; Hypervisor flag to indicate if an IRQ is pending on exit from the hypervisor / set 1 to force IRQ/NMI deferal for 1,024 cycles on exit from hypervisor. (bit mask)
HCPU_PNMI_ADDR = $D67D  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (address)
PNMI_ADDR = $D67D  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (address)
HCPU_PNMI_MASK = 128  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (bit mask)
PNMI_MASK = 128  ; Hypervisor flag to indicate if an NMI is pending on exit from the hypervisor. (bit mask)
CPU_HTRAP3E = $D67E  ; @HTRAPXX
HTRAP3E = $D67E  ; @HTRAPXX
HCPU_HICKED = $D67E  ; Hypervisor already-upgraded bit (writing sets permanently)
HICKED = $D67E  ; Hypervisor already-upgraded bit (writing sets permanently)
CPU_HTRAP3F = $D67F  ; @HTRAPXX
HTRAP3F = $D67F  ; @HTRAPXX
HCPU_ENTEREXIT = $D67F  ; Writing trigger return from hypervisor
ENTEREXIT = $D67F  ; Writing trigger return from hypervisor
SD_CMDANDSTAT = $D680  ; SD controller status/command
CMDANDSTAT = $D680  ; SD controller status/command
SD_SECTOR0 = $D681  ; SD controller SD sector address (LSB)
SECTOR0 = $D681  ; SD controller SD sector address (LSB)
SD_SECTOR1 = $D682  ; SD controller SD sector address (2nd byte)
SECTOR1 = $D682  ; SD controller SD sector address (2nd byte)
SD_SECTOR2 = $D683  ; SD controller SD sector address (3rd byte)
SECTOR2 = $D683  ; SD controller SD sector address (3rd byte)
SD_SECTOR3 = $D684  ; SD controller SD sector address (MSB)
SECTOR3 = $D684  ; SD controller SD sector address (MSB)
SD_FILLVAL = $D686  ; WRITE ONLY set fill byte for use in fill mode, instead of SD buffer data
FILLVAL = $D686  ; WRITE ONLY set fill byte for use in fill mode, instead of SD buffer data
SD_BUFBIT8_ADDR = $D689  ; (read only) reads bit 8 of the sector buffer pointer (address)
BUFBIT8_ADDR = $D689  ; (read only) reads bit 8 of the sector buffer pointer (address)
SD_BUFBIT8_MASK = 1  ; (read only) reads bit 8 of the sector buffer pointer (bit mask)
BUFBIT8_MASK = 1  ; (read only) reads bit 8 of the sector buffer pointer (bit mask)
SD_BUFFFULL_ADDR = $D689  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (address)
BUFFFULL_ADDR = $D689  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (address)
SD_BUFFFULL_MASK = 2  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (bit mask)
BUFFFULL_MASK = 2  ; (read only) if set, indicates that the sector buffer is full and has not yet been read (bit mask)
SD_HNDSHK_ADDR = $D689  ; Set/read SD card sd_handshake signal (address)
HNDSHK_ADDR = $D689  ; Set/read SD card sd_handshake signal (address)
SD_HNDSHK_MASK = 4  ; Set/read SD card sd_handshake signal (bit mask)
HNDSHK_MASK = 4  ; Set/read SD card sd_handshake signal (bit mask)
SD_DRDY_ADDR = $D689  ; SD Card Data Ready indication (address)
DRDY_ADDR = $D689  ; SD Card Data Ready indication (address)
SD_DRDY_MASK = 8  ; SD Card Data Ready indication (bit mask)
DRDY_MASK = 8  ; SD Card Data Ready indication (bit mask)
SD_RESERVED_ADDR = $D689  ; Reserved (address)
SD_RESERVED_MASK = 16  ; Reserved (bit mask)
SD_FDCSWAP_ADDR = $D689  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (address)
FDCSWAP_ADDR = $D689  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (address)
SD_FDCSWAP_MASK = 32  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (bit mask)
FDCSWAP_MASK = 32  ; Set to swap floppy drive 0 (the internal drive) and drive 1 (the drive on the 2nd position on the internal floppy cable). (bit mask)
SD_BUFFSEL_ADDR = $D689  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (address)
BUFFSEL_ADDR = $D689  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (address)
SD_BUFFSEL_MASK = 128  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (bit mask)
BUFFSEL_MASK = 128  ; Set to switch sector buffer to view SD card direct access, clear for access to the F011 FDC sector buffer. (bit mask)
SD_CDC00_ADDR = $D68A  ; (read only) Set if colour RAM at $DC00 (address)
CDC00_ADDR = $D68A  ; (read only) Set if colour RAM at $DC00 (address)
SD_CDC00_MASK = 1  ; (read only) Set if colour RAM at $DC00 (bit mask)
CDC00_MASK = 1  ; (read only) Set if colour RAM at $DC00 (bit mask)
SD_VICIII_ADDR = $D68A  ; (read only) Set if VIC-IV or ethernet IO bank visible (address)
VICIII_ADDR = $D68A  ; (read only) Set if VIC-IV or ethernet IO bank visible (address)
SD_VICIII_MASK = 2  ; (read only) Set if VIC-IV or ethernet IO bank visible (bit mask)
VICIII_MASK = 2  ; (read only) Set if VIC-IV or ethernet IO bank visible (bit mask)
SD_VFDC0_ADDR = $D68A  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (address)
VFDC0_ADDR = $D68A  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (address)
SD_VFDC0_MASK = 4  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (bit mask)
VFDC0_MASK = 4  ; (read only) Set if drive 0 is virtualised (sectors delivered via serial monitor interface) (bit mask)
SD_VFDC1_ADDR = $D68A  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (address)
VFDC1_ADDR = $D68A  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (address)
SD_VFDC1_MASK = 8  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (bit mask)
VFDC1_MASK = 8  ; (read only) Set if drive 1 is virtualised (sectors delivered via serial monitor interface) (bit mask)
SDFDC_D0IMG_ADDR = $D68B  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (address)
D0IMG_ADDR = $D68B  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (address)
SDFDC_D0IMG_MASK = 1  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (bit mask)
D0IMG_MASK = 1  ; F011 drive 0 use disk image if set, otherwise use real floppy drive. (bit mask)
SDFDC_D0P_ADDR = $D68B  ; F011 drive 0 media present (address)
D0P_ADDR = $D68B  ; F011 drive 0 media present (address)
SDFDC_D0P_MASK = 2  ; F011 drive 0 media present (bit mask)
D0P_MASK = 2  ; F011 drive 0 media present (bit mask)
SDFDC_D0WP_ADDR = $D68B  ; Write enable F011 drive 0 (address)
D0WP_ADDR = $D68B  ; Write enable F011 drive 0 (address)
SDFDC_D0WP_MASK = 4  ; Write enable F011 drive 0 (bit mask)
D0WP_MASK = 4  ; Write enable F011 drive 0 (bit mask)
SDFDC_D1IMG_ADDR = $D68B  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (address)
D1IMG_ADDR = $D68B  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (address)
SDFDC_D1IMG_MASK = 8  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (bit mask)
D1IMG_MASK = 8  ; F011 drive 1 use disk image if set, otherwise use real floppy drive. (bit mask)
SDFDC_D1P_ADDR = $D68B  ; F011 drive 1 media present (address)
D1P_ADDR = $D68B  ; F011 drive 1 media present (address)
SDFDC_D1P_MASK = 16  ; F011 drive 1 media present (bit mask)
D1P_MASK = 16  ; F011 drive 1 media present (bit mask)
SDFDC_D1WP_ADDR = $D68B  ; Write enable F011 drive 1 (address)
D1WP_ADDR = $D68B  ; Write enable F011 drive 1 (address)
SDFDC_D1WP_MASK = 32  ; Write enable F011 drive 1 (bit mask)
D1WP_MASK = 32  ; Write enable F011 drive 1 (bit mask)
F011_MDISK0_ADDR = $D68B  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 0 (address)
F011_MDISK0_MASK = 64  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 0 (bit mask)
SDFDC_D0MD_ADDR = $D68B  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
D0MD_ADDR = $D68B  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
SDFDC_D0MD_MASK = 64  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
D0MD_MASK = 64  ; F011 drive 0 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
GS_F011_MDISK0_ADDR = $D68B  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 1 (address)
GS_F011_MDISK0_MASK = 128  ; Enable 64MiB ``MEGA Disk'' for F011 emulated drive 1 (bit mask)
SDFDC_D1MD_ADDR = $D68B  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
D1MD_ADDR = $D68B  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (address)
SDFDC_D1MD_MASK = 128  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
D1MD_MASK = 128  ; F011 drive 1 disk image is 64MiB mega image if set (otherwise 800KiB 1581 image) (bit mask)
F011_DISKADDR0 = $D68C  ; Diskimage sector number (bits 0-7)
DISKADDR0 = $D68C  ; Diskimage sector number (bits 0-7)
SDFDC_D0STARTSEC0 = $D68C  ; F011 drive 0 disk image address on SD card (LSB)
D0STARTSEC0 = $D68C  ; F011 drive 0 disk image address on SD card (LSB)
F011_DISKADDR1 = $D68D  ; Diskimage sector number (bits 8-15)
DISKADDR1 = $D68D  ; Diskimage sector number (bits 8-15)
SDFDC_D0STARTSEC1 = $D68D  ; F011 drive 0 disk image address on SD card (2nd byte)
D0STARTSEC1 = $D68D  ; F011 drive 0 disk image address on SD card (2nd byte)
F011_DISKADDR2 = $D68E  ; Diskimage sector number (bits 16-23)
DISKADDR2 = $D68E  ; Diskimage sector number (bits 16-23)
SDFDC_D0STARTSEC2 = $D68E  ; F011 drive 0 disk image address on SD card (3rd byte)
D0STARTSEC2 = $D68E  ; F011 drive 0 disk image address on SD card (3rd byte)
F011_DISKADDR3 = $D68F  ; Diskimage sector number (bits 24-31)
DISKADDR3 = $D68F  ; Diskimage sector number (bits 24-31)
SDFDC_D0STARTSEC3 = $D68F  ; F011 drive 0 disk image address on SD card (MSB)
D0STARTSEC3 = $D68F  ; F011 drive 0 disk image address on SD card (MSB)
F011_DISK2ADDR0 = $D690  ; Diskimage 2 sector number (bits 0-7)
DISK2ADDR0 = $D690  ; Diskimage 2 sector number (bits 0-7)
SDFDC_D1STARTSEC0 = $D690  ; F011 drive 1 disk image address on SD card (LSB)
D1STARTSEC0 = $D690  ; F011 drive 1 disk image address on SD card (LSB)
F011_DISK2ADDR1 = $D691  ; Diskimage 2 sector number (bits 8-15)
DISK2ADDR1 = $D691  ; Diskimage 2 sector number (bits 8-15)
SDFDC_D1STARTSEC1 = $D691  ; F011 drive 1 disk image address on SD card (2nd byte)
D1STARTSEC1 = $D691  ; F011 drive 1 disk image address on SD card (2nd byte)
F011_DISK2ADDR2 = $D692  ; Diskimage 2 sector number (bits 16-23)
DISK2ADDR2 = $D692  ; Diskimage 2 sector number (bits 16-23)
SDFDC_D1STARTSEC2 = $D692  ; F011 drive 1 disk image address on SD card (3rd byte)
D1STARTSEC2 = $D692  ; F011 drive 1 disk image address on SD card (3rd byte)
F011_DISK2ADDR3 = $D693  ; Diskimage 2 sector number (bits 24-31)
DISK2ADDR3 = $D693  ; Diskimage 2 sector number (bits 24-31)
SDFDC_D1STARTSEC3 = $D693  ; F011 drive 1 disk image address on SD card (MSB)
D1STARTSEC3 = $D693  ; F011 drive 1 disk image address on SD card (MSB)
F011_AUTOTUNE = $D696  ; Enable automatic track seeking for sector reads and writes
AUTOTUNE = $D696  ; Enable automatic track seeking for sector reads and writes
DEBUG_J21INL = $D69B  ; Status of M65 R3 J21 pins
J21INL = $D69B  ; Status of M65 R3 J21 pins
DEBUG_J21INH = $D69C  ; Status of M65 R3 J21 pins
J21INH = $D69C  ; Status of M65 R3 J21 pins
DEBUG_DIPSW = $D69D  ; Status of M65 R3 DIP switches
DIPSW = $D69D  ; Status of M65 R3 DIP switches
DEBUG_SWSTATUS = $D69E  ; Status of switches 0 to 7
GS_DEBUG_SWSTATUS = $D69F  ; Status of switches 8 to 15
FDC_DBGWGATE_ADDR = $D6A0  ; Control floppy drive SIDE1 line (address)
FDC_DBGWGATE_MASK = 1  ; Control floppy drive SIDE1 line (bit mask)
GS_FDC_DBGWGATE_ADDR = $D6A0  ; Control floppy drive WGATE line (address)
GS_FDC_DBGWGATE_MASK = 2  ; Control floppy drive WGATE line (bit mask)
FDC_DBGWDATA_ADDR = $D6A0  ; Control floppy drive WDATA line (address)
DBGWDATA_ADDR = $D6A0  ; Control floppy drive WDATA line (address)
FDC_DBGWDATA_MASK = 4  ; Control floppy drive WDATA line (bit mask)
DBGWDATA_MASK = 4  ; Control floppy drive WDATA line (bit mask)
FDC_DBGDIR_ADDR = $D6A0  ; Control floppy drive STEP line (address)
FDC_DBGDIR_MASK = 8  ; Control floppy drive STEP line (bit mask)
GS_FDC_DBGDIR_ADDR = $D6A0  ; Control floppy drive STEPDIR line (address)
GS_FDC_DBGDIR_MASK = 16  ; Control floppy drive STEPDIR line (bit mask)
FDC_DBGMOTORA_ADDR = $D6A0  ; Control floppy drive SELECT line (address)
FDC_DBGMOTORA_MASK = 32  ; Control floppy drive SELECT line (bit mask)
GS_FDC_DBGMOTORA_ADDR = $D6A0  ; Control floppy drive MOTOR line (address)
GS_FDC_DBGMOTORA_MASK = 64  ; Control floppy drive MOTOR line (bit mask)
FDC_DENSITY_ADDR = $D6A0  ; Control floppy drive density select line (address)
DENSITY_ADDR = $D6A0  ; Control floppy drive density select line (address)
FDC_DENSITY_MASK = 128  ; Control floppy drive density select line (bit mask)
DENSITY_MASK = 128  ; Control floppy drive density select line (bit mask)
F011_DRV0EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 1st floppy drive (address)
DRV0EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 1st floppy drive (address)
F011_DRV0EN_MASK = 1  ; Use real floppy drive instead of SD card for 1st floppy drive (bit mask)
DRV0EN_MASK = 1  ; Use real floppy drive instead of SD card for 1st floppy drive (bit mask)
SDFDC_USEREAL0_ADDR = $D6A1  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (address)
USEREAL0_ADDR = $D6A1  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (address)
SDFDC_USEREAL0_MASK = 1  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (bit mask)
USEREAL0_MASK = 1  ; Use real floppy drive for drive 0 if set (read-only, except for from hypervisor) (bit mask)
SDFDC_TARGANY_ADDR = $D6A1  ; Read next sector under head if set, ignoring the requested side, track and sector number. (address)
TARGANY_ADDR = $D6A1  ; Read next sector under head if set, ignoring the requested side, track and sector number. (address)
SDFDC_TARGANY_MASK = 2  ; Read next sector under head if set, ignoring the requested side, track and sector number. (bit mask)
TARGANY_MASK = 2  ; Read next sector under head if set, ignoring the requested side, track and sector number. (bit mask)
F011_DRV2EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 2nd floppy drive (address)
DRV2EN_ADDR = $D6A1  ; Use real floppy drive instead of SD card for 2nd floppy drive (address)
F011_DRV2EN_MASK = 4  ; Use real floppy drive instead of SD card for 2nd floppy drive (bit mask)
DRV2EN_MASK = 4  ; Use real floppy drive instead of SD card for 2nd floppy drive (bit mask)
SDFDC_USEREAL1_ADDR = $D6A1  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (address)
USEREAL1_ADDR = $D6A1  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (address)
SDFDC_USEREAL1_MASK = 4  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (bit mask)
USEREAL1_MASK = 4  ; Use real floppy drive for drive 1 if set (read-only, except for from hypervisor) (bit mask)
SDFDC_SILENT_ADDR = $D6A1  ; Disable floppy spinning and tracking for SD card operations. (address)
SILENT_ADDR = $D6A1  ; Disable floppy spinning and tracking for SD card operations. (address)
SDFDC_SILENT_MASK = 8  ; Disable floppy spinning and tracking for SD card operations. (bit mask)
SILENT_MASK = 8  ; Disable floppy spinning and tracking for SD card operations. (bit mask)
FDC_DATARATE = $D6A2  ; Set number of bus cycles per floppy magnetic interval (decrease to increase data rate)
DATARATE = $D6A2  ; Set number of bus cycles per floppy magnetic interval (decrease to increase data rate)
MISCIO_WHEEL3TARGET_ADDR = $D6AC  ; Select audio channel volume to be set by thumb wheel #3 (address)
WHEEL3TARGET_ADDR = $D6AC  ; Select audio channel volume to be set by thumb wheel #3 (address)
MISCIO_WHEEL3TARGET_MASK = 15  ; Select audio channel volume to be set by thumb wheel #3 (bit mask)
WHEEL3TARGET_MASK = 15  ; Select audio channel volume to be set by thumb wheel #3 (bit mask)
MISCIO_WHEELBRIGHTEN_ADDR = $D6AC  ; Enable control of LCD panel brightness via thumb wheel (address)
WHEELBRIGHTEN_ADDR = $D6AC  ; Enable control of LCD panel brightness via thumb wheel (address)
MISCIO_WHEELBRIGHTEN_MASK = 128  ; Enable control of LCD panel brightness via thumb wheel (bit mask)
WHEELBRIGHTEN_MASK = 128  ; Enable control of LCD panel brightness via thumb wheel (bit mask)
MISCIO_WHEEL1TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #1 (address)
WHEEL1TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #1 (address)
MISCIO_WHEEL1TARGET_MASK = 15  ; Select audio channel volume to be set by thumb wheel #1 (bit mask)
WHEEL1TARGET_MASK = 15  ; Select audio channel volume to be set by thumb wheel #1 (bit mask)
MISCIO_WHEEL2TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #2 (address)
WHEEL2TARGET_ADDR = $D6AD  ; Select audio channel volume to be set by thumb wheel #2 (address)
MISCIO_WHEEL2TARGET_MASK = 240  ; Select audio channel volume to be set by thumb wheel #2 (bit mask)
WHEEL2TARGET_MASK = 240  ; Select audio channel volume to be set by thumb wheel #2 (bit mask)
SD_FDC_ENC_ADDR = $D6AE  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (address)
FDC_ENC_ADDR = $D6AE  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (address)
SD_FDC_ENC_MASK = 15  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (bit mask)
FDC_ENC_MASK = 15  ; Select floppy encoding (0=MFM, 1=RLL2,7, F=Raw encoding) (bit mask)
SD_AUTO_2XSEL_ADDR = $D6AE  ; Automatically select DD or HD decoder for last sector display (address)
AUTO_2XSEL_ADDR = $D6AE  ; Automatically select DD or HD decoder for last sector display (address)
SD_AUTO_2XSEL_MASK = 16  ; Automatically select DD or HD decoder for last sector display (bit mask)
AUTO_2XSEL_MASK = 16  ; Automatically select DD or HD decoder for last sector display (bit mask)
SD_FDC_VARSPD_ADDR = $D6AE  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (address)
FDC_VARSPD_ADDR = $D6AE  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (address)
SD_FDC_VARSPD_MASK = 32  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (bit mask)
FDC_VARSPD_MASK = 32  ; Enable automatic variable speed selection for floppy controller using Track Information Blocks on MEGA65 HD floppies (bit mask)
SD_FDC_2XSEL_ADDR = $D6AE  ; Select HD decoder for last sector display (address)
FDC_2XSEL_ADDR = $D6AE  ; Select HD decoder for last sector display (address)
SD_FDC_2XSEL_MASK = 64  ; Select HD decoder for last sector display (bit mask)
FDC_2XSEL_MASK = 64  ; Select HD decoder for last sector display (bit mask)
SD_FDC_TIBEN_ADDR = $D6AE  ; Enable use of Track Info Block settings (address)
FDC_TIBEN_ADDR = $D6AE  ; Enable use of Track Info Block settings (address)
SD_FDC_TIBEN_MASK = 128  ; Enable use of Track Info Block settings (bit mask)
FDC_TIBEN_MASK = 128  ; Enable use of Track Info Block settings (bit mask)
SD_VR_FOUND_ADDR = $D6AF  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (address)
VR_FOUND_ADDR = $D6AF  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (address)
SD_VR_FOUND_MASK = 1  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (bit mask)
VR_FOUND_MASK = 1  ; Manually set f011_rsector_found signal (indented for virtual F011 mode only) (bit mask)
SD_VW_FOUND_ADDR = $D6AF  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (address)
VW_FOUND_ADDR = $D6AF  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (address)
SD_VW_FOUND_MASK = 2  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (bit mask)
VW_FOUND_MASK = 2  ; Manually set f011_wsector_found signal (indented for virtual F011 mode only) (bit mask)
SD_VEQ_INH_ADDR = $D6AF  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (address)
VEQ_INH_ADDR = $D6AF  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (address)
SD_VEQ_INH_MASK = 4  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (bit mask)
VEQ_INH_MASK = 4  ; Manually set f011_eq_inhibit signal (indented for virtual F011 mode only) (bit mask)
SD_VRNF_ADDR = $D6AF  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (address)
VRNF_ADDR = $D6AF  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (address)
SD_VRNF_MASK = 8  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (bit mask)
VRNF_MASK = 8  ; Manually set f011_rnf signal (indented for virtual F011 mode only) (bit mask)
SD_VDRQ_ADDR = $D6AF  ; Manually set f011_drq signal (indented for virtual F011 mode only) (address)
VDRQ_ADDR = $D6AF  ; Manually set f011_drq signal (indented for virtual F011 mode only) (address)
SD_VDRQ_MASK = 16  ; Manually set f011_drq signal (indented for virtual F011 mode only) (bit mask)
VDRQ_MASK = 16  ; Manually set f011_drq signal (indented for virtual F011 mode only) (bit mask)
SD_VLOST_ADDR = $D6AF  ; Manually set f011_lost signal (indented for virtual F011 mode only) (address)
VLOST_ADDR = $D6AF  ; Manually set f011_lost signal (indented for virtual F011 mode only) (address)
SD_VLOST_MASK = 32  ; Manually set f011_lost signal (indented for virtual F011 mode only) (bit mask)
VLOST_MASK = 32  ; Manually set f011_lost signal (indented for virtual F011 mode only) (bit mask)
TOUCH_EV1_ADDR = $D6B0  ; Touch event 1 is valid (address)
EV1_ADDR = $D6B0  ; Touch event 1 is valid (address)
TOUCH_EV1_MASK = 1  ; Touch event 1 is valid (bit mask)
EV1_MASK = 1  ; Touch event 1 is valid (bit mask)
TOUCH_EV2_ADDR = $D6B0  ; Touch event 2 is valid (address)
EV2_ADDR = $D6B0  ; Touch event 2 is valid (address)
TOUCH_EV2_MASK = 2  ; Touch event 2 is valid (bit mask)
EV2_MASK = 2  ; Touch event 2 is valid (bit mask)
TOUCH_UPDN1_ADDR = $D6B0  ; Touch event 1 up/down state (address)
UPDN1_ADDR = $D6B0  ; Touch event 1 up/down state (address)
TOUCH_UPDN1_MASK = 12  ; Touch event 1 up/down state (bit mask)
UPDN1_MASK = 12  ; Touch event 1 up/down state (bit mask)
TOUCH_UPDN2_ADDR = $D6B0  ; Touch event 2 up/down state (address)
UPDN2_ADDR = $D6B0  ; Touch event 2 up/down state (address)
TOUCH_UPDN2_MASK = 48  ; Touch event 2 up/down state (bit mask)
UPDN2_MASK = 48  ; Touch event 2 up/down state (bit mask)
MISCIO_TCHFLX_ADDR = $D6B0  ; Flip X axis of touch interface if set (address)
MISCIO_TCHFLX_MASK = 64  ; Flip X axis of touch interface if set (bit mask)
TOUCH_XINV_ADDR = $D6B0  ; Invert horizontal axis (address)
XINV_ADDR = $D6B0  ; Invert horizontal axis (address)
TOUCH_XINV_MASK = 64  ; Invert horizontal axis (bit mask)
XINV_MASK = 64  ; Invert horizontal axis (bit mask)
GS_MISCIO_TCHFLX_ADDR = $D6B0  ; Flip Y axis of touch interface if set (address)
GS_MISCIO_TCHFLX_MASK = 128  ; Flip Y axis of touch interface if set (bit mask)
TOUCH_YINV_ADDR = $D6B0  ; Invert vertical axis (address)
YINV_ADDR = $D6B0  ; Invert vertical axis (address)
TOUCH_YINV_MASK = 128  ; Invert vertical axis (bit mask)
YINV_MASK = 128  ; Invert vertical axis (bit mask)
MISCIO_TCHXSCALE = $D6B1  ; Set X scale value for touch interface (LSB)
TOUCH_CALXSCALELSB = $D6B1  ; Touch pad X scaling LSB
CALXSCALELSB = $D6B1  ; Touch pad X scaling LSB
GS_MISCIO_TCHXSCALE = $D6B2  ; Set X scale value for touch interface (MSB)
TOUCH_CALXSCALEMSB = $D6B2  ; Touch pad X scaling MSB
CALXSCALEMSB = $D6B2  ; Touch pad X scaling MSB
MISCIO_TCHYSCALE = $D6B3  ; Set Y scale value for touch interface (LSB)
TOUCH_CALYSCALELSB = $D6B3  ; Touch pad Y scaling LSB
CALYSCALELSB = $D6B3  ; Touch pad Y scaling LSB
GS_MISCIO_TCHYSCALE = $D6B4  ; Set Y scale value for touch interface (MSB)
TOUCH_CALYSCALEMSB = $D6B4  ; Touch pad Y scaling MSB
CALYSCALEMSB = $D6B4  ; Touch pad Y scaling MSB
MISCIO_TCHXDELTA = $D6B5  ; Set X delta value for touch interface (LSB)
TOUCH_CALXDELTALSB = $D6B5  ; Touch pad X delta LSB
CALXDELTALSB = $D6B5  ; Touch pad X delta LSB
MISCIO_TCHYDELTA = $D6B7  ; Set Y delta value for touch interface (LSB)
TOUCH_CALYDELTALSB = $D6B7  ; Touch pad Y delta LSB
CALYDELTALSB = $D6B7  ; Touch pad Y delta LSB
GS_MISCIO_TCHYDELTA = $D6B8  ; Set Y delta value for touch interface (MSB)
TOUCH_CALYDELTAMSB = $D6B8  ; Touch pad Y delta MSB
CALYDELTAMSB = $D6B8  ; Touch pad Y delta MSB
TOUCH_TOUCH1XLSB = $D6B9  ; Touch pad touch #1 X LSB
TOUCH1XLSB = $D6B9  ; Touch pad touch #1 X LSB
TOUCH_TOUCH1YLSB = $D6BA  ; Touch pad touch #1 Y LSB
TOUCH1YLSB = $D6BA  ; Touch pad touch #1 Y LSB
GS_MISCIO_TCHXDELTA = $D6BB  ; Set X delta value for touch interface (MSB)
TOUCH_TOUCH1XMSB_ADDR = $D6BB  ; Touch pad touch \#1 X MSBs (address)
TOUCH1XMSB_ADDR = $D6BB  ; Touch pad touch \#1 X MSBs (address)
TOUCH_TOUCH1XMSB_MASK = 3  ; Touch pad touch \#1 X MSBs (bit mask)
TOUCH1XMSB_MASK = 3  ; Touch pad touch \#1 X MSBs (bit mask)
TOUCH_TOUCH1YMSB_ADDR = $D6BB  ; Touch pad touch \#1 Y MSBs (address)
TOUCH1YMSB_ADDR = $D6BB  ; Touch pad touch \#1 Y MSBs (address)
TOUCH_TOUCH1YMSB_MASK = 48  ; Touch pad touch \#1 Y MSBs (bit mask)
TOUCH1YMSB_MASK = 48  ; Touch pad touch \#1 Y MSBs (bit mask)
TOUCH_TOUCH2XLSB = $D6BC  ; Touch pad touch \#2 X LSB
TOUCH2XLSB = $D6BC  ; Touch pad touch \#2 X LSB
TOUCH_TOUCH2YLSB = $D6BD  ; Touch pad touch \#2 Y LSB
TOUCH2YLSB = $D6BD  ; Touch pad touch \#2 Y LSB
TOUCH_TOUCH2XMSB_ADDR = $D6BE  ; Touch pad touch \#2 X MSBs (address)
TOUCH2XMSB_ADDR = $D6BE  ; Touch pad touch \#2 X MSBs (address)
TOUCH_TOUCH2XMSB_MASK = 3  ; Touch pad touch \#2 X MSBs (bit mask)
TOUCH2XMSB_MASK = 3  ; Touch pad touch \#2 X MSBs (bit mask)
TOUCH_TOUCH2YMSB_ADDR = $D6BE  ; Touch pad touch \#2 Y MSBs (address)
TOUCH2YMSB_ADDR = $D6BE  ; Touch pad touch \#2 Y MSBs (address)
TOUCH_TOUCH2YMSB_MASK = 48  ; Touch pad touch \#2 Y MSBs (bit mask)
TOUCH2YMSB_MASK = 48  ; Touch pad touch \#2 Y MSBs (bit mask)
MISCIO_TCHBYTENUM_ADDR = $D6BF  ; Select byte number for touch panel communications instrumentation (address)
TCHBYTENUM_ADDR = $D6BF  ; Select byte number for touch panel communications instrumentation (address)
MISCIO_TCHBYTENUM_MASK = 127  ; Select byte number for touch panel communications instrumentation (bit mask)
TCHBYTENUM_MASK = 127  ; Select byte number for touch panel communications instrumentation (bit mask)
MISCIO_TCHI2CEN_ADDR = $D6BF  ; Enable/disable touch panel I2C communications (address)
TCHI2CEN_ADDR = $D6BF  ; Enable/disable touch panel I2C communications (address)
MISCIO_TCHI2CEN_MASK = 128  ; Enable/disable touch panel I2C communications (bit mask)
TCHI2CEN_MASK = 128  ; Enable/disable touch panel I2C communications (bit mask)
TOUCH_GESTUREDIR_ADDR = $D6C0  ; Touch pad gesture directions (left,right,up,down) (address)
GESTUREDIR_ADDR = $D6C0  ; Touch pad gesture directions (left,right,up,down) (address)
TOUCH_GESTUREDIR_MASK = 15  ; Touch pad gesture directions (left,right,up,down) (bit mask)
GESTUREDIR_MASK = 15  ; Touch pad gesture directions (left,right,up,down) (bit mask)
TOUCH_GESTUREID_ADDR = $D6C0  ; Touch pad gesture ID (address)
GESTUREID_ADDR = $D6C0  ; Touch pad gesture ID (address)
TOUCH_GESTUREID_MASK = 240  ; Touch pad gesture ID (bit mask)
GESTUREID_MASK = 240  ; Touch pad gesture ID (bit mask)
FPGA_REGNUM = $D6C4  ; Select ICAPE2 FPGA configuration register for reading WRITE ONLY
REGNUM = $D6C4  ; Select ICAPE2 FPGA configuration register for reading WRITE ONLY
FPGA_REGVAL = $D6C4  ; Value of selected ICAPE2 register (least significant byte)
GS_FPGA_REGVAL = $D6C5  ; Value of selected ICAPE2 register
GS_FPGA_REGVAL_2 = $D6C6  ; Value of selected ICAPE2 register
GS_FPGA_REGVAL_3 = $D6C7  ; Value of selected ICAPE2 register (most significant byte)
FPGA_BOOTADDR0 = $D6C8  ; Address of bitstream in boot flash for reconfiguration (least significant byte)
BOOTADDR0 = $D6C8  ; Address of bitstream in boot flash for reconfiguration (least significant byte)
FPGA_BOOTADDR1 = $D6C9  ; Address of bitstream in boot flash for reconfiguration
BOOTADDR1 = $D6C9  ; Address of bitstream in boot flash for reconfiguration
FPGA_BOOTADDR2 = $D6CA  ; Address of bitstream in boot flash for reconfiguration
BOOTADDR2 = $D6CA  ; Address of bitstream in boot flash for reconfiguration
FPGA_BOOTADDR3 = $D6CB  ; Address of bitstream in boot flash for reconfiguration (most significant byte)
BOOTADDR3 = $D6CB  ; Address of bitstream in boot flash for reconfiguration (most significant byte)
QSPI_DB_ADDR = $D6CC  ; Data bits for QSPI flash interface (read/write) (address)
DB_ADDR = $D6CC  ; Data bits for QSPI flash interface (read/write) (address)
QSPI_DB_MASK = 15  ; Data bits for QSPI flash interface (read/write) (bit mask)
DB_MASK = 15  ; Data bits for QSPI flash interface (read/write) (bit mask)
QSPI_RESERVED_ADDR = $D6CC  ; (set to 0) (address)
QSPI_RESERVED_MASK = 16  ; (set to 0) (bit mask)
QSPI_CLOCK_ADDR = $D6CC  ; Clock output line for QSPI flash (address)
QSPI_CLOCK_MASK = 32  ; Clock output line for QSPI flash (bit mask)
QSPI_CSN_ADDR = $D6CC  ; Active-low chip-select for QSPI flash (address)
CSN_ADDR = $D6CC  ; Active-low chip-select for QSPI flash (address)
QSPI_CSN_MASK = 64  ; Active-low chip-select for QSPI flash (bit mask)
CSN_MASK = 64  ; Active-low chip-select for QSPI flash (bit mask)
QSPI_TRI_ADDR = $D6CC  ; Tristate DB0-3 (address)
TRI_ADDR = $D6CC  ; Tristate DB0-3 (address)
QSPI_TRI_MASK = 128  ; Tristate DB0-3 (bit mask)
TRI_MASK = 128  ; Tristate DB0-3 (bit mask)
QSPI_CLOCKRUN_ADDR = $D6CD  ; Set to cause QSPI clock to free run at CPU clock frequency. (address)
CLOCKRUN_ADDR = $D6CD  ; Set to cause QSPI clock to free run at CPU clock frequency. (address)
QSPI_CLOCKRUN_MASK = 1  ; Set to cause QSPI clock to free run at CPU clock frequency. (bit mask)
CLOCKRUN_MASK = 1  ; Set to cause QSPI clock to free run at CPU clock frequency. (bit mask)
GS_QSPI_CLOCK_ADDR = $D6CD  ; Alternate address for direct manipulation of QSPI CLOCK (address)
GS_QSPI_CLOCK_MASK = 2  ; Alternate address for direct manipulation of QSPI CLOCK (bit mask)
FPGA_RECONFTRIG = $D6CF  ; Write $42 to Trigger FPGA reconfiguration to switch to alternate bitstream.
RECONFTRIG = $D6CF  ; Write $42 to Trigger FPGA reconfiguration to switch to alternate bitstream.
MISC_I2CBUSSELECT = $D6D0  ; I2C bus select (bus 0 = temp sensor on Nexys4 boardS)
I2CBUSSELECT = $D6D0  ; I2C bus select (bus 0 = temp sensor on Nexys4 boardS)
MISCIO_I2CBUSSEL = $D6D0  ; Select I2C bus number (I2C busses vary between MEGA65 and MEGAphone variants)
I2CBUSSEL = $D6D0  ; Select I2C bus number (I2C busses vary between MEGA65 and MEGAphone variants)
MISCIO_I2CRST_ADDR = $D6D1  ; I2C reset (address)
I2CRST_ADDR = $D6D1  ; I2C reset (address)
MISCIO_I2CRST_MASK = 1  ; I2C reset (bit mask)
I2CRST_MASK = 1  ; I2C reset (bit mask)
MISCIO_I2CL_ADDR = $D6D1  ; I2C command latch write strobe (write 1 to trigger command) (address)
I2CL_ADDR = $D6D1  ; I2C command latch write strobe (write 1 to trigger command) (address)
MISCIO_I2CL_MASK = 2  ; I2C command latch write strobe (write 1 to trigger command) (bit mask)
I2CL_MASK = 2  ; I2C command latch write strobe (write 1 to trigger command) (bit mask)
MISCIO_I2CRW_ADDR = $D6D1  ; I2C Select read (1) or write (0) (address)
I2CRW_ADDR = $D6D1  ; I2C Select read (1) or write (0) (address)
MISCIO_I2CRW_MASK = 4  ; I2C Select read (1) or write (0) (bit mask)
I2CRW_MASK = 4  ; I2C Select read (1) or write (0) (bit mask)
MISCIO_I2CSW_ADDR = $D6D1  ; I2C bus 1 swap SDA/SCL pins (address)
I2CSW_ADDR = $D6D1  ; I2C bus 1 swap SDA/SCL pins (address)
MISCIO_I2CSW_MASK = 32  ; I2C bus 1 swap SDA/SCL pins (bit mask)
I2CSW_MASK = 32  ; I2C bus 1 swap SDA/SCL pins (bit mask)
MISCIO_I2CBSY_ADDR = $D6D1  ; I2C busy flag (address)
I2CBSY_ADDR = $D6D1  ; I2C busy flag (address)
MISCIO_I2CBSY_MASK = 64  ; I2C busy flag (bit mask)
I2CBSY_MASK = 64  ; I2C busy flag (bit mask)
MISCIO_I2CERR_ADDR = $D6D1  ; I2C ack error (address)
I2CERR_ADDR = $D6D1  ; I2C ack error (address)
MISCIO_I2CERR_MASK = 128  ; I2C ack error (bit mask)
I2CERR_MASK = 128  ; I2C ack error (bit mask)
MISCIO_I2CADDR_ADDR = $D6D2  ; I2C address (address)
I2CADDR_ADDR = $D6D2  ; I2C address (address)
MISCIO_I2CADDR_MASK = 254  ; I2C address (bit mask)
I2CADDR_MASK = 254  ; I2C address (bit mask)
MISCIO_I2CWDATA = $D6D3  ; I2C data write register
I2CWDATA = $D6D3  ; I2C data write register
MISCIO_I2CRDATA = $D6D4  ; I2C data read register
I2CRDATA = $D6D4  ; I2C data read register
MISC_SDDEBUGERRLSB = $D6DA  ; DEBUG SD card last error code LSB
SDDEBUGERRLSB = $D6DA  ; DEBUG SD card last error code LSB
MISC_SDDEBUGERRMSB = $D6DB  ; DEBUG SD card last error code MSB
SDDEBUGERRMSB = $D6DB  ; DEBUG SD card last error code MSB
FPGA_FPGATEMPLSB = $D6DE  ; FPGA die temperature sensor (lower nybl)
FPGATEMPLSB = $D6DE  ; FPGA die temperature sensor (lower nybl)
FPGA_FPGATEMPMSB = $D6DF  ; FPGA die temperature sensor (upper byte)
FPGATEMPMSB = $D6DF  ; FPGA die temperature sensor (upper byte)
ETH_RST_ADDR = $D6E0  ; Write 0 to hold ethernet controller under reset (address)
ETH_RST_MASK = 1  ; Write 0 to hold ethernet controller under reset (bit mask)
ETH_TXRST_ADDR = $D6E0  ; Write 0 to hold ethernet controller transmit sub-system under reset (address)
TXRST_ADDR = $D6E0  ; Write 0 to hold ethernet controller transmit sub-system under reset (address)
ETH_TXRST_MASK = 2  ; Write 0 to hold ethernet controller transmit sub-system under reset (bit mask)
TXRST_MASK = 2  ; Write 0 to hold ethernet controller transmit sub-system under reset (bit mask)
ETH_DRXD_ADDR = $D6E0  ; Read ethernet RX bits currently on the wire (address)
DRXD_ADDR = $D6E0  ; Read ethernet RX bits currently on the wire (address)
ETH_DRXD_MASK = 4  ; Read ethernet RX bits currently on the wire (bit mask)
DRXD_MASK = 4  ; Read ethernet RX bits currently on the wire (bit mask)
ETH_DRXDV_ADDR = $D6E0  ; Read ethernet RX data valid (debug) (address)
DRXDV_ADDR = $D6E0  ; Read ethernet RX data valid (debug) (address)
ETH_DRXDV_MASK = 8  ; Read ethernet RX data valid (debug) (bit mask)
DRXDV_MASK = 8  ; Read ethernet RX data valid (debug) (bit mask)
ETH_KEYEN_ADDR = $D6E0  ; Allow remote keyboard input via magic ethernet frames (address)
KEYEN_ADDR = $D6E0  ; Allow remote keyboard input via magic ethernet frames (address)
ETH_KEYEN_MASK = 16  ; Allow remote keyboard input via magic ethernet frames (bit mask)
KEYEN_MASK = 16  ; Allow remote keyboard input via magic ethernet frames (bit mask)
ETH_RXBLKD_ADDR = $D6E0  ; Indicate if ethernet RX is blocked until RX buffers freed (address)
RXBLKD_ADDR = $D6E0  ; Indicate if ethernet RX is blocked until RX buffers freed (address)
ETH_RXBLKD_MASK = 64  ; Indicate if ethernet RX is blocked until RX buffers freed (bit mask)
RXBLKD_MASK = 64  ; Indicate if ethernet RX is blocked until RX buffers freed (bit mask)
ETH_TXIDLE_ADDR = $D6E0  ; Ethernet transmit side is idle, i.e., a packet can be sent. (address)
TXIDLE_ADDR = $D6E0  ; Ethernet transmit side is idle, i.e., a packet can be sent. (address)
ETH_TXIDLE_MASK = 128  ; Ethernet transmit side is idle, i.e., a packet can be sent. (bit mask)
TXIDLE_MASK = 128  ; Ethernet transmit side is idle, i.e., a packet can be sent. (bit mask)
ETH_RXBF_ADDR = $D6E1  ; Number of free receive buffers (address)
RXBF_ADDR = $D6E1  ; Number of free receive buffers (address)
ETH_RXBF_MASK = 6  ; Number of free receive buffers (bit mask)
RXBF_MASK = 6  ; Number of free receive buffers (bit mask)
ETH_STRM_ADDR = $D6E1  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (address)
STRM_ADDR = $D6E1  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (address)
ETH_STRM_MASK = 8  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (bit mask)
STRM_MASK = 8  ; Enable streaming of CPU instruction stream or VIC-IV display on ethernet (bit mask)
ETH_TXQ_ADDR = $D6E1  ; Ethernet TX IRQ status (address)
TXQ_ADDR = $D6E1  ; Ethernet TX IRQ status (address)
ETH_TXQ_MASK = 16  ; Ethernet TX IRQ status (bit mask)
TXQ_MASK = 16  ; Ethernet TX IRQ status (bit mask)
ETH_RXQ_ADDR = $D6E1  ; Ethernet RX IRQ status (address)
RXQ_ADDR = $D6E1  ; Ethernet RX IRQ status (address)
ETH_RXQ_MASK = 32  ; Ethernet RX IRQ status (bit mask)
RXQ_MASK = 32  ; Ethernet RX IRQ status (bit mask)
ETH_TXQEN_ADDR = $D6E1  ; Enable ethernet TX IRQ (address)
TXQEN_ADDR = $D6E1  ; Enable ethernet TX IRQ (address)
ETH_TXQEN_MASK = 64  ; Enable ethernet TX IRQ (bit mask)
TXQEN_MASK = 64  ; Enable ethernet TX IRQ (bit mask)
ETH_RXQEN_ADDR = $D6E1  ; Enable ethernet RX IRQ (address)
RXQEN_ADDR = $D6E1  ; Enable ethernet RX IRQ (address)
ETH_RXQEN_MASK = 128  ; Enable ethernet RX IRQ (bit mask)
RXQEN_MASK = 128  ; Enable ethernet RX IRQ (bit mask)
ETH_TXSZLSB = $D6E2  ; TX Packet size (low byte)
TXSZLSB = $D6E2  ; TX Packet size (low byte)
ETH_TXSZMSB = $D6E3  ; TX Packet size (high byte)
TXSZMSB = $D6E3  ; TX Packet size (high byte)
ETH_COMMAND = $D6E4  ; Ethernet command register (write only)
ETH_NOPROM_ADDR = $D6E5  ; Ethernet disable promiscuous mode (address)
NOPROM_ADDR = $D6E5  ; Ethernet disable promiscuous mode (address)
ETH_NOPROM_MASK = 1  ; Ethernet disable promiscuous mode (bit mask)
NOPROM_MASK = 1  ; Ethernet disable promiscuous mode (bit mask)
ETH_NOCRC_ADDR = $D6E5  ; Disable CRC check for received packets (address)
NOCRC_ADDR = $D6E5  ; Disable CRC check for received packets (address)
ETH_NOCRC_MASK = 2  ; Disable CRC check for received packets (bit mask)
NOCRC_MASK = 2  ; Disable CRC check for received packets (bit mask)
ETH_TXPH_ADDR = $D6E5  ; Ethernet TX clock phase adjust (address)
TXPH_ADDR = $D6E5  ; Ethernet TX clock phase adjust (address)
ETH_TXPH_MASK = 12  ; Ethernet TX clock phase adjust (bit mask)
TXPH_MASK = 12  ; Ethernet TX clock phase adjust (bit mask)
ETH_BCST_ADDR = $D6E5  ; Accept broadcast frames (address)
BCST_ADDR = $D6E5  ; Accept broadcast frames (address)
ETH_BCST_MASK = 16  ; Accept broadcast frames (bit mask)
BCST_MASK = 16  ; Accept broadcast frames (bit mask)
ETH_MCST_ADDR = $D6E5  ; Accept multicast frames (address)
MCST_ADDR = $D6E5  ; Accept multicast frames (address)
ETH_MCST_MASK = 32  ; Accept multicast frames (bit mask)
MCST_MASK = 32  ; Accept multicast frames (bit mask)
ETH_RXPH_ADDR = $D6E5  ; Ethernet RX clock phase adjust (address)
RXPH_ADDR = $D6E5  ; Ethernet RX clock phase adjust (address)
ETH_RXPH_MASK = 192  ; Ethernet RX clock phase adjust (bit mask)
RXPH_MASK = 192  ; Ethernet RX clock phase adjust (bit mask)
ETH_MIIMREG_ADDR = $D6E6  ; Ethernet MIIM register number (address)
MIIMREG_ADDR = $D6E6  ; Ethernet MIIM register number (address)
ETH_MIIMREG_MASK = 31  ; Ethernet MIIM register number (bit mask)
MIIMREG_MASK = 31  ; Ethernet MIIM register number (bit mask)
ETH_MIIMPHY_ADDR = $D6E6  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (address)
MIIMPHY_ADDR = $D6E6  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (address)
ETH_MIIMPHY_MASK = 224  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (bit mask)
MIIMPHY_MASK = 224  ; Ethernet MIIM PHY number (use 0 for Nexys4, 1 for MEGA65 r1 PCBs) (bit mask)
ETH_MIIMVLSB = $D6E7  ; Ethernet MIIM register value (LSB)
MIIMVLSB = $D6E7  ; Ethernet MIIM register value (LSB)
ETH_MIIMVMSB = $D6E8  ; Ethernet MIIM register value (MSB)
MIIMVMSB = $D6E8  ; Ethernet MIIM register value (MSB)
ETH_MACADDR1 = $D6E9  ; Ethernet MAC address
MACADDR1 = $D6E9  ; Ethernet MAC address
ETH_MACADDR2 = $D6EA  ; @MACADDRX
MACADDR2 = $D6EA  ; @MACADDRX
ETH_MACADDR3 = $D6EB  ; @MACADDRX
MACADDR3 = $D6EB  ; @MACADDRX
ETH_MACADDR4 = $D6EC  ; @MACADDRX
MACADDR4 = $D6EC  ; @MACADDRX
ETH_MACADDR5 = $D6ED  ; @MACADDRX
MACADDR5 = $D6ED  ; @MACADDRX
ETH_MACADDR6 = $D6EE  ; @MACADDRX
MACADDR6 = $D6EE  ; @MACADDRX
ETH_DBGRXWCOUNT = $D6EF  ; DEBUG show number of writes to eth RX buffer
DBGRXWCOUNT = $D6EF  ; DEBUG show number of writes to eth RX buffer
ETH_DBGTXSTAT = $D6EF  ; DEBUG show current ethernet TX state
DBGTXSTAT = $D6EF  ; DEBUG show current ethernet TX state
MISC_LCDBRIGHTNESS = $D6F0  ; LCD panel brightness control
LCDBRIGHTNESS = $D6F0  ; LCD panel brightness control
MISCIO_LCDBRIGHT = $D6F0  ; LCD panel brightness control
LCDBRIGHT = $D6F0  ; LCD panel brightness control
MISC_FPGABUTTONS = $D6F2  ; Read FPGA five-way buttons
FPGABUTTONS = $D6F2  ; Read FPGA five-way buttons
MISC_ACCELBITBASH = $D6F3  ; Accelerometer bit-bash interface
ACCELBITBASH = $D6F3  ; Accelerometer bit-bash interface
MISCIO_ACCELBASH = $D6F3  ; Accelerometer bit-bashing port (debug only)
ACCELBASH = $D6F3  ; Accelerometer bit-bashing port (debug only)
AUDIO_MIXREGSEL = $D6F4  ; Audio Mixer register select
MIXREGSEL = $D6F4  ; Audio Mixer register select
AUDIOMIX_REGSEL = $D6F4  ; Audio Mixer register select
REGSEL = $D6F4  ; Audio Mixer register select
AUDIO_MIXREGDATA = $D6F5  ; Audio Mixer register read port
MIXREGDATA = $D6F5  ; Audio Mixer register read port
AUDIOMIX_REGWDATA = $D6F5  ; Audio Mixer register write port
REGWDATA = $D6F5  ; Audio Mixer register write port
MISC_PS2KEYSCANLSB = $D6F6  ; Keyboard scan code reader (lower byte)
PS2KEYSCANLSB = $D6F6  ; Keyboard scan code reader (lower byte)
MISC_PS2KEYSCANMSB = $D6F7  ; Keyboard scan code reader (upper nybl)
PS2KEYSCANMSB = $D6F7  ; Keyboard scan code reader (upper nybl)
AUDIO_DIGILEFTLSB = $D6F8  ; Digital audio, left channel, LSB
DIGILEFTLSB = $D6F8  ; Digital audio, left channel, LSB
AUDIO_DIGILLSB = $D6F8  ; 16-bit digital audio out (left LSB)
DIGILLSB = $D6F8  ; 16-bit digital audio out (left LSB)
AUDIO_DIGILEFTMSB = $D6F9  ; Digital audio, left channel, MSB
DIGILEFTMSB = $D6F9  ; Digital audio, left channel, MSB
AUDIO_DIGILMSB = $D6F9  ; 16-bit digital audio out (left MSB)
DIGILMSB = $D6F9  ; 16-bit digital audio out (left MSB)
AUDIO_DIGIRIGHTLSB = $D6FA  ; Digital audio, left channel, LSB
DIGIRIGHTLSB = $D6FA  ; Digital audio, left channel, LSB
AUDIO_DIGIRLSB = $D6FA  ; 16-bit digital audio out (right LSB)
DIGIRLSB = $D6FA  ; 16-bit digital audio out (right LSB)
AUDIO_DIGIRIGHTMSB = $D6FB  ; Digital audio, left channel, MSB
DIGIRIGHTMSB = $D6FB  ; Digital audio, left channel, MSB
AUDIO_DIGIRMSB = $D6FB  ; 16-bit digital audio out (right MSB)
DIGIRMSB = $D6FB  ; 16-bit digital audio out (right MSB)
AUDIO_READBACKLSB = $D6FC  ; audio read-back LSB (source selected by $D6F4)
READBACKLSB = $D6FC  ; audio read-back LSB (source selected by $D6F4)
AUDIO_READBACKMSB = $D6FD  ; audio read-back MSB (source selected by $D6F4)
READBACKMSB = $D6FD  ; audio read-back MSB (source selected by $D6F4)
DMA_ADDRLSBTRIG = $D700  ; DMAgic DMA list address LSB, and trigger DMA (when written)
ADDRLSBTRIG = $D700  ; DMAgic DMA list address LSB, and trigger DMA (when written)
DMA_ADDRMSB = $D701  ; DMA list address high byte (address bits 8 -- 15).
ADDRMSB = $D701  ; DMA list address high byte (address bits 8 -- 15).
DMA_ADDRBANK = $D702  ; DMA list address bank (address bits 16 -- 22). Writing clears \$D704.
ADDRBANK = $D702  ; DMA list address bank (address bits 16 -- 22). Writing clears \$D704.
DMA_EN018B_ADDR = $D703  ; DMA enable F018B mode (adds sub-command byte) (address)
EN018B_ADDR = $D703  ; DMA enable F018B mode (adds sub-command byte) (address)
DMA_EN018B_MASK = 1  ; DMA enable F018B mode (adds sub-command byte) (bit mask)
EN018B_MASK = 1  ; DMA enable F018B mode (adds sub-command byte) (bit mask)
DMA_ADDRMB = $D704  ; DMA list address mega-byte
ADDRMB = $D704  ; DMA list address mega-byte
DMA_ETRIG = $D705  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list address specified as 28-bit flat address (uses DMA option list)
ETRIG = $D705  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list address specified as 28-bit flat address (uses DMA option list)
DMA_ETRIGMAPD = $D706  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list in current CPU memory map (uses DMA option list)
ETRIGMAPD = $D706  ; Set low-order byte of DMA list address, and trigger Enhanced DMA job, with list in current CPU memory map (uses DMA option list)
DMA_ADDRLSB = $D70E  ; DMA list address low byte (address bits 0 -- 7) WITHOUT STARTING A DMA JOB (used by Hypervisor for unfreezing DMA-using tasks)
ADDRLSB = $D70E  ; DMA list address low byte (address bits 0 -- 7) WITHOUT STARTING A DMA JOB (used by Hypervisor for unfreezing DMA-using tasks)
MATH_MULBUSY_ADDR = $D70F  ; Set if hardware multiplier is busy (address)
MULBUSY_ADDR = $D70F  ; Set if hardware multiplier is busy (address)
MATH_MULBUSY_MASK = 64  ; Set if hardware multiplier is busy (bit mask)
MULBUSY_MASK = 64  ; Set if hardware multiplier is busy (bit mask)
MATH_DIVBUSY_ADDR = $D70F  ; Set if hardware divider is busy (address)
DIVBUSY_ADDR = $D70F  ; Set if hardware divider is busy (address)
MATH_DIVBUSY_MASK = 128  ; Set if hardware divider is busy (bit mask)
DIVBUSY_MASK = 128  ; Set if hardware divider is busy (bit mask)
CPU_BADLEN_ADDR = $D710  ; Enable badline emulation (address)
BADLEN_ADDR = $D710  ; Enable badline emulation (address)
CPU_BADLEN_MASK = 1  ; Enable badline emulation (bit mask)
BADLEN_MASK = 1  ; Enable badline emulation (bit mask)
CPU_SLIEN_ADDR = $D710  ; Enable 6502-style slow (7 cycle) interrupts (address)
SLIEN_ADDR = $D710  ; Enable 6502-style slow (7 cycle) interrupts (address)
CPU_SLIEN_MASK = 2  ; Enable 6502-style slow (7 cycle) interrupts (bit mask)
SLIEN_MASK = 2  ; Enable 6502-style slow (7 cycle) interrupts (bit mask)
MISC_VDCSEN_ADDR = $D710  ; Enable VDC inteface simulation (address)
VDCSEN_ADDR = $D710  ; Enable VDC inteface simulation (address)
MISC_VDCSEN_MASK = 4  ; Enable VDC inteface simulation (bit mask)
VDCSEN_MASK = 4  ; Enable VDC inteface simulation (bit mask)
CPU_BRCOST_ADDR = $D710  ; 1=charge extra cycle(s) for branches taken (address)
BRCOST_ADDR = $D710  ; 1=charge extra cycle(s) for branches taken (address)
CPU_BRCOST_MASK = 8  ; 1=charge extra cycle(s) for branches taken (bit mask)
BRCOST_MASK = 8  ; 1=charge extra cycle(s) for branches taken (bit mask)
CPU_BADEXTRA_ADDR = $D710  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (address)
BADEXTRA_ADDR = $D710  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (address)
CPU_BADEXTRA_MASK = 48  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (bit mask)
BADEXTRA_MASK = 48  ; Cost of badlines minus 40. ie. 00=40 cycles, 11 = 43 cycles. (bit mask)
DMA_AUD_BLKTO_ADDR = $D711  ; Audio DMA block timeout (read only) DEBUG (address)
AUD_BLKTO_ADDR = $D711  ; Audio DMA block timeout (read only) DEBUG (address)
DMA_AUD_BLKTO_MASK = 7  ; Audio DMA block timeout (read only) DEBUG (bit mask)
AUD_BLKTO_MASK = 7  ; Audio DMA block timeout (read only) DEBUG (bit mask)
AUDIO_PWMPDM_ADDR = $D711  ; PWM/PDM audio encoding select (address)
PWMPDM_ADDR = $D711  ; PWM/PDM audio encoding select (address)
AUDIO_PWMPDM_MASK = 8  ; PWM/PDM audio encoding select (bit mask)
PWMPDM_MASK = 8  ; PWM/PDM audio encoding select (bit mask)
DMA_NOMIX_ADDR = $D711  ; Audio DMA bypasses audio mixer (address)
NOMIX_ADDR = $D711  ; Audio DMA bypasses audio mixer (address)
DMA_NOMIX_MASK = 16  ; Audio DMA bypasses audio mixer (bit mask)
NOMIX_MASK = 16  ; Audio DMA bypasses audio mixer (bit mask)
DMA_AUD_WRBLK_ADDR = $D711  ; Audio DMA block writes (samples still get read) (address)
AUD_WRBLK_ADDR = $D711  ; Audio DMA block writes (samples still get read) (address)
DMA_AUD_WRBLK_MASK = 32  ; Audio DMA block writes (samples still get read) (bit mask)
AUD_WRBLK_MASK = 32  ; Audio DMA block writes (samples still get read) (bit mask)
DMA_BLKD_ADDR = $D711  ; Audio DMA blocked (read only) DEBUG (address)
BLKD_ADDR = $D711  ; Audio DMA blocked (read only) DEBUG (address)
DMA_BLKD_MASK = 64  ; Audio DMA blocked (read only) DEBUG (bit mask)
BLKD_MASK = 64  ; Audio DMA blocked (read only) DEBUG (bit mask)
DMA_AUDEN_ADDR = $D711  ; Enable Audio DMA (address)
AUDEN_ADDR = $D711  ; Enable Audio DMA (address)
DMA_AUDEN_MASK = 128  ; Enable Audio DMA (bit mask)
AUDEN_MASK = 128  ; Enable Audio DMA (bit mask)
DMA_CH0RVOL = $D71C  ; Audio DMA channel 0 right channel volume
CH0RVOL = $D71C  ; Audio DMA channel 0 right channel volume
DMA_CH1RVOL = $D71D  ; Audio DMA channel 1 right channel volume
CH1RVOL = $D71D  ; Audio DMA channel 1 right channel volume
DMA_CH2LVOL = $D71E  ; Audio DMA channel 2 left channel volume
CH2LVOL = $D71E  ; Audio DMA channel 2 left channel volume
DMA_CH3LVOL = $D71F  ; Audio DMA channel 3 left channel volume
CH3LVOL = $D71F  ; Audio DMA channel 3 left channel volume
DMA_CH0_SBITS_ADDR = $D720  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (address)
CH0_SBITS_ADDR = $D720  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (address)
DMA_CH0_SBITS_MASK = 3  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (bit mask)
CH0_SBITS_MASK = 3  ; Audio DMA channel X sample bits (11=16, 10=8, 01=upper nybl, 00=lower nybl) (bit mask)
DMA_CH0_STP_ADDR = $D720  ; Audio DMA channel X stop flag (address)
CH0_STP_ADDR = $D720  ; Audio DMA channel X stop flag (address)
DMA_CH0_STP_MASK = 8  ; Audio DMA channel X stop flag (bit mask)
CH0_STP_MASK = 8  ; Audio DMA channel X stop flag (bit mask)
DMA_CH0_SINE_ADDR = $D720  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (address)
CH0_SINE_ADDR = $D720  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (address)
DMA_CH0_SINE_MASK = 16  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (bit mask)
CH0_SINE_MASK = 16  ; Audio DMA channel X play 32-sample sine wave instead of DMA data (bit mask)
DMA_CH0_SGN_ADDR = $D720  ; Enable Audio DMA channel X signed samples (address)
CH0_SGN_ADDR = $D720  ; Enable Audio DMA channel X signed samples (address)
DMA_CH0_SGN_MASK = 32  ; Enable Audio DMA channel X signed samples (bit mask)
CH0_SGN_MASK = 32  ; Enable Audio DMA channel X signed samples (bit mask)
DMA_CH0_LOOP_ADDR = $D720  ; Enable Audio DMA channel X looping (address)
CH0_LOOP_ADDR = $D720  ; Enable Audio DMA channel X looping (address)
DMA_CH0_LOOP_MASK = 64  ; Enable Audio DMA channel X looping (bit mask)
CH0_LOOP_MASK = 64  ; Enable Audio DMA channel X looping (bit mask)
DMA_CH0_EN_ADDR = $D720  ; Enable Audio DMA channel X (address)
CH0_EN_ADDR = $D720  ; Enable Audio DMA channel X (address)
DMA_CH0_EN_MASK = 128  ; Enable Audio DMA channel X (bit mask)
CH0_EN_MASK = 128  ; Enable Audio DMA channel X (bit mask)
DMA_CH0BADDRL = $D721  ; Audio DMA channel X base address LSB
CH0BADDRL = $D721  ; Audio DMA channel X base address LSB
DMA_CH0BADDRC = $D722  ; Audio DMA channel X base address middle byte
CH0BADDRC = $D722  ; Audio DMA channel X base address middle byte
DMA_CH0BADDRM = $D723  ; Audio DMA channel X base address MSB
CH0BADDRM = $D723  ; Audio DMA channel X base address MSB
DMA_CH0FREQL = $D724  ; Audio DMA channel X frequency LSB
CH0FREQL = $D724  ; Audio DMA channel X frequency LSB
DMA_CH0FREQC = $D725  ; Audio DMA channel X frequency middle byte
CH0FREQC = $D725  ; Audio DMA channel X frequency middle byte
DMA_CH0FREQM = $D726  ; Audio DMA channel X frequency MSB
CH0FREQM = $D726  ; Audio DMA channel X frequency MSB
DMA_CH0TADDRL = $D727  ; Audio DMA channel X top address LSB
CH0TADDRL = $D727  ; Audio DMA channel X top address LSB
DMA_CH0TADDRM = $D728  ; Audio DMA channel X top address MSB
CH0TADDRM = $D728  ; Audio DMA channel X top address MSB
DMA_CH0VOLUME = $D729  ; Audio DMA channel X playback volume
CH0VOLUME = $D729  ; Audio DMA channel X playback volume
DMA_CH0CURADDRL = $D72A  ; Audio DMA channel X current address LSB
CH0CURADDRL = $D72A  ; Audio DMA channel X current address LSB
DMA_CH0CURADDRC = $D72B  ; Audio DMA channel X current address middle byte
CH0CURADDRC = $D72B  ; Audio DMA channel X current address middle byte
DMA_CH0CURADDRM = $D72C  ; Audio DMA channel X current address MSB
CH0CURADDRM = $D72C  ; Audio DMA channel X current address MSB
DMA_CH0TMRADDRL = $D72D  ; Audio DMA channel X timing counter LSB
CH0TMRADDRL = $D72D  ; Audio DMA channel X timing counter LSB
DMA_CH0TMRADDRC = $D72E  ; Audio DMA channel X timing counter middle byte
CH0TMRADDRC = $D72E  ; Audio DMA channel X timing counter middle byte
DMA_CH0TMRADDRM = $D72F  ; Audio DMA channel X timing counter MSB
CH0TMRADDRM = $D72F  ; Audio DMA channel X timing counter MSB
DMA_CH1_SBITS_ADDR = $D730  ; @CHXSBITS (address)
CH1_SBITS_ADDR = $D730  ; @CHXSBITS (address)
DMA_CH1_SBITS_MASK = 3  ; @CHXSBITS (bit mask)
CH1_SBITS_MASK = 3  ; @CHXSBITS (bit mask)
DMA_CH1_STP_ADDR = $D730  ; @CHXSTP (address)
CH1_STP_ADDR = $D730  ; @CHXSTP (address)
DMA_CH1_STP_MASK = 8  ; @CHXSTP (bit mask)
CH1_STP_MASK = 8  ; @CHXSTP (bit mask)
DMA_CH1_SINE_ADDR = $D730  ; @CHXSINE (address)
CH1_SINE_ADDR = $D730  ; @CHXSINE (address)
DMA_CH1_SINE_MASK = 16  ; @CHXSINE (bit mask)
CH1_SINE_MASK = 16  ; @CHXSINE (bit mask)
DMA_CH1_SGN_ADDR = $D730  ; @CHXSGN (address)
CH1_SGN_ADDR = $D730  ; @CHXSGN (address)
DMA_CH1_SGN_MASK = 32  ; @CHXSGN (bit mask)
CH1_SGN_MASK = 32  ; @CHXSGN (bit mask)
DMA_CH1_LOOP_ADDR = $D730  ; @CHXLOOP (address)
CH1_LOOP_ADDR = $D730  ; @CHXLOOP (address)
DMA_CH1_LOOP_MASK = 64  ; @CHXLOOP (bit mask)
CH1_LOOP_MASK = 64  ; @CHXLOOP (bit mask)
DMA_CH1_EN_ADDR = $D730  ; @CHXEN (address)
CH1_EN_ADDR = $D730  ; @CHXEN (address)
DMA_CH1_EN_MASK = 128  ; @CHXEN (bit mask)
CH1_EN_MASK = 128  ; @CHXEN (bit mask)
DMA_CH1BADDRL = $D731  ; @CHXBADDRL
CH1BADDRL = $D731  ; @CHXBADDRL
DMA_CH1BADDRC = $D732  ; @CHXBADDRC
CH1BADDRC = $D732  ; @CHXBADDRC
DMA_CH1BADDRM = $D733  ; @CHXBADDRM
CH1BADDRM = $D733  ; @CHXBADDRM
DMA_CH1FREQL = $D734  ; @CHXFREQL
CH1FREQL = $D734  ; @CHXFREQL
DMA_CH1FREQC = $D735  ; @CHXFREQC
CH1FREQC = $D735  ; @CHXFREQC
DMA_CH1FREQM = $D736  ; @CHXFREQM
CH1FREQM = $D736  ; @CHXFREQM
DMA_CH1TADDRL = $D737  ; @CHXTADDRL
CH1TADDRL = $D737  ; @CHXTADDRL
DMA_CH1TADDRM = $D738  ; @CHXTADDRM
CH1TADDRM = $D738  ; @CHXTADDRM
DMA_CH1VOLUME = $D739  ; @CHXVOLUME
CH1VOLUME = $D739  ; @CHXVOLUME
DMA_CH1CURADDRL = $D73A  ; @CHXCURADDRL
CH1CURADDRL = $D73A  ; @CHXCURADDRL
DMA_CH1CURADDRC = $D73B  ; @CHXCURADDRC
CH1CURADDRC = $D73B  ; @CHXCURADDRC
DMA_CH1CURADDRM = $D73C  ; @CHXCURADDRM
CH1CURADDRM = $D73C  ; @CHXCURADDRM
DMA_CH1TMRADDRL = $D73D  ; @CHXTMRADDRL
CH1TMRADDRL = $D73D  ; @CHXTMRADDRL
DMA_CH1TMRADDRC = $D73E  ; @CHXTMRADDRC
CH1TMRADDRC = $D73E  ; @CHXTMRADDRC
DMA_CH1TMRADDRM = $D73F  ; @CHXTMRADDRM
CH1TMRADDRM = $D73F  ; @CHXTMRADDRM
DMA_CH2_SBITS_ADDR = $D740  ; @CHXSBITS (address)
CH2_SBITS_ADDR = $D740  ; @CHXSBITS (address)
DMA_CH2_SBITS_MASK = 3  ; @CHXSBITS (bit mask)
CH2_SBITS_MASK = 3  ; @CHXSBITS (bit mask)
DMA_CH2_STP_ADDR = $D740  ; @CHXSTP (address)
CH2_STP_ADDR = $D740  ; @CHXSTP (address)
DMA_CH2_STP_MASK = 8  ; @CHXSTP (bit mask)
CH2_STP_MASK = 8  ; @CHXSTP (bit mask)
DMA_CH2_SINE_ADDR = $D740  ; @CHXSINE (address)
CH2_SINE_ADDR = $D740  ; @CHXSINE (address)
DMA_CH2_SINE_MASK = 16  ; @CHXSINE (bit mask)
CH2_SINE_MASK = 16  ; @CHXSINE (bit mask)
DMA_CH2_SGN_ADDR = $D740  ; @CHXSGN (address)
CH2_SGN_ADDR = $D740  ; @CHXSGN (address)
DMA_CH2_SGN_MASK = 32  ; @CHXSGN (bit mask)
CH2_SGN_MASK = 32  ; @CHXSGN (bit mask)
DMA_CH2_LOOP_ADDR = $D740  ; @CHXLOOP (address)
CH2_LOOP_ADDR = $D740  ; @CHXLOOP (address)
DMA_CH2_LOOP_MASK = 64  ; @CHXLOOP (bit mask)
CH2_LOOP_MASK = 64  ; @CHXLOOP (bit mask)
DMA_CH2_EN_ADDR = $D740  ; @CHXEN (address)
CH2_EN_ADDR = $D740  ; @CHXEN (address)
DMA_CH2_EN_MASK = 128  ; @CHXEN (bit mask)
CH2_EN_MASK = 128  ; @CHXEN (bit mask)
DMA_CH2BADDRL = $D741  ; @CHXBADDRL
CH2BADDRL = $D741  ; @CHXBADDRL
DMA_CH2BADDRC = $D742  ; @CHXBADDRC
CH2BADDRC = $D742  ; @CHXBADDRC
DMA_CH2BADDRM = $D743  ; @CHXBADDRM
CH2BADDRM = $D743  ; @CHXBADDRM
DMA_CH2FREQL = $D744  ; @CHXFREQL
CH2FREQL = $D744  ; @CHXFREQL
DMA_CH2FREQC = $D745  ; @CHXFREQC
CH2FREQC = $D745  ; @CHXFREQC
DMA_CH2FREQM = $D746  ; @CHXFREQM
CH2FREQM = $D746  ; @CHXFREQM
DMA_CH2TADDRL = $D747  ; @CHXTADDRL
CH2TADDRL = $D747  ; @CHXTADDRL
DMA_CH2TADDRM = $D748  ; @CHXTADDRM
CH2TADDRM = $D748  ; @CHXTADDRM
DMA_CH2VOLUME = $D749  ; @CHXVOLUME
CH2VOLUME = $D749  ; @CHXVOLUME
DMA_CH2CURADDRL = $D74A  ; @CHXCURADDRL
CH2CURADDRL = $D74A  ; @CHXCURADDRL
DMA_CH2CURADDRC = $D74B  ; @CHXCURADDRC
CH2CURADDRC = $D74B  ; @CHXCURADDRC
DMA_CH2CURADDRM = $D74C  ; @CHXCURADDRM
CH2CURADDRM = $D74C  ; @CHXCURADDRM
DMA_CH2TMRADDRL = $D74D  ; @CHXTMRADDRL
CH2TMRADDRL = $D74D  ; @CHXTMRADDRL
DMA_CH2TMRADDRC = $D74E  ; @CHXTMRADDRC
CH2TMRADDRC = $D74E  ; @CHXTMRADDRC
DMA_CH2TMRADDRM = $D74F  ; @CHXTMRADDRM
CH2TMRADDRM = $D74F  ; @CHXTMRADDRM
DMA_CH3_SBITS_ADDR = $D750  ; @CHXSBITS (address)
CH3_SBITS_ADDR = $D750  ; @CHXSBITS (address)
DMA_CH3_SBITS_MASK = 3  ; @CHXSBITS (bit mask)
CH3_SBITS_MASK = 3  ; @CHXSBITS (bit mask)
DMA_CH3_STP_ADDR = $D750  ; @CHXSTP (address)
CH3_STP_ADDR = $D750  ; @CHXSTP (address)
DMA_CH3_STP_MASK = 8  ; @CHXSTP (bit mask)
CH3_STP_MASK = 8  ; @CHXSTP (bit mask)
DMA_CH3_SINE_ADDR = $D750  ; @CHXSINE (address)
CH3_SINE_ADDR = $D750  ; @CHXSINE (address)
DMA_CH3_SINE_MASK = 16  ; @CHXSINE (bit mask)
CH3_SINE_MASK = 16  ; @CHXSINE (bit mask)
DMA_CH3_SGN_ADDR = $D750  ; @CHXSGN (address)
CH3_SGN_ADDR = $D750  ; @CHXSGN (address)
DMA_CH3_SGN_MASK = 32  ; @CHXSGN (bit mask)
CH3_SGN_MASK = 32  ; @CHXSGN (bit mask)
DMA_CH3_LOOP_ADDR = $D750  ; @CHXLOOP (address)
CH3_LOOP_ADDR = $D750  ; @CHXLOOP (address)
DMA_CH3_LOOP_MASK = 64  ; @CHXLOOP (bit mask)
CH3_LOOP_MASK = 64  ; @CHXLOOP (bit mask)
DMA_CH3_EN_ADDR = $D750  ; @CHXEN (address)
CH3_EN_ADDR = $D750  ; @CHXEN (address)
DMA_CH3_EN_MASK = 128  ; @CHXEN (bit mask)
CH3_EN_MASK = 128  ; @CHXEN (bit mask)
DMA_CH3BADDRL = $D751  ; @CHXBADDRL
CH3BADDRL = $D751  ; @CHXBADDRL
DMA_CH3BADDRC = $D752  ; @CHXBADDRC
CH3BADDRC = $D752  ; @CHXBADDRC
DMA_CH3BADDRM = $D753  ; @CHXBADDRM
CH3BADDRM = $D753  ; @CHXBADDRM
DMA_CH3FREQL = $D754  ; @CHXFREQL
CH3FREQL = $D754  ; @CHXFREQL
DMA_CH3FREQC = $D755  ; @CHXFREQC
CH3FREQC = $D755  ; @CHXFREQC
DMA_CH3FREQM = $D756  ; @CHXFREQM
CH3FREQM = $D756  ; @CHXFREQM
DMA_CH3TADDRL = $D757  ; @CHXTADDRL
CH3TADDRL = $D757  ; @CHXTADDRL
DMA_CH3TADDRM = $D758  ; @CHXTADDRM
CH3TADDRM = $D758  ; @CHXTADDRM
DMA_CH3VOLUME = $D759  ; @CHXVOLUME
CH3VOLUME = $D759  ; @CHXVOLUME
DMA_CH3CURADDRL = $D75A  ; @CHXCURADDRL
CH3CURADDRL = $D75A  ; @CHXCURADDRL
DMA_CH3CURADDRC = $D75B  ; @CHXCURADDRC
CH3CURADDRC = $D75B  ; @CHXCURADDRC
DMA_CH3CURADDRM = $D75C  ; @CHXCURADDRM
CH3CURADDRM = $D75C  ; @CHXCURADDRM
DMA_CH3TMRADDRL = $D75D  ; @CHXTMRADDRL
CH3TMRADDRL = $D75D  ; @CHXTMRADDRL
DMA_CH3TMRADDRC = $D75E  ; @CHXTMRADDRC
CH3TMRADDRC = $D75E  ; @CHXTMRADDRC
DMA_CH3TMRADDRM = $D75F  ; @CHXTMRADDRM
CH3TMRADDRM = $D75F  ; @CHXTMRADDRM
MATH_DIVOUT = $D768  ; 64-bit output of MULTINA $\div$ MULTINB
GS_MATH_DIVOUT = $D769  ; 64-bit output of MULTINA $\div$ MULTINB
GS_MATH_DIVOUT_2 = $D76A  ; 64-bit output of MULTINA $\div$ MULTINB
GS_MATH_DIVOUT_3 = $D76B  ; 64-bit output of MULTINA $\div$ MULTINB
GS_MATH_DIVOUT_4 = $D76C  ; 64-bit output of MULTINA $\div$ MULTINB
GS_MATH_DIVOUT_5 = $D76D  ; 64-bit output of MULTINA $\div$ MULTINB
GS_MATH_DIVOUT_6 = $D76E  ; 64-bit output of MULTINA $\div$ MULTINB
GS_MATH_DIVOUT_7 = $D76F  ; 64-bit output of MULTINA $\div$ MULTINB
MATH_MULTINA = $D770  ; Multiplier input A / Divider numerator (32 bit)
GS_MATH_MULTINA = $D771  ; Multiplier input A / Divider numerator (32 bit)
GS_MATH_MULTINA_2 = $D772  ; Multiplier input A / Divider numerator (32 bit)
GS_MATH_MULTINA_3 = $D773  ; Multiplier input A / Divider numerator (32 bit)
MATH_MULTINB = $D774  ; Multiplier input B / Divider denominator (32 bit)
GS_MATH_MULTINB = $D775  ; Multiplier input B / Divider denominator (32 bit)
GS_MATH_MULTINB_2 = $D776  ; Multiplier input B / Divider denominator (32 bit)
GS_MATH_MULTINB_3 = $D777  ; Multiplier input B / Divider denominator (32 bit)
MATH_MULTOUT = $D778  ; 64-bit output of MULTINA $\times$ MULTINB
GS_MATH_MULTOUT = $D779  ; 64-bit output of MULTINA $\times$ MULTINB
GS_MATH_MULTOUT_2 = $D77A  ; 64-bit output of MULTINA $\times$ MULTINB
GS_MATH_MULTOUT_3 = $D77B  ; 64-bit output of MULTINA $\times$ MULTINB
GS_MATH_MULTOUT_4 = $D77C  ; 64-bit output of MULTINA $\times$ MULTINB
GS_MATH_MULTOUT_5 = $D77D  ; 64-bit output of MULTINA $\times$ MULTINB
GS_MATH_MULTOUT_6 = $D77E  ; 64-bit output of MULTINA $\times$ MULTINB
GS_MATH_MULTOUT_7 = $D77F  ; 64-bit output of MULTINA $\times$ MULTINB
MATH_MATHIN0 = $D780  ; Math unit 32-bit input X
GS_MATH_MATHIN0 = $D781  ; @MATHINX
GS_MATH_MATHIN0_2 = $D782  ; @MATHINX
GS_MATH_MATHIN0_3 = $D783  ; @MATHINX
MATH_MATHIN1 = $D784  ; @MATHINX
GS_MATH_MATHIN1 = $D785  ; @MATHINX
GS_MATH_MATHIN1_2 = $D786  ; @MATHINX
GS_MATH_MATHIN1_3 = $D787  ; @MATHINX
MATH_MATHIN2 = $D788  ; @MATHINX
GS_MATH_MATHIN2 = $D789  ; @MATHINX
GS_MATH_MATHIN2_2 = $D78A  ; @MATHINX
GS_MATH_MATHIN2_3 = $D78B  ; @MATHINX
MATH_MATHIN3 = $D78C  ; @MATHINX
GS_MATH_MATHIN3 = $D78D  ; @MATHINX
GS_MATH_MATHIN3_2 = $D78E  ; @MATHINX
GS_MATH_MATHIN3_3 = $D78F  ; @MATHINX
MATH_MATHIN4 = $D790  ; @MATHINX
GS_MATH_MATHIN4 = $D791  ; @MATHINX
GS_MATH_MATHIN4_2 = $D792  ; @MATHINX
GS_MATH_MATHIN4_3 = $D793  ; @MATHINX
MATH_MATHIN5 = $D794  ; @MATHINX
GS_MATH_MATHIN5 = $D795  ; @MATHINX
GS_MATH_MATHIN5_2 = $D796  ; @MATHINX
GS_MATH_MATHIN5_3 = $D797  ; @MATHINX
MATH_MATHIN6 = $D798  ; @MATHINX
GS_MATH_MATHIN6 = $D799  ; @MATHINX
GS_MATH_MATHIN6_2 = $D79A  ; @MATHINX
GS_MATH_MATHIN6_3 = $D79B  ; @MATHINX
MATH_MATHIN7 = $D79C  ; @MATHINX
GS_MATH_MATHIN7 = $D79D  ; @MATHINX
GS_MATH_MATHIN7_2 = $D79E  ; @MATHINX
GS_MATH_MATHIN7_3 = $D79F  ; @MATHINX
MATH_MATHIN8 = $D7A0  ; @MATHINX
GS_MATH_MATHIN8 = $D7A1  ; @MATHINX
GS_MATH_MATHIN8_2 = $D7A2  ; @MATHINX
GS_MATH_MATHIN8_3 = $D7A3  ; @MATHINX
MATH_MATHIN9 = $D7A4  ; @MATHINX
GS_MATH_MATHIN9 = $D7A5  ; @MATHINX
GS_MATH_MATHIN9_2 = $D7A6  ; @MATHINX
GS_MATH_MATHIN9_3 = $D7A7  ; @MATHINX
MATH_MATHINA = $D7A8  ; @MATHINX
GS_MATH_MATHINA = $D7A9  ; @MATHINX
GS_MATH_MATHINA_2 = $D7AA  ; @MATHINX
GS_MATH_MATHINA_3 = $D7AB  ; @MATHINX
MATH_MATHINB = $D7AC  ; @MATHINX
GS_MATH_MATHINB = $D7AD  ; @MATHINX
GS_MATH_MATHINB_2 = $D7AE  ; @MATHINX
GS_MATH_MATHINB_3 = $D7AF  ; @MATHINX
MATH_MATHINC = $D7B0  ; @MATHINX
GS_MATH_MATHINC = $D7B1  ; @MATHINX
GS_MATH_MATHINC_2 = $D7B2  ; @MATHINX
GS_MATH_MATHINC_3 = $D7B3  ; @MATHINX
MATH_MATHIND = $D7B4  ; @MATHINX
GS_MATH_MATHIND = $D7B5  ; @MATHINX
GS_MATH_MATHIND_2 = $D7B6  ; @MATHINX
GS_MATH_MATHIND_3 = $D7B7  ; @MATHINX
MATH_MATHINE = $D7B8  ; @MATHINX
GS_MATH_MATHINE = $D7B9  ; @MATHINX
GS_MATH_MATHINE_2 = $D7BA  ; @MATHINX
GS_MATH_MATHINE_3 = $D7BB  ; @MATHINX
MATH_MATHINF = $D7BC  ; @MATHINX
GS_MATH_MATHINF = $D7BD  ; @MATHINX
GS_MATH_MATHINF_2 = $D7BE  ; @MATHINX
GS_MATH_MATHINF_3 = $D7BF  ; @MATHINX
MATH_UNIT0INA_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (address)
UNIT0INA_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (address)
MATH_UNIT0INA_MASK = 15  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (bit mask)
UNIT0INA_MASK = 15  ; Select which of the 16 32-bit math registers is input A for Math Function Unit X. (bit mask)
MATH_UNIT0INB_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (address)
UNIT0INB_ADDR = $D7C0  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (address)
MATH_UNIT0INB_MASK = 240  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (bit mask)
UNIT0INB_MASK = 240  ; Select which of the 16 32-bit math registers is input B for Math Function Unit X. (bit mask)
MATH_UNIT1INA_ADDR = $D7C1  ; @UNITXINA (address)
UNIT1INA_ADDR = $D7C1  ; @UNITXINA (address)
MATH_UNIT1INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT1INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT1INB_ADDR = $D7C1  ; @UNITXINB (address)
UNIT1INB_ADDR = $D7C1  ; @UNITXINB (address)
MATH_UNIT1INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT1INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT2INA_ADDR = $D7C2  ; @UNITXINA (address)
UNIT2INA_ADDR = $D7C2  ; @UNITXINA (address)
MATH_UNIT2INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT2INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT2INB_ADDR = $D7C2  ; @UNITXINB (address)
UNIT2INB_ADDR = $D7C2  ; @UNITXINB (address)
MATH_UNIT2INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT2INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT3INA_ADDR = $D7C3  ; @UNITXINA (address)
UNIT3INA_ADDR = $D7C3  ; @UNITXINA (address)
MATH_UNIT3INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT3INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT3INB_ADDR = $D7C3  ; @UNITXINB (address)
UNIT3INB_ADDR = $D7C3  ; @UNITXINB (address)
MATH_UNIT3INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT3INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT4INA_ADDR = $D7C4  ; @UNITXINA (address)
UNIT4INA_ADDR = $D7C4  ; @UNITXINA (address)
MATH_UNIT4INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT4INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT4INB_ADDR = $D7C4  ; @UNITXINB (address)
UNIT4INB_ADDR = $D7C4  ; @UNITXINB (address)
MATH_UNIT4INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT4INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT5INA_ADDR = $D7C5  ; @UNITXINA (address)
UNIT5INA_ADDR = $D7C5  ; @UNITXINA (address)
MATH_UNIT5INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT5INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT5INB_ADDR = $D7C5  ; @UNITXINB (address)
UNIT5INB_ADDR = $D7C5  ; @UNITXINB (address)
MATH_UNIT5INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT5INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT6INA_ADDR = $D7C6  ; @UNITXINA (address)
UNIT6INA_ADDR = $D7C6  ; @UNITXINA (address)
MATH_UNIT6INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT6INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT6INB_ADDR = $D7C6  ; @UNITXINB (address)
UNIT6INB_ADDR = $D7C6  ; @UNITXINB (address)
MATH_UNIT6INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT6INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT7INA_ADDR = $D7C7  ; @UNITXINA (address)
UNIT7INA_ADDR = $D7C7  ; @UNITXINA (address)
MATH_UNIT7INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT7INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT7INB_ADDR = $D7C7  ; @UNITXINB (address)
UNIT7INB_ADDR = $D7C7  ; @UNITXINB (address)
MATH_UNIT7INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT7INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT8INA_ADDR = $D7C8  ; @UNITXINA (address)
UNIT8INA_ADDR = $D7C8  ; @UNITXINA (address)
MATH_UNIT8INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT8INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT8INB_ADDR = $D7C8  ; @UNITXINB (address)
UNIT8INB_ADDR = $D7C8  ; @UNITXINB (address)
MATH_UNIT8INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT8INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT9INA_ADDR = $D7C9  ; @UNITXINA (address)
UNIT9INA_ADDR = $D7C9  ; @UNITXINA (address)
MATH_UNIT9INA_MASK = 15  ; @UNITXINA (bit mask)
UNIT9INA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNIT9INB_ADDR = $D7C9  ; @UNITXINB (address)
UNIT9INB_ADDR = $D7C9  ; @UNITXINB (address)
MATH_UNIT9INB_MASK = 240  ; @UNITXINB (bit mask)
UNIT9INB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNITAINA_ADDR = $D7CA  ; @UNITXINA (address)
UNITAINA_ADDR = $D7CA  ; @UNITXINA (address)
MATH_UNITAINA_MASK = 15  ; @UNITXINA (bit mask)
UNITAINA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNITAINB_ADDR = $D7CA  ; @UNITXINB (address)
UNITAINB_ADDR = $D7CA  ; @UNITXINB (address)
MATH_UNITAINB_MASK = 240  ; @UNITXINB (bit mask)
UNITAINB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNITBINA_ADDR = $D7CB  ; @UNITXINA (address)
UNITBINA_ADDR = $D7CB  ; @UNITXINA (address)
MATH_UNITBINA_MASK = 15  ; @UNITXINA (bit mask)
UNITBINA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNITBINB_ADDR = $D7CB  ; @UNITXINB (address)
UNITBINB_ADDR = $D7CB  ; @UNITXINB (address)
MATH_UNITBINB_MASK = 240  ; @UNITXINB (bit mask)
UNITBINB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNITCINA_ADDR = $D7CC  ; @UNITXINA (address)
UNITCINA_ADDR = $D7CC  ; @UNITXINA (address)
MATH_UNITCINA_MASK = 15  ; @UNITXINA (bit mask)
UNITCINA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNITCINB_ADDR = $D7CC  ; @UNITXINB (address)
UNITCINB_ADDR = $D7CC  ; @UNITXINB (address)
MATH_UNITCINB_MASK = 240  ; @UNITXINB (bit mask)
UNITCINB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNITDINA_ADDR = $D7CD  ; @UNITXINA (address)
UNITDINA_ADDR = $D7CD  ; @UNITXINA (address)
MATH_UNITDINA_MASK = 15  ; @UNITXINA (bit mask)
UNITDINA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNITDINB_ADDR = $D7CD  ; @UNITXINB (address)
UNITDINB_ADDR = $D7CD  ; @UNITXINB (address)
MATH_UNITDINB_MASK = 240  ; @UNITXINB (bit mask)
UNITDINB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNITEINA_ADDR = $D7CE  ; @UNITXINA (address)
UNITEINA_ADDR = $D7CE  ; @UNITXINA (address)
MATH_UNITEINA_MASK = 15  ; @UNITXINA (bit mask)
UNITEINA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNITEINB_ADDR = $D7CE  ; @UNITXINB (address)
UNITEINB_ADDR = $D7CE  ; @UNITXINB (address)
MATH_UNITEINB_MASK = 240  ; @UNITXINB (bit mask)
UNITEINB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNITFINA_ADDR = $D7CF  ; @UNITXINA (address)
UNITFINA_ADDR = $D7CF  ; @UNITXINA (address)
MATH_UNITFINA_MASK = 15  ; @UNITXINA (bit mask)
UNITFINA_MASK = 15  ; @UNITXINA (bit mask)
MATH_UNITFINB_ADDR = $D7CF  ; @UNITXINB (address)
UNITFINB_ADDR = $D7CF  ; @UNITXINB (address)
MATH_UNITFINB_MASK = 240  ; @UNITXINB (bit mask)
UNITFINB_MASK = 240  ; @UNITXINB (bit mask)
MATH_UNIT0OUT_ADDR = $D7D0  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (address)
UNIT0OUT_ADDR = $D7D0  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (address)
MATH_UNIT0OUT_MASK = 15  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (bit mask)
UNIT0OUT_MASK = 15  ; Select which of the 16 32-bit math registers receives the output of Math Function Unit X (bit mask)
MATH_U0_LOWOUT_ADDR = $D7D0  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
U0_LOWOUT_ADDR = $D7D0  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
MATH_U0_LOWOUT_MASK = 16  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
U0_LOWOUT_MASK = 16  ; If set, the low-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
MATH_U0_HIOUT_ADDR = $D7D0  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
U0_HIOUT_ADDR = $D7D0  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (address)
MATH_U0_HIOUT_MASK = 32  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
U0_HIOUT_MASK = 32  ; If set, the high-half of the output of Math Function Unit X is written to math register UNITXOUT. (bit mask)
MATH_U0_MLADD_ADDR = $D7D0  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (address)
U0_MLADD_ADDR = $D7D0  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (address)
MATH_U0_MLADD_MASK = 64  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (bit mask)
U0_MLADD_MASK = 64  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit multiplier. (bit mask)
MATH_U0_LATCH_ADDR = $D7D0  ; If set, Math Function Unit X's output is latched. (address)
U0_LATCH_ADDR = $D7D0  ; If set, Math Function Unit X's output is latched. (address)
MATH_U0_LATCH_MASK = 128  ; If set, Math Function Unit X's output is latched. (bit mask)
U0_LATCH_MASK = 128  ; If set, Math Function Unit X's output is latched. (bit mask)
MATH_UNIT1OUT_ADDR = $D7D1  ; @UNITXOUT (address)
UNIT1OUT_ADDR = $D7D1  ; @UNITXOUT (address)
MATH_UNIT1OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT1OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U1_LOWOUT_ADDR = $D7D1  ; @UXLOWOUT (address)
U1_LOWOUT_ADDR = $D7D1  ; @UXLOWOUT (address)
MATH_U1_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U1_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U1_HIOUT_ADDR = $D7D1  ; @UXHIOUT (address)
U1_HIOUT_ADDR = $D7D1  ; @UXHIOUT (address)
MATH_U1_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U1_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U1_MLADD_ADDR = $D7D1  ; @UXMLADD (address)
U1_MLADD_ADDR = $D7D1  ; @UXMLADD (address)
MATH_U1_MLADD_MASK = 64  ; @UXMLADD (bit mask)
U1_MLADD_MASK = 64  ; @UXMLADD (bit mask)
MATH_U1_LATCH_ADDR = $D7D1  ; @UXLATCH (address)
U1_LATCH_ADDR = $D7D1  ; @UXLATCH (address)
MATH_U1_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U1_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT2OUT_ADDR = $D7D2  ; @UNITXOUT (address)
UNIT2OUT_ADDR = $D7D2  ; @UNITXOUT (address)
MATH_UNIT2OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT2OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U2_LOWOUT_ADDR = $D7D2  ; @UXLOWOUT (address)
U2_LOWOUT_ADDR = $D7D2  ; @UXLOWOUT (address)
MATH_U2_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U2_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U2_HIOUT_ADDR = $D7D2  ; @UXHIOUT (address)
U2_HIOUT_ADDR = $D7D2  ; @UXHIOUT (address)
MATH_U2_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U2_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U2_MLADD_ADDR = $D7D2  ; @UXMLADD (address)
U2_MLADD_ADDR = $D7D2  ; @UXMLADD (address)
MATH_U2_MLADD_MASK = 64  ; @UXMLADD (bit mask)
U2_MLADD_MASK = 64  ; @UXMLADD (bit mask)
MATH_U2_LATCH_ADDR = $D7D2  ; @UXLATCH (address)
U2_LATCH_ADDR = $D7D2  ; @UXLATCH (address)
MATH_U2_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U2_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT3OUT_ADDR = $D7D3  ; @UNITXOUT (address)
UNIT3OUT_ADDR = $D7D3  ; @UNITXOUT (address)
MATH_UNIT3OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT3OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U3_LOWOUT_ADDR = $D7D3  ; @UXLOWOUT (address)
U3_LOWOUT_ADDR = $D7D3  ; @UXLOWOUT (address)
MATH_U3_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U3_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U3_HIOUT_ADDR = $D7D3  ; @UXHIOUT (address)
U3_HIOUT_ADDR = $D7D3  ; @UXHIOUT (address)
MATH_U3_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U3_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U3_MLADD_ADDR = $D7D3  ; @UXMLADD (address)
U3_MLADD_ADDR = $D7D3  ; @UXMLADD (address)
MATH_U3_MLADD_MASK = 64  ; @UXMLADD (bit mask)
U3_MLADD_MASK = 64  ; @UXMLADD (bit mask)
MATH_U3_LATCH_ADDR = $D7D3  ; @UXLATCH (address)
U3_LATCH_ADDR = $D7D3  ; @UXLATCH (address)
MATH_U3_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U3_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT4OUT_ADDR = $D7D4  ; @UNITXOUT (address)
UNIT4OUT_ADDR = $D7D4  ; @UNITXOUT (address)
MATH_UNIT4OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT4OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U4_LOWOUT_ADDR = $D7D4  ; @UXLOWOUT (address)
U4_LOWOUT_ADDR = $D7D4  ; @UXLOWOUT (address)
MATH_U4_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U4_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U4_HIOUT_ADDR = $D7D4  ; @UXHIOUT (address)
U4_HIOUT_ADDR = $D7D4  ; @UXHIOUT (address)
MATH_U4_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U4_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U4_MLADD_ADDR = $D7D4  ; @UXMLADD (address)
U4_MLADD_ADDR = $D7D4  ; @UXMLADD (address)
MATH_U4_MLADD_MASK = 64  ; @UXMLADD (bit mask)
U4_MLADD_MASK = 64  ; @UXMLADD (bit mask)
MATH_U4_LATCH_ADDR = $D7D4  ; @UXLATCH (address)
U4_LATCH_ADDR = $D7D4  ; @UXLATCH (address)
MATH_U4_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U4_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT5OUT_ADDR = $D7D5  ; @UNITXOUT (address)
UNIT5OUT_ADDR = $D7D5  ; @UNITXOUT (address)
MATH_UNIT5OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT5OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U5_LOWOUT_ADDR = $D7D5  ; @UXLOWOUT (address)
U5_LOWOUT_ADDR = $D7D5  ; @UXLOWOUT (address)
MATH_U5_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U5_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U5_HIOUT_ADDR = $D7D5  ; @UXHIOUT (address)
U5_HIOUT_ADDR = $D7D5  ; @UXHIOUT (address)
MATH_U5_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U5_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U5_MLADD_ADDR = $D7D5  ; @UXMLADD (address)
U5_MLADD_ADDR = $D7D5  ; @UXMLADD (address)
MATH_U5_MLADD_MASK = 64  ; @UXMLADD (bit mask)
U5_MLADD_MASK = 64  ; @UXMLADD (bit mask)
MATH_U5_LATCH_ADDR = $D7D5  ; @UXLATCH (address)
U5_LATCH_ADDR = $D7D5  ; @UXLATCH (address)
MATH_U5_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U5_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT6OUT_ADDR = $D7D6  ; @UNITXOUT (address)
UNIT6OUT_ADDR = $D7D6  ; @UNITXOUT (address)
MATH_UNIT6OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT6OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U6_LOWOUT_ADDR = $D7D6  ; @UXLOWOUT (address)
U6_LOWOUT_ADDR = $D7D6  ; @UXLOWOUT (address)
MATH_U6_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U6_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U6_HIOUT_ADDR = $D7D6  ; @UXHIOUT (address)
U6_HIOUT_ADDR = $D7D6  ; @UXHIOUT (address)
MATH_U6_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U6_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U6_MLADD_ADDR = $D7D6  ; @UXMLADD (address)
U6_MLADD_ADDR = $D7D6  ; @UXMLADD (address)
MATH_U6_MLADD_MASK = 64  ; @UXMLADD (bit mask)
U6_MLADD_MASK = 64  ; @UXMLADD (bit mask)
MATH_U6_LATCH_ADDR = $D7D6  ; @UXLATCH (address)
U6_LATCH_ADDR = $D7D6  ; @UXLATCH (address)
MATH_U6_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U6_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT7OUT_ADDR = $D7D7  ; @UNITXOUT (address)
UNIT7OUT_ADDR = $D7D7  ; @UNITXOUT (address)
MATH_UNIT7OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT7OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U7_LOWOUT_ADDR = $D7D7  ; @UXLOWOUT (address)
U7_LOWOUT_ADDR = $D7D7  ; @UXLOWOUT (address)
MATH_U7_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U7_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U7_HIOUT_ADDR = $D7D7  ; @UXHIOUT (address)
U7_HIOUT_ADDR = $D7D7  ; @UXHIOUT (address)
MATH_U7_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U7_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U7_MLADD_ADDR = $D7D7  ; @UXMLADD (address)
U7_MLADD_ADDR = $D7D7  ; @UXMLADD (address)
MATH_U7_MLADD_MASK = 64  ; @UXMLADD (bit mask)
U7_MLADD_MASK = 64  ; @UXMLADD (bit mask)
MATH_U7_LATCH_ADDR = $D7D7  ; @UXLATCH (address)
U7_LATCH_ADDR = $D7D7  ; @UXLATCH (address)
MATH_U7_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U7_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT8OUT_ADDR = $D7D8  ; @UNITXOUT (address)
UNIT8OUT_ADDR = $D7D8  ; @UNITXOUT (address)
MATH_UNIT8OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT8OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U8_LOWOUT_ADDR = $D7D8  ; @UXLOWOUT (address)
U8_LOWOUT_ADDR = $D7D8  ; @UXLOWOUT (address)
MATH_U8_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U8_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U8_HIOUT_ADDR = $D7D8  ; @UXHIOUT (address)
U8_HIOUT_ADDR = $D7D8  ; @UXHIOUT (address)
MATH_U8_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U8_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U8_BSADD_ADDR = $D7D8  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (address)
U8_BSADD_ADDR = $D7D8  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (address)
MATH_U8_BSADD_MASK = 64  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (bit mask)
U8_BSADD_MASK = 64  ; If set, Math Function Unit Y acts as a 32-bit adder instead of 32-bit barrel-shifter. (bit mask)
MATH_U8_LATCH_ADDR = $D7D8  ; @UXLATCH (address)
U8_LATCH_ADDR = $D7D8  ; @UXLATCH (address)
MATH_U8_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U8_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNIT9OUT_ADDR = $D7D9  ; @UNITXOUT (address)
UNIT9OUT_ADDR = $D7D9  ; @UNITXOUT (address)
MATH_UNIT9OUT_MASK = 15  ; @UNITXOUT (bit mask)
UNIT9OUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_U9_LOWOUT_ADDR = $D7D9  ; @UXLOWOUT (address)
U9_LOWOUT_ADDR = $D7D9  ; @UXLOWOUT (address)
MATH_U9_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
U9_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_U9_HIOUT_ADDR = $D7D9  ; @UXHIOUT (address)
U9_HIOUT_ADDR = $D7D9  ; @UXHIOUT (address)
MATH_U9_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
U9_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_U9_BSADD_ADDR = $D7D9  ; @UXBSADD (address)
U9_BSADD_ADDR = $D7D9  ; @UXBSADD (address)
MATH_U9_BSADD_MASK = 64  ; @UXBSADD (bit mask)
U9_BSADD_MASK = 64  ; @UXBSADD (bit mask)
MATH_U9_LATCH_ADDR = $D7D9  ; @UXLATCH (address)
U9_LATCH_ADDR = $D7D9  ; @UXLATCH (address)
MATH_U9_LATCH_MASK = 128  ; @UXLATCH (bit mask)
U9_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNITAOUT_ADDR = $D7DA  ; @UNITXOUT (address)
UNITAOUT_ADDR = $D7DA  ; @UNITXOUT (address)
MATH_UNITAOUT_MASK = 15  ; @UNITXOUT (bit mask)
UNITAOUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_UA_LOWOUT_ADDR = $D7DA  ; @UXLOWOUT (address)
UA_LOWOUT_ADDR = $D7DA  ; @UXLOWOUT (address)
MATH_UA_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
UA_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_UA_HIOUT_ADDR = $D7DA  ; @UXHIOUT (address)
UA_HIOUT_ADDR = $D7DA  ; @UXHIOUT (address)
MATH_UA_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
UA_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_UA_BSADD_ADDR = $D7DA  ; @UXBSADD (address)
UA_BSADD_ADDR = $D7DA  ; @UXBSADD (address)
MATH_UA_BSADD_MASK = 64  ; @UXBSADD (bit mask)
UA_BSADD_MASK = 64  ; @UXBSADD (bit mask)
MATH_UA_LATCH_ADDR = $D7DA  ; @UXLATCH (address)
UA_LATCH_ADDR = $D7DA  ; @UXLATCH (address)
MATH_UA_LATCH_MASK = 128  ; @UXLATCH (bit mask)
UA_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNITBOUT_ADDR = $D7DB  ; @UNITXOUT (address)
UNITBOUT_ADDR = $D7DB  ; @UNITXOUT (address)
MATH_UNITBOUT_MASK = 15  ; @UNITXOUT (bit mask)
UNITBOUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_UB_LOWOUT_ADDR = $D7DB  ; @UXLOWOUT (address)
UB_LOWOUT_ADDR = $D7DB  ; @UXLOWOUT (address)
MATH_UB_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
UB_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_UB_HIOUT_ADDR = $D7DB  ; @UXHIOUT (address)
UB_HIOUT_ADDR = $D7DB  ; @UXHIOUT (address)
MATH_UB_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
UB_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_UB_BSADD_ADDR = $D7DB  ; @UXBSADD (address)
UB_BSADD_ADDR = $D7DB  ; @UXBSADD (address)
MATH_UB_BSADD_MASK = 64  ; @UXBSADD (bit mask)
UB_BSADD_MASK = 64  ; @UXBSADD (bit mask)
MATH_UB_LATCH_ADDR = $D7DB  ; @UXLATCH (address)
UB_LATCH_ADDR = $D7DB  ; @UXLATCH (address)
MATH_UB_LATCH_MASK = 128  ; @UXLATCH (bit mask)
UB_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNITCOUT_ADDR = $D7DC  ; @UNITXOUT (address)
UNITCOUT_ADDR = $D7DC  ; @UNITXOUT (address)
MATH_UNITCOUT_MASK = 15  ; @UNITXOUT (bit mask)
UNITCOUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_UC_LOWOUT_ADDR = $D7DC  ; @UXLOWOUT (address)
UC_LOWOUT_ADDR = $D7DC  ; @UXLOWOUT (address)
MATH_UC_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
UC_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_UC_HIOUT_ADDR = $D7DC  ; @UXHIOUT (address)
UC_HIOUT_ADDR = $D7DC  ; @UXHIOUT (address)
MATH_UC_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
UC_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_UC_DVADD_ADDR = $D7DC  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (address)
UC_DVADD_ADDR = $D7DC  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (address)
MATH_UC_DVADD_MASK = 64  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (bit mask)
UC_DVADD_MASK = 64  ; If set, Math Function Unit X acts as a 32-bit adder instead of 32-bit divider. (bit mask)
MATH_UC_LATCH_ADDR = $D7DC  ; @UXLATCH (address)
UC_LATCH_ADDR = $D7DC  ; @UXLATCH (address)
MATH_UC_LATCH_MASK = 128  ; @UXLATCH (bit mask)
UC_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNITDOUT_ADDR = $D7DD  ; @UNITXOUT (address)
UNITDOUT_ADDR = $D7DD  ; @UNITXOUT (address)
MATH_UNITDOUT_MASK = 15  ; @UNITXOUT (bit mask)
UNITDOUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_UD_LOWOUT_ADDR = $D7DD  ; @UXLOWOUT (address)
UD_LOWOUT_ADDR = $D7DD  ; @UXLOWOUT (address)
MATH_UD_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
UD_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_UD_HIOUT_ADDR = $D7DD  ; @UXHIOUT (address)
UD_HIOUT_ADDR = $D7DD  ; @UXHIOUT (address)
MATH_UD_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
UD_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_UD_DVADD_ADDR = $D7DD  ;  (address)
UD_DVADD_ADDR = $D7DD  ;  (address)
MATH_UD_DVADD_MASK = 64  ;  (bit mask)
UD_DVADD_MASK = 64  ;  (bit mask)
MATH_UD_LATCH_ADDR = $D7DD  ; @UXLATCH (address)
UD_LATCH_ADDR = $D7DD  ; @UXLATCH (address)
MATH_UD_LATCH_MASK = 128  ; @UXLATCH (bit mask)
UD_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNITEOUT_ADDR = $D7DE  ; @UNITXOUT (address)
UNITEOUT_ADDR = $D7DE  ; @UNITXOUT (address)
MATH_UNITEOUT_MASK = 15  ; @UNITXOUT (bit mask)
UNITEOUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_UE_LOWOUT_ADDR = $D7DE  ; @UXLOWOUT (address)
UE_LOWOUT_ADDR = $D7DE  ; @UXLOWOUT (address)
MATH_UE_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
UE_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_UE_HIOUT_ADDR = $D7DE  ; @UXHIOUT (address)
UE_HIOUT_ADDR = $D7DE  ; @UXHIOUT (address)
MATH_UE_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
UE_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_UE_DVADD_ADDR = $D7DE  ;  (address)
UE_DVADD_ADDR = $D7DE  ;  (address)
MATH_UE_DVADD_MASK = 64  ;  (bit mask)
UE_DVADD_MASK = 64  ;  (bit mask)
MATH_UE_LATCH_ADDR = $D7DE  ; @UXLATCH (address)
UE_LATCH_ADDR = $D7DE  ; @UXLATCH (address)
MATH_UE_LATCH_MASK = 128  ; @UXLATCH (bit mask)
UE_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_UNITFOUT_ADDR = $D7DF  ; @UNITXOUT (address)
UNITFOUT_ADDR = $D7DF  ; @UNITXOUT (address)
MATH_UNITFOUT_MASK = 15  ; @UNITXOUT (bit mask)
UNITFOUT_MASK = 15  ; @UNITXOUT (bit mask)
MATH_UF_LOWOUT_ADDR = $D7DF  ; @UXLOWOUT (address)
UF_LOWOUT_ADDR = $D7DF  ; @UXLOWOUT (address)
MATH_UF_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
UF_LOWOUT_MASK = 16  ; @UXLOWOUT (bit mask)
MATH_UF_HIOUT_ADDR = $D7DF  ; @UXHIOUT (address)
UF_HIOUT_ADDR = $D7DF  ; @UXHIOUT (address)
MATH_UF_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
UF_HIOUT_MASK = 32  ; @UXHIOUT (bit mask)
MATH_UF_DVADD_ADDR = $D7DF  ;  (address)
UF_DVADD_ADDR = $D7DF  ;  (address)
MATH_UF_DVADD_MASK = 64  ;  (bit mask)
UF_DVADD_MASK = 64  ;  (bit mask)
MATH_UF_LATCH_ADDR = $D7DF  ; @UXLATCH (address)
UF_LATCH_ADDR = $D7DF  ; @UXLATCH (address)
MATH_UF_LATCH_MASK = 128  ; @UXLATCH (bit mask)
UF_LATCH_MASK = 128  ; @UXLATCH (bit mask)
MATH_LATCHINT = $D7E0  ; Latch interval for latched outputs (in CPU cycles)
LATCHINT = $D7E0  ; Latch interval for latched outputs (in CPU cycles)
MATH_WREN_ADDR = $D7E1  ; Enable setting of math registers (must normally be set) (address)
WREN_ADDR = $D7E1  ; Enable setting of math registers (must normally be set) (address)
MATH_WREN_MASK = 1  ; Enable setting of math registers (must normally be set) (bit mask)
WREN_MASK = 1  ; Enable setting of math registers (must normally be set) (bit mask)
MATH_CALCEN_ADDR = $D7E1  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (address)
CALCEN_ADDR = $D7E1  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (address)
MATH_CALCEN_MASK = 2  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (bit mask)
CALCEN_MASK = 2  ; Enable committing of output values from math units back to math registers (clearing effectively pauses iterative formulae) (bit mask)
MATH_RESERVED = $D7E2  ; Reserved
GS_MATH_RESERVED = $D7E3  ; Reserved
MATH_ITERCNT = $D7E4  ; Iteration Counter (32 bit)
GS_MATH_ITERCNT = $D7E5  ; Iteration Counter (32 bit)
GS_MATH_ITERCNT_2 = $D7E6  ; Iteration Counter (32 bit)
GS_MATH_ITERCNT_3 = $D7E7  ; Iteration Counter (32 bit)
MATH_ITERCMP = $D7E8  ; Math iteration counter comparator (32 bit)
GS_MATH_ITERCMP = $D7E9  ; Math iteration counter comparator (32 bit)
GS_MATH_ITERCMP_2 = $D7EA  ; Math iteration counter comparator (32 bit)
GS_MATH_ITERCMP_3 = $D7EB  ; Math iteration counter comparator (32 bit)
CPU_IECBUSACT_ADDR = $D7F1  ; IEC bus is active (address)
IECBUSACT_ADDR = $D7F1  ; IEC bus is active (address)
CPU_IECBUSACT_MASK = 1  ; IEC bus is active (bit mask)
IECBUSACT_MASK = 1  ; IEC bus is active (bit mask)
CPU_PHIPERFRAME = $D7F2  ; Count the number of PHI cycles per video frame (LSB)
GS_CPU_PHIPERFRAME = $D7F5  ; Count the number of PHI cycles per video frame (MSB)
CPU_CYCPERFRAME = $D7F6  ; Count the number of usable (proceed=1) CPU cycles per video frame (LSB)
GS_CPU_CYCPERFRAME = $D7F9  ; Count the number of usable (proceed=1) CPU cycles per video frame (MSB)
CPU_FRAMECOUNT = $D7FA  ; Count number of elapsed video frames
FRAMECOUNT = $D7FA  ; Count number of elapsed video frames
CPU_CARTEN_ADDR = $D7FB  ; 1= enable cartridges (address)
CARTEN_ADDR = $D7FB  ; 1= enable cartridges (address)
CPU_CARTEN_MASK = 2  ; 1= enable cartridges (bit mask)
CARTEN_MASK = 2  ; 1= enable cartridges (bit mask)
CPU_POWEREN_ADDR = $D7FD  ; Set to zero to power off computer on supported systems. WRITE ONLY. (address)
POWEREN_ADDR = $D7FD  ; Set to zero to power off computer on supported systems. WRITE ONLY. (address)
CPU_POWEREN_MASK = 1  ; Set to zero to power off computer on supported systems. WRITE ONLY. (bit mask)
POWEREN_MASK = 1  ; Set to zero to power off computer on supported systems. WRITE ONLY. (bit mask)
CPU_NOGAME_ADDR = $D7FD  ; Override for /GAME : Must be 0 to enable /GAME signal (address)
NOGAME_ADDR = $D7FD  ; Override for /GAME : Must be 0 to enable /GAME signal (address)
CPU_NOGAME_MASK = 64  ; Override for /GAME : Must be 0 to enable /GAME signal (bit mask)
NOGAME_MASK = 64  ; Override for /GAME : Must be 0 to enable /GAME signal (bit mask)
CPU_NOEXROM_ADDR = $D7FD  ; Override for /EXROM : Must be 0 to enable /EXROM signal (address)
NOEXROM_ADDR = $D7FD  ; Override for /EXROM : Must be 0 to enable /EXROM signal (address)
CPU_NOEXROM_MASK = 128  ; Override for /EXROM : Must be 0 to enable /EXROM signal (bit mask)
NOEXROM_MASK = 128  ; Override for /EXROM : Must be 0 to enable /EXROM signal (bit mask)
CPU_PREFETCH_ADDR = $D7FE  ; Enable expansion RAM pre-fetch logic (address)
PREFETCH_ADDR = $D7FE  ; Enable expansion RAM pre-fetch logic (address)
CPU_PREFETCH_MASK = 1  ; Enable expansion RAM pre-fetch logic (bit mask)
PREFETCH_MASK = 1  ; Enable expansion RAM pre-fetch logic (bit mask)
CPU_OCEANA_ADDR = $D7FE  ; Enable Ocean Type A cartridge emulation (address)
OCEANA_ADDR = $D7FE  ; Enable Ocean Type A cartridge emulation (address)
CPU_OCEANA_MASK = 2  ; Enable Ocean Type A cartridge emulation (bit mask)
OCEANA_MASK = 2  ; Enable Ocean Type A cartridge emulation (bit mask)
ETHCOMMAND_DEBUGCPU = $DC  ; Select CPU debug stream via ethernet when \$D6E1.3 is set
DEBUGCPU = $DC  ; Select CPU debug stream via ethernet when \$D6E1.3 is set
CIA1_PORTA = $DC00  ; Port A
CIA1_PORTB = $DC01  ; Port B
CIA1_DDRA = $DC02  ; Port A DDR
CIA1_DDRB = $DC03  ; Port B DDR
CIA1_TIMERA = $DC04  ; Timer A counter (16 bit)
C64_CIA1_TIMERA = $DC05  ; Timer A counter (16 bit)
CIA1_TIMERB = $DC06  ; Timer B counter (16 bit)
C64_CIA1_TIMERB = $DC07  ; Timer B counter (16 bit)
CIA1_TODJIF_ADDR = $DC08  ; TOD tenths of seconds (address)
CIA1_TODJIF_MASK = 15  ; TOD tenths of seconds (bit mask)
CIA1_TODSEC_ADDR = $DC09  ; TOD seconds (address)
CIA1_TODSEC_MASK = 63  ; TOD seconds (bit mask)
CIA1_TODMIN_ADDR = $DC0A  ; TOD minutes (address)
TODMIN_ADDR = $DC0A  ; TOD minutes (address)
CIA1_TODMIN_MASK = 63  ; TOD minutes (bit mask)
TODMIN_MASK = 63  ; TOD minutes (bit mask)
CIA1_TODHOUR_ADDR = $DC0B  ; TOD hours (address)
CIA1_TODHOUR_MASK = 31  ; TOD hours (bit mask)
CIA1_TODAMPM_ADDR = $DC0B  ; TOD PM flag (address)
CIA1_TODAMPM_MASK = 128  ; TOD PM flag (bit mask)
CIA1_SDR = $DC0C  ; shift register data register(writing starts sending)
CIA1_TA_ADDR = $DC0D  ; Timer A underflow (address)
CIA1_TA_MASK = 1  ; Timer A underflow (bit mask)
CIA1_TB_ADDR = $DC0D  ; Timer B underflow (address)
CIA1_TB_MASK = 2  ; Timer B underflow (bit mask)
CIA1_ALRM_ADDR = $DC0D  ; TOD alarm (address)
CIA1_ALRM_MASK = 4  ; TOD alarm (bit mask)
CIA1_SP_ADDR = $DC0D  ; shift register full/empty (address)
CIA1_SP_MASK = 8  ; shift register full/empty (bit mask)
CIA1_FLG_ADDR = $DC0D  ; FLAG edge detected (address)
CIA1_FLG_MASK = 16  ; FLAG edge detected (bit mask)
CIA1_IR_ADDR = $DC0D  ; Interrupt flag (address)
IR_ADDR = $DC0D  ; Interrupt flag (address)
CIA1_IR_MASK = 128  ; Interrupt flag (bit mask)
IR_MASK = 128  ; Interrupt flag (bit mask)
CIA1_STRTA_ADDR = $DC0E  ; Timer A start (address)
CIA1_STRTA_MASK = 1  ; Timer A start (bit mask)
CIA1_PBONA_ADDR = $DC0E  ; Timer A PB6 out (address)
CIA1_PBONA_MASK = 2  ; Timer A PB6 out (bit mask)
CIA1_OMODA_ADDR = $DC0E  ; Timer A toggle or pulse (address)
CIA1_OMODA_MASK = 4  ; Timer A toggle or pulse (bit mask)
CIA1_RMODA_ADDR = $DC0E  ; Timer A one-shot mode (address)
CIA1_RMODA_MASK = 8  ; Timer A one-shot mode (bit mask)
CIA1_IMODA_ADDR = $DC0E  ; Timer A Timer A tick source (address)
CIA1_IMODA_MASK = 32  ; Timer A Timer A tick source (bit mask)
CIA1_SPMOD_ADDR = $DC0E  ; Serial port direction (address)
CIA1_SPMOD_MASK = 64  ; Serial port direction (bit mask)
CIA1_TOD50_ADDR = $DC0E  ; 50/60Hz select for TOD clock (address)
CIA1_TOD50_MASK = 128  ; 50/60Hz select for TOD clock (bit mask)
CIA1_STRTB_ADDR = $DC0F  ; Timer B start (address)
CIA1_STRTB_MASK = 1  ; Timer B start (bit mask)
CIA1_PBONB_ADDR = $DC0F  ; Timer B PB7 out (address)
CIA1_PBONB_MASK = 2  ; Timer B PB7 out (bit mask)
CIA1_OMODB_ADDR = $DC0F  ; Timer B toggle or pulse (address)
CIA1_OMODB_MASK = 4  ; Timer B toggle or pulse (bit mask)
CIA1_RMODB_ADDR = $DC0F  ; Timer B one-shot mode (address)
CIA1_RMODB_MASK = 8  ; Timer B one-shot mode (bit mask)
CIA1_LOAD_ADDR = $DC0F  ; Strobe input to force-load timers (address)
CIA1_LOAD_MASK = 16  ; Strobe input to force-load timers (bit mask)
CIA1_IMODB_ADDR = $DC0F  ; Timer B Timer A tick source (address)
CIA1_IMODB_MASK = 96  ; Timer B Timer A tick source (bit mask)
CIA2_TODEDIT_ADDR = $DC0F  ; TOD alarm edit (address)
CIA2_TODEDIT_MASK = 128  ; TOD alarm edit (bit mask)
CIA1_TALATCH = $DC10  ; Timer A latch value (16 bit)
GS_CIA1_TALATCH = $DC11  ; Timer A latch value (16 bit)
GS_CIA1_TALATCH_2 = $DC12  ; Timer B latch value (16 bit)
GS_CIA1_TALATCH_3 = $DC13  ; Timer B latch value (16 bit)
GS_CIA1_TALATCH_4 = $DC14  ; Timer A current value (16 bit)
GS_CIA1_TALATCH_5 = $DC15  ; Timer A current value (16 bit)
GS_CIA1_TALATCH_6 = $DC16  ; Timer B current value (16 bit)
GS_CIA1_TALATCH_7 = $DC17  ; Timer B current value (16 bit)
GS_CIA1_TODJIF_ADDR = $DC18  ; TOD 10ths of seconds value (address)
GS_CIA1_TODJIF_MASK = 15  ; TOD 10ths of seconds value (bit mask)
CIA1_IMTB_ADDR = $DC18  ; Interrupt mask for Timer B (address)
CIA1_IMTB_MASK = 16  ; Interrupt mask for Timer B (bit mask)
CIA1_IMALRM_ADDR = $DC18  ; Interrupt mask for TOD alarm (address)
CIA1_IMALRM_MASK = 32  ; Interrupt mask for TOD alarm (bit mask)
CIA1_IMSP_ADDR = $DC18  ; Interrupt mask for shift register (serial port) (address)
CIA1_IMSP_MASK = 64  ; Interrupt mask for shift register (serial port) (bit mask)
CIA1_IMFLG_ADDR = $DC18  ; Interrupt mask for FLAG line (address)
CIA1_IMFLG_MASK = 128  ; Interrupt mask for FLAG line (bit mask)
CIA1_TODSEC = $DC19  ; TOD Alarm seconds value
CIA1_TODMIN = $DC1A  ; TOD Alarm minutes value
GS_CIA1_TODHOUR_ADDR = $DC1B  ; TOD hours value (address)
GS_CIA1_TODHOUR_MASK = 127  ; TOD hours value (bit mask)
GS_CIA1_TODAMPM_ADDR = $DC1B  ; TOD AM/PM flag (address)
GS_CIA1_TODAMPM_MASK = 128  ; TOD AM/PM flag (bit mask)
CIA1_ALRMJIF = $DC1C  ; TOD Alarm 10ths of seconds value
CIA1_ALRMSEC = $DC1D  ; TOD Alarm seconds value
CIA1_ALRMMIN = $DC1E  ; TOD Alarm minutes value
CIA1_ALRMHOUR_ADDR = $DC1F  ; TOD Alarm hours value (address)
CIA1_ALRMHOUR_MASK = 127  ; TOD Alarm hours value (bit mask)
CIA1_ALRMAMPM_ADDR = $DC1F  ; TOD Alarm AM/PM flag (address)
CIA1_ALRMAMPM_MASK = 128  ; TOD Alarm AM/PM flag (bit mask)
CIA2_PORTA = $DD00  ; Port A
CIA2_PORTB = $DD01  ; Port B
CIA2_DDRA = $DD02  ; Port A DDR
CIA2_DDRB = $DD03  ; Port B DDR
CIA2_TIMERA = $DD04  ; Timer A counter (16 bit)
C64_CIA2_TIMERA = $DD05  ; Timer A counter (16 bit)
CIA2_TIMERB = $DD06  ; Timer B counter (16 bit)
C64_CIA2_TIMERB = $DD07  ; Timer B counter (16 bit)
CIA2_TODJIF_ADDR = $DD08  ; TOD tenths of seconds (address)
CIA2_TODJIF_MASK = 15  ; TOD tenths of seconds (bit mask)
CIA2_TODSEC_ADDR = $DD09  ; TOD seconds (address)
CIA2_TODSEC_MASK = 63  ; TOD seconds (bit mask)
CIA2_TODHOUR_ADDR = $DD0B  ; TOD hours (address)
CIA2_TODHOUR_MASK = 31  ; TOD hours (bit mask)
CIA2_TODAMPM_ADDR = $DD0B  ; TOD PM flag (address)
CIA2_TODAMPM_MASK = 128  ; TOD PM flag (bit mask)
CIA2_SDR = $DD0C  ; shift register data register(writing starts sending)
CIA2_TA_ADDR = $DD0D  ; Timer A underflow (address)
CIA2_TA_MASK = 1  ; Timer A underflow (bit mask)
CIA2_TB_ADDR = $DD0D  ; Timer B underflow (address)
CIA2_TB_MASK = 2  ; Timer B underflow (bit mask)
CIA2_ALRM_ADDR = $DD0D  ; TOD alarm (address)
CIA2_ALRM_MASK = 4  ; TOD alarm (bit mask)
CIA2_SP_ADDR = $DD0D  ; shift register full/empty (address)
CIA2_SP_MASK = 8  ; shift register full/empty (bit mask)
CIA2_FLG_ADDR = $DD0D  ; FLAG edge detected (address)
CIA2_FLG_MASK = 16  ; FLAG edge detected (bit mask)
CIA2_STRTA_ADDR = $DD0E  ; Timer A start (address)
CIA2_STRTA_MASK = 1  ; Timer A start (bit mask)
CIA2_PBONA_ADDR = $DD0E  ; Timer A PB6 out (address)
CIA2_PBONA_MASK = 2  ; Timer A PB6 out (bit mask)
CIA2_OMODA_ADDR = $DD0E  ; Timer A toggle or pulse (address)
CIA2_OMODA_MASK = 4  ; Timer A toggle or pulse (bit mask)
CIA2_RMODA_ADDR = $DD0E  ; Timer A one-shot mode (address)
CIA2_RMODA_MASK = 8  ; Timer A one-shot mode (bit mask)
CIA2_IMODA_ADDR = $DD0E  ; Timer A Timer A tick source (address)
CIA2_IMODA_MASK = 32  ; Timer A Timer A tick source (bit mask)
CIA2_SPMOD_ADDR = $DD0E  ; Serial port direction (address)
CIA2_SPMOD_MASK = 64  ; Serial port direction (bit mask)
CIA2_TOD50_ADDR = $DD0E  ; 50/60Hz select for TOD clock (address)
CIA2_TOD50_MASK = 128  ; 50/60Hz select for TOD clock (bit mask)
CIA2_STRTB_ADDR = $DD0F  ; Timer B start (address)
CIA2_STRTB_MASK = 1  ; Timer B start (bit mask)
CIA2_PBONB_ADDR = $DD0F  ; Timer B PB7 out (address)
CIA2_PBONB_MASK = 2  ; Timer B PB7 out (bit mask)
CIA2_OMODB_ADDR = $DD0F  ; Timer B toggle or pulse (address)
CIA2_OMODB_MASK = 4  ; Timer B toggle or pulse (bit mask)
CIA2_RMODB_ADDR = $DD0F  ; Timer B one-shot mode (address)
CIA2_RMODB_MASK = 8  ; Timer B one-shot mode (bit mask)
CIA2_LOAD_ADDR = $DD0F  ; Strobe input to force-load timers (address)
CIA2_LOAD_MASK = 16  ; Strobe input to force-load timers (bit mask)
CIA2_IMODB_ADDR = $DD0F  ; Timer B Timer A tick source (address)
CIA2_IMODB_MASK = 96  ; Timer B Timer A tick source (bit mask)
C64_CIA2_TODEDIT_ADDR = $DD0F  ; TOD alarm edit (address)
C64_CIA2_TODEDIT_MASK = 128  ; TOD alarm edit (bit mask)
CIA2_TALATCH = $DD10  ; Timer A latch value (16 bit)
GS_CIA2_TALATCH = $DD11  ; Timer A latch value (16 bit)
GS_CIA2_TALATCH_2 = $DD12  ; Timer B latch value (16 bit)
GS_CIA2_TALATCH_3 = $DD13  ; Timer B latch value (16 bit)
GS_CIA2_TALATCH_4 = $DD14  ; Timer A current value (16 bit)
GS_CIA2_TALATCH_5 = $DD15  ; Timer A current value (16 bit)
GS_CIA2_TALATCH_6 = $DD16  ; Timer B current value (16 bit)
GS_CIA2_TALATCH_7 = $DD17  ; Timer B current value (16 bit)
GS_CIA2_TODJIF_ADDR = $DD18  ; TOD 10ths of seconds value (address)
GS_CIA2_TODJIF_MASK = 15  ; TOD 10ths of seconds value (bit mask)
CIA2_IMTB_ADDR = $DD18  ; Interrupt mask for Timer B (address)
CIA2_IMTB_MASK = 16  ; Interrupt mask for Timer B (bit mask)
CIA2_IMALRM_ADDR = $DD18  ; Interrupt mask for TOD alarm (address)
CIA2_IMALRM_MASK = 32  ; Interrupt mask for TOD alarm (bit mask)
CIA2_IMSP_ADDR = $DD18  ; Interrupt mask for shift register (serial port) (address)
CIA2_IMSP_MASK = 64  ; Interrupt mask for shift register (serial port) (bit mask)
CIA2_IMFLG_ADDR = $DD18  ; Interrupt mask for FLAG line (address)
CIA2_IMFLG_MASK = 128  ; Interrupt mask for FLAG line (bit mask)
CIA2_TODSEC = $DD19  ; TOD Alarm seconds value
CIA2_TODMIN = $DD1A  ; TOD Alarm minutes value
GS_CIA2_TODHOUR_ADDR = $DD1B  ; TOD hours value (address)
GS_CIA2_TODHOUR_MASK = 127  ; TOD hours value (bit mask)
GS_CIA2_TODAMPM_ADDR = $DD1B  ; TOD AM/PM flag (address)
GS_CIA2_TODAMPM_MASK = 128  ; TOD AM/PM flag (bit mask)
CIA2_ALRMJIF = $DD1C  ; TOD Alarm 10ths of seconds value
CIA2_DD00DELAY_ADDR = $DD1C  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (address)
DD00DELAY_ADDR = $DD1C  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (address)
CIA2_DD00DELAY_MASK = 128  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (bit mask)
DD00DELAY_MASK = 128  ; Enable delaying writes to $DD00 by 3 cycles to match real 6502 timing (bit mask)
CIA2_ALRMSEC = $DD1D  ; TOD Alarm seconds value
CIA2_ALRMMIN = $DD1E  ; TOD Alarm minutes value
CIA2_ALRMHOUR_ADDR = $DD1F  ; TOD Alarm hours value (address)
CIA2_ALRMHOUR_MASK = 127  ; TOD Alarm hours value (bit mask)
CIA2_ALRMAMPM_ADDR = $DD1F  ; TOD Alarm AM/PM flag (address)
CIA2_ALRMAMPM_MASK = 128  ; TOD Alarm AM/PM flag (bit mask)
ETHCOMMAND_RXONLYONE = $DE  ; Receive exactly one ethernet frame only, and keep all signals states (for debugging ethernet sub-system)
RXONLYONE = $DE  ; Receive exactly one ethernet frame only, and keep all signals states (for debugging ethernet sub-system)
ETHCOMMAND_FRAME1K = $F1  ; Select ~1KiB frames for video/cpu debug stream frames (for receivers that do not support MTUs of greater than 2KiB)
FRAME1K = $F1  ; Select ~1KiB frames for video/cpu debug stream frames (for receivers that do not support MTUs of greater than 2KiB)
ETHCOMMAND_FRAME2K = $F2  ; Select ~2KiB frames for video/cpu debug stream frames, for optimal performance.
FRAME2K = $F2  ; Select ~2KiB frames for video/cpu debug stream frames, for optimal performance.
SUMMARY_CHARWRITE = $FF7E000  ; VIC-IV CHARROM write area
CHARWRITE = $FF7E000  ; VIC-IV CHARROM write area
SUMMARY_COLOURRAM = $FF80000  ; Colour RAM (32KB or 64KB)
COLOURRAM = $FF80000  ; Colour RAM (32KB or 64KB)
RTC_RTCSEC = $FFD7110  ; Real-time Clock seconds value (binary coded decimal)
RTCSEC = $FFD7110  ; Real-time Clock seconds value (binary coded decimal)
RTC_RTC = $FFD7110  ; Real-time Clock
RTC = $FFD7110  ; Real-time Clock
RTC_RTCMIN = $FFD7111  ; Real-time Clock minutes value (binary coded decimal)
RTCMIN = $FFD7111  ; Real-time Clock minutes value (binary coded decimal)
RTC_RTCHOUR = $FFD7112  ; Real-time Clock hours value (binary coded decimal)
RTCHOUR = $FFD7112  ; Real-time Clock hours value (binary coded decimal)
RTC_RTCDAY = $FFD7113  ; Real-time Clock day of month value (binary coded decimal)
RTCDAY = $FFD7113  ; Real-time Clock day of month value (binary coded decimal)
RTC_RTCMONTH = $FFD7114  ; Real-time Clock month value (binary coded decimal)
RTCMONTH = $FFD7114  ; Real-time Clock month value (binary coded decimal)
RTC_RTCYEAR = $FFD7115  ; Real-time Clock year value (binary coded decimal)
RTCYEAR = $FFD7115  ; Real-time Clock year value (binary coded decimal)
RTC_NVRAM = $FFD7140  ; 64-bytes of non-volatile RAM. Can be used for storing machine configuration.
NVRAM = $FFD7140  ; 64-bytes of non-volatile RAM. Can be used for storing machine configuration.
SUMMARY_HYPERVISOR = $FFF8000  ; 16KB Hyppo/Hypervisor ROM
HYPERVISOR = $FFF8000  ; 16KB Hyppo/Hypervisor ROM
